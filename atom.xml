<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>等疾风</title>
  
  <subtitle>正在捣鼓协程</subtitle>
  <link href="https://codesire-deng.github.io/atom.xml" rel="self"/>
  
  <link href="https://codesire-deng.github.io/"/>
  <updated>2022-10-25T07:43:55.647Z</updated>
  <id>https://codesire-deng.github.io/</id>
  
  <author>
    <name>等疾风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Archlinux装机笔记</title>
    <link href="https://codesire-deng.github.io/2022/10/24/Archlinux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://codesire-deng.github.io/2022/10/24/Archlinux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-24T11:39:00.000Z</published>
    <updated>2022-10-25T07:43:55.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>重要数据·务必备份</strong>！固态硬盘报废，连带 Linux 无了，只能重装。丫的一点都不省心，每次装机必出 BUG。写一篇笔记，希望一劳永逸。</p><span id="more"></span><h2 id="进入桌面前"><a href="#进入桌面前" class="headerlink" title="进入桌面前"></a>进入桌面前</h2><h3 id="准备装机盘"><a href="#准备装机盘" class="headerlink" title="准备装机盘"></a>准备装机盘</h3><ol><li>在 <a href="https://archlinux.org/download/">archlinux</a> 找到镜像源，下载 ISO。</li><li>用 <a href="https://rufus.ie/zh/">Rufus</a> 之类的刷 U 盘。<ul><li>MBR 分区</li><li>ISO 模式</li></ul></li></ol><h3 id="引导进装机盘"><a href="#引导进装机盘" class="headerlink" title="引导进装机盘"></a>引导进装机盘</h3><p>华硕主板的快捷键是 <code>F11</code>。如果黑屏，将 DP 线换成 HDMI。</p><h3 id="archinstall"><a href="#archinstall" class="headerlink" title="archinstall"></a>archinstall</h3><ol><li>进临时操作系统之后，连网线，运行 <code>archinstall</code>。</li><li>选镜像源（mirror region）</li><li>选择格式化硬盘</li><li>创建 superuser。</li><li>其他选项都检查一下。archinstall 可能会有大幅的更新。</li><li>install! </li><li>最后提示 chroot，在里面 <code>systemctl enable sddm</code>。</li></ol><h3 id="卡-wayland"><a href="#卡-wayland" class="headerlink" title="卡 wayland"></a>卡 wayland</h3><p>N 卡 + nvidia 专有驱动 + wayland &#x3D; 黑屏</p><p>在 <code>~/.local/share/sddm/wayland-session.log</code> 可查看 log。</p><ol><li>先用 X11 登陆，把环境都配置好再回来。</li><li>添加内核参数：<code>nvidia-drm.modeset=1</code>。这是 wayland 要求的。<ul><li>适用于 systemd-boot：<code>kate /boot/loader/entries/xxxx.conf</code>。追加参数。</li></ul></li><li>已经能用了，但是 BUG 很多又卡顿，Fuck Nvidia。遂放弃，或者<a href="https://forum.manjaro.org/t/installing-video-nvidia-causes-kde-sddm-to-fail-to-load/110395/6">参考</a></li></ol><h2 id="进入桌面后"><a href="#进入桌面后" class="headerlink" title="进入桌面后"></a>进入桌面后</h2><h3 id="添加-sudo-免密"><a href="#添加-sudo-免密" class="headerlink" title="添加 sudo 免密"></a>添加 sudo 免密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">vim /etc/sudoers.d/00_codesire</span><br><span class="line"><span class="comment"># 内容如下</span></span><br><span class="line">codesire ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><h3 id="调整快捷键"><a href="#调整快捷键" class="headerlink" title="调整快捷键"></a>调整快捷键</h3><ol><li>Konsole</li><li>System Settings</li><li>KRunner</li><li>（后面安装的）Flameshot: <code>/usr/bin/flameshot gui</code></li></ol><h3 id="安装-yay"><a href="#安装-yay" class="headerlink" title="安装 yay"></a>安装 yay</h3><p>利用 git 下载预编译版安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">mkdir</span> -p .<span class="built_in">local</span>/opt &amp;&amp; <span class="built_in">cd</span> .<span class="built_in">local</span>/opt</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay-bin.git</span><br><span class="line"><span class="built_in">cd</span> yay-bin &amp;&amp; makepkg -si</span><br></pre></td></tr></table></figure><h3 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">mkdir</span> -p .config/fontconfig</span><br><span class="line">kate .config/fontconfig/fonts.conf</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;urn:fontconfig:fonts.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- $&#123;XDG_CONFIG_HOME&#125;/fontconfig/fonts.conf</span></span><br><span class="line"><span class="comment">        - vim:ft=xml:fenc=utf-8:noet:ts=3:sw=3:</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;antialias&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;autohint&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dpi&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">double</span>&gt;</span>96<span class="tag">&lt;/<span class="name">double</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hinting&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hintstyle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>hintslight<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lcdfilter&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>lcdlight<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rgba&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>rgb<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">int</span>&gt;</span>15<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dir</span>&gt;</span>~/.fonts<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新字体缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure><p>可能需要重启生效，但是先不重启。</p><h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>谜之 CPU 软件包，不要全装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S amd-ucode</span><br><span class="line">sudo pacman -S intel-ucode</span><br></pre></td></tr></table></figure><p>man，浏览器，输入法，vscode，openssh，firacode，flameshot：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S man-db man-pages google-chrome-stable fcitx5-im fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-pinyin-zhwiki visual-studio-code-bin openssh ttf-fira-code nerd-fonts-fira-code flameshot</span><br></pre></td></tr></table></figure><p>在 System Settings 添加 Pinyin 输入。修改切换输入法的快捷键。</p><p>如果需要开启启动 sshd：<code>systemctl enable --now sshd</code></p><p>网络自由，Fuck Timeout：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -Ls https://mirrors.v2raya.org/go.sh | sudo bash</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> v2ray --now</span><br><span class="line">yay -S v2raya-bin</span><br><span class="line">sudo systemctl start v2raya.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> v2raya.service</span><br></pre></td></tr></table></figure><p>进浏览器管理 <code>127.0.0.1:2017</code>。</p><h3 id="还原-zsh"><a href="#还原-zsh" class="headerlink" title="还原 zsh"></a>还原 zsh</h3><p>参考 <a href="https://github.com/Codesire-Deng/rc">Codesire-Deng&#x2F;rc</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yay -S zsh</span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">yay -S zsh-syntax-highlighting-git</span><br></pre></td></tr></table></figure><ul><li>覆盖拷贝 <a href="https://github.com/Codesire-Deng/rc">Codesire-Deng&#x2F;rc</a> 的配置文件。</li><li>安装完后，调整 konsole 和 vscode 的默认终端。</li></ul><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>C++ 相关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S linux-headers cmake clang mimalloc boost cloc </span><br></pre></td></tr></table></figure><p>Node 相关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/tj/n/master/bin/n -o n</span><br><span class="line">sudo bash n lts</span><br><span class="line">sudo npm install -g n</span><br><span class="line"><span class="built_in">rm</span> n</span><br><span class="line">sudo npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h3><p>参考 <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Github Docs</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;oi_dzf@qq.com&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><p>将公钥添加到 <a href="https://github.com/settings/keys">Github SSH keys</a>。</p><h3 id="systemd-boot-追加-Windows"><a href="#systemd-boot-追加-Windows" class="headerlink" title="systemd-boot 追加 Windows"></a>systemd-boot 追加 Windows</h3><ol><li>找到 Windows EFI 分区：<ul><li><code>lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT</code></li></ul></li><li>挂载这个分区：<ul><li><code>sudo mkdir /mnt/win-efi</code></li><li><code>sudo mount /dev/sdb1xxx /mnt/win-efi</code></li></ul></li><li>拷贝 Windows EFI 到当前硬盘的 EFI（<code>/boot/EFI</code>在不同系统下可能不同，例如可能是<code>/boot/efi/EFI</code>）<ul><li><code>sudo cp -r /mnt/win-efi/EFI/Microsoft /boot/EFI</code></li></ul></li><li>修改 bootloader 的配置，例如倒计时<ul><li>参考 <a href="https://wiki.archlinux.org/title/Systemd-boot">Wiki: Systemd-boot</a></li><li><code>kate /boot/loader/loader.conf</code></li></ul></li><li>重启即可。在选择界面按 <code>d</code> 即可指定默认项。</li></ol><h3 id="附：Windows-改为-UTC-时间"><a href="#附：Windows-改为-UTC-时间" class="headerlink" title="附：Windows 改为 UTC 时间"></a>附：Windows 改为 UTC 时间</h3><p>新建<code>UTC.reg</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]</span><br><span class="line">&quot;RealTimeIsUniversal&quot;=dword:00000001</span><br></pre></td></tr></table></figure><p>用管理员运行之即可。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>珍爱生命，珍惜时间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重要数据·务必备份&lt;/strong&gt;！固态硬盘报废，连带 Linux 无了，只能重装。丫的一点都不省心，每次装机必出 BUG。写一篇笔记，希望一劳永逸。&lt;/p&gt;</summary>
    
    
    
    
    <category term="减少脱发指南" scheme="https://codesire-deng.github.io/tags/%E5%87%8F%E5%B0%91%E8%84%B1%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>co_context[2]: 性能优化杂谈</title>
    <link href="https://codesire-deng.github.io/2022/06/25/co-context-2/"/>
    <id>https://codesire-deng.github.io/2022/06/25/co-context-2/</id>
    <published>2022-06-25T15:06:00.000Z</published>
    <updated>2022-06-25T15:23:28.900Z</updated>
    
    <content type="html"><![CDATA[<p>Hello，我是等疾风！本篇介绍在 <a href="https://github.com/Codesire-Deng/co_context">co_context</a> 中用到的性能优化技巧，希望在各位 C&#x2F;C++ 道友的项目上有所帮助。<strong>重点将在技巧的入门</strong>，而不是 co_context 本身。</p><span id="more"></span><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>大多数情况下，我们其实是在优化已有的代码，而不是在设计全新的高性能业务。所以建议在优化之前，先分析出哪些代码是<strong>热点</strong>，哪些代码占用最多的<strong>运行时间&#x2F;空间</strong>，然后再针对性地做优化。相关的工具有 perf，vtune，valgrind 等等。需注意性能分析工具会不会<strong>拖慢程序运行速度</strong>（例如 valgrind，好家伙直接令我的程序假死），因为这会带来测量的误差。</p><p>除了现成工具，还可以用 <strong>rdtsc 指令</strong>做低损耗、高精度的时间测量。</p><p>在 co_context 里，性能在一开始就是设计重点，所以会减轻一些总体工作量。</p><h2 id="无锁化"><a href="#无锁化" class="headerlink" title="无锁化"></a>无锁化</h2><h3 id="细数互斥锁「四宗罪」"><a href="#细数互斥锁「四宗罪」" class="headerlink" title="细数互斥锁「四宗罪」"></a>细数互斥锁「四宗罪」</h3><p>无锁设计，是性能优化入门的一道坎。我们在写多线程程序时，很自然想到用<strong>互斥锁（mutex）</strong>来保护共享数据，防止读到脏数据，防止竞争条件（race condition）。互斥锁还有信号量（semaphore），条件变量等变体，它们的原理都是类似的。但它们会有一些性能缺陷：</p><ol><li>和线程高度绑定：如果互斥锁抢不到，线程就陷入<strong>阻塞</strong>；</li><li>引入额外的数据结构：至少有一条唤醒<strong>队列</strong>，记录哪些线程等待唤醒；且这条队列是<strong>不定长</strong>的；</li><li>和操作系统高度绑定：线程的阻塞和唤醒都要走操作系统<strong>内核态</strong>；会打断 CPU 流水线，所以极致性能优化下一般不喜欢看见内核态；</li><li>要切换上下文：每次切线程都要暂存和恢复寄存器的值，可能引发<strong>内存 I&#x2F;O</strong>。</li></ol><p>说了一堆屁话，总之<strong>能避开互斥锁就避开</strong>，而 co_context 比较无脑粗暴，几乎直接禁用了互斥锁。这也会带来一些副作用：线程在空闲的时候也没法阻塞，会导致 CPU 空转，对于其他进程来说无疑是 CPU 强盗。（所以我也给出了备选方案：使用 <code>std::atomic&lt;xxx&gt;::wait/notify</code>，它的原理类似 futex，线程可以阻塞）</p><h3 id="无锁世界的秩序"><a href="#无锁世界的秩序" class="headerlink" title="无锁世界的秩序"></a>无锁世界的秩序</h3><p>无锁世界的秩序主要靠<strong>「原子变量」</strong>来维持。原子变量本质是对 CPU 内存顺序、原子指令、编译器乱序约束的封装。本节只做最基本的入门介绍，入门之后，读者可以快速读懂其他文章。</p><p>比方说，县长说他到鹅城来，只干三件事，然后就离开。这三件事涉及机密，完成之前外人没法知道其状态。有一天，县长离开了鹅城，说明「三件事」已经完成了。至于是哪件事先做完，哪件事后做完，民间众说纷纭。</p><p>在例子中，我们令「县长的位置」为原子变量，若「县长的位置」≠「鹅城」，则编译器和 CPU 保证三件「事」已经完成，但是，由于乱序优化和内存顺序等问题，这三件「事」的完成顺序是不确定的。所幸，我们不关心顺序，只要访问这三件「事」的结果就可以了。</p><p>于是，我们解锁了两种 C++ 内存顺序：<code>std::memory_order_release</code> 和 <code>std::memory_order_acquire</code></p><p>我们结合代码举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; distance_from_e_city = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="built_in">do_A</span>();</span><br><span class="line"><span class="built_in">do_B</span>();</span><br><span class="line"><span class="built_in">do_C</span>();</span><br><span class="line">distance_from_e_city.<span class="built_in">store</span>(<span class="number">100</span>, std::memory_order_release); <span class="comment">// 瞬移100公里不过分吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (distance_from_e_city.<span class="built_in">load</span>(std::memory_order_acquire) &gt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="built_in">use_A</span>(); <span class="comment">// 必定能看见do_A的结果</span></span><br><span class="line">    <span class="built_in">use_B</span>();</span><br><span class="line">    <span class="built_in">use_C</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会保证<code>std::memory_order_release</code>之前的指令不会被乱序到其之后，但是不保证<code>do_A()</code> <code>do_B()</code> <code>do_C()</code>之间的乱序。</p><p>对称地， 保证<code>std::memory_order_acquire</code>之后的指令不会被乱序到其之前，但是不保证<code>use_A()</code> <code>use_B()</code> <code>use_C()</code>之间的乱序。</p><p>最终，以原子变量为桥梁，我们实现了安全的共享数据访问。读者可以学习<code>std::memory_order_seq_cst</code> <code>std::memory_order_relaxed</code> 等等来解锁更多姿势。关键词：C++ 内存顺序</p><h3 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h3><p>理解内存顺序之后，就能轻松上手无锁数据结构了。**定长单生产者单消费者队列(SPSC queue)**是一种高性能的无锁队列，它有很多约束：容量固定、只支持一个生产者和一个消费者。但它的延迟非常低，实现非常简单，只依赖内存顺序，不依赖互斥锁。co_context 用了 n 条 SPSC 队列来模拟“单生多消”和“多生单消”功能。</p><p>其实，保证越少，性能越高。SPSC 队列尚且保留了「先进先出」的队列性质，倘若抛弃队列性质，还有更猛的乱序数据结构，性能提高可逼近100%。但是，乱序性会带来太高的 debug 难度，在负载均衡上也不实用，最终还是被我弃用了。</p><h3 id="用户态互斥锁"><a href="#用户态互斥锁" class="headerlink" title="用户态互斥锁"></a>用户态互斥锁</h3><p>底层开发者可以承受没有互斥锁的不便，但不能不给应用层提供互斥锁的等价工具。co_context 给用户提供了互斥锁、信号量和条件变量，它们的 API 与 C++ 标准库几乎一致，在体验上没有差别，在实现上性能会略强，一是因为无等待且完全<strong>不经过内核态</strong>，二是因为没有<strong>引入堆内存分配</strong>。涉及的技巧比较复杂，在这里就不展开介绍了，关键词：用<strong>侵入式链表</strong>实现等待队列。这里推荐参考 <a href="https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/async_mutex.hpp">cppcoro</a> 的互斥锁实现。</p><h2 id="cacheline-编排"><a href="#cacheline-编排" class="headerlink" title="cacheline 编排"></a>cacheline 编排</h2><p>常见 CPU 的内存读写都是以 64 字节为单位的，对应 CPU 的 cache 也是每 64 字节为一个「cacheline」。性能优化的必修课之一是妥善安排数据在 cache 中的位置。不妥的安排会导致以下情况：</p><ol><li><strong>伪共享（false sharing）</strong>：线程 1 读写变量 a，线程 2 读写变量 b，本是老死不相往来，却偏偏让 a 和 b 处于同一 cacheline。</li><li><strong>乒乓缓存（cacheline ping-ponging）</strong>：常见于伪共享。变量 a 和 b 位于同一 cacheline，线程 1 只读 a，线程 2 频繁改写 b。结果，每当 b 被线程 2 修改时，线程 1 都要同步 a 所在的 cacheline，这实际上是多余的。</li><li>多余读写：常见于指针解引用、通讯协议。可以只用一条 cacheline 完成跨核通讯，实际却用了多条。</li><li>cache 浪费：偷懒，无脑塞 64 字节做 padding。这是不负责任的做法，本质只是将 cache-miss 转移到其他数据上。</li></ol><p>只要善用 C++ 的<code>alignas</code>关键字，针对以上问题，相信读者能想出优化的办法。</p><p>co_context 大量使用了 <code>alignas(64)</code>来指定结构体在 cacheline 中的位置，以优化性能。</p><h2 id="跨核通信压缩"><a href="#跨核通信压缩" class="headerlink" title="跨核通信压缩"></a>跨核通信压缩</h2><p>这一节也与 CPU cache 有关。</p><h3 id="解引用真的有必要吗？"><a href="#解引用真的有必要吗？" class="headerlink" title="解引用真的有必要吗？"></a>解引用真的有必要吗？</h3><p>在多线程程序里，经常见到线程 1 写入变量 a，然后将 <code>p=&amp;a</code> 告诉线程 2，最后，线程 2 读取<code>*p</code> 。这里大概率涉及了两条 cacheline 的同步：一条是指针 p，另一条是<code>*p</code>也就是变量 a。 但这真的有必要吗？</p><p>以 co_context 为例，优化前，线程 1 写入 <code>a.type = xxx</code> ，<code>p = &amp;a</code>交给线程 2，线程 2 根据 <code>p-&gt;type</code> 做不同的操作。但是，由于 <code>a.type</code> 只有 8 种取值 ，对应二进制 3 个 bit，而变量 a 正好是按照 8 字节对齐的，a 的地址末尾 3 个 bit 必然为 0，意味着 <code>p = &amp;a</code> 的末尾 3 个 bit 没有携带任何信息。那么为什么不让这 3 个 bit 存放 <code>a.type</code> 呢？</p><p>于是，优化后，线程 1 写入<code>p = &amp;a; p |= a.type = xxx;</code> ，p 交给线程 2，线程 2 根据 <code>p &amp; 7</code> 做不同的转发，全过程没有解引用 p，节省了一次 cacheline 传播。</p><h3 id="使用-union-但不是-std-variant"><a href="#使用-union-但不是-std-variant" class="headerlink" title="使用 union 但不是 std::variant"></a>使用 union 但不是 std::variant</h3><p>（这一条建议非常激进，读者一旦使用，最好补上充足的文档）</p><p>使用 union（联合体）可以进一步压缩 struct 的体积。每当用 union 将 struct 的体积减小到 n*64，每次同步 cacheline 所传输的信息量就会提升，理论性能就会出现一次质变。</p><p>用 std::variant 也能达到压缩体积的目的，但是 std::variant 的以类型为单位的多态粒度比较粗糙，内置的异常处理也带来了性能损耗，在极致性能优化时可能会禁用（但 std::variant 满足普通项目是绰绰有余了）。</p><h2 id="批处理请求"><a href="#批处理请求" class="headerlink" title="批处理请求"></a>批处理请求</h2><p>在 co_context 中，很容易完成一个批处理优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">A_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">B_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">C_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="built_in">co_await</span> (<span class="built_in">A_IO</span>(&amp;buf) &amp;&amp; <span class="built_in">B_IO</span>(&amp;buf) &amp;&amp; <span class="built_in">C_IO</span>(&amp;buf));</span><br></pre></td></tr></table></figure><p>上面的例子，原本要进入调度器 3 次，将 I&#x2F;O 请求提交给内核态 3 次，在优化后统统变为 1 次。批处理优化的思想无论在底层还是架构层应用层都是非常实用的。</p><p>要留意的是批处理是否会<strong>对延迟造成不可接受的影响</strong>，如果为了批处理而强行等待，可能得不偿失。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了一些 C++ 性能优化的技巧，重点是内存顺序和 CPU cache。虽然性能优化的水很深，需要大量的基础知识和经验积累，但正因此我们有机会为世界做别出心裁的贡献，坚定前行吧骚年！最后，放两张祖传的 co_context 性能测试图：</p><p>netcat 网络吞吐（单连接）：<br><img src="/2022/06/25/co-context-2/netcat.png" alt="netcat"></p><p>redis-benchmark QPS 和平均延迟（单线程）：<br><img src="/2022/06/25/co-context-2/redis-single-thread.png" alt="redis-benchmark"></p><hr><p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hello，我是等疾风！本篇介绍在 &lt;a href=&quot;https://github.com/Codesire-Deng/co_context&quot;&gt;co_context&lt;/a&gt; 中用到的性能优化技巧，希望在各位 C&amp;#x2F;C++ 道友的项目上有所帮助。&lt;strong&gt;重点将在技巧的入门&lt;/strong&gt;，而不是 co_context 本身。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="C++协程" scheme="https://codesire-deng.github.io/tags/C-%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="co_context" scheme="https://codesire-deng.github.io/tags/co-context/"/>
    
  </entry>
  
  <entry>
    <title>co_context[1]: 易用性设计</title>
    <link href="https://codesire-deng.github.io/2022/06/25/co-context-1/"/>
    <id>https://codesire-deng.github.io/2022/06/25/co-context-1/</id>
    <published>2022-06-25T14:17:00.000Z</published>
    <updated>2022-06-25T15:23:35.657Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Codesire-Deng/co_context">co_context</a> 是最近开发的 C++ 异步协程框架，基于 Linux io_uring。<strong>「易用性」</strong>和「性能」是我们最重视的属性，这篇文章，我们介绍在 co_context 中有关易用性的设计。</p><span id="more"></span><h2 id="I-x2F-O：同步风格，业务专注"><a href="#I-x2F-O：同步风格，业务专注" class="headerlink" title="I&#x2F;O：同步风格，业务专注"></a>I&#x2F;O：同步风格，业务专注</h2><p>任何有意义的计算机程序都需要做 I&#x2F;O，为了提高性能，我们不得不追求更好的 I&#x2F;O 模型。很多网络文章将 I&#x2F;O 模型分成阻塞、非阻塞、多路复用等多种，但本人不太喜欢这种分类（阻塞+非阻塞≠全集，违反直觉）。从代码风格上，我将 I&#x2F;O 模型分成两种：同步式，函数回调式。</p><p>以一个简单需求为例：等待五秒钟后，打印“Hello, world!”。我们对比一下同步式和函数回调的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步式，使用C++标准库</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delay_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    <span class="built_in">printf</span>(“Hello, world!\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务代码中使用</span></span><br><span class="line"><span class="built_in">delay_print</span>(); <span class="comment">// 导致当前线程会阻塞5秒</span></span><br><span class="line">std::thread t&#123;delay_print&#125;; <span class="comment">// 生成新线程，令其阻塞5秒</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步式，使用co_context</span></span><br><span class="line"><span class="function">task&lt;<span class="type">void</span>&gt; <span class="title">delay_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">timeout</span><span class="params">(<span class="number">5</span>s)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(“Hello, world!\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务代码中使用</span></span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">delay_print</span><span class="params">()</span></span>; <span class="comment">// 当前协程暂停5秒后被继续执行；当前线程不阻塞（转而执行其他协程）</span></span><br><span class="line"><span class="built_in">co_spawn</span>(<span class="built_in">delay_print</span>()); <span class="comment">// 生成一个新协程，5秒后被执行；当前协程继续执行</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数回调，使用Boost.Asio</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> error_code &amp; <span class="comment">/*e*/</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context io;</span><br><span class="line">    <span class="function">asio::steady_timer <span class="title">t</span><span class="params">(io, <span class="number">5</span>s)</span></span>;</span><br><span class="line">    t.<span class="built_in">async_wait</span>(&amp;print); <span class="comment">// 总是不会造成阻塞</span></span><br><span class="line">    io.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th align="left">同步阻塞式</th><th align="left">函数回调式</th><th align="left">co_context（同步式）</th></tr></thead><tbody><tr><td align="left">学习难度</td><td align="left">易</td><td align="left">难</td><td align="left"><strong>易</strong></td></tr><tr><td align="left">编程难度</td><td align="left">易</td><td align="left">难</td><td align="left"><strong>易</strong></td></tr><tr><td align="left">阅读难度</td><td align="left">易</td><td align="left">非常难</td><td align="left"><strong>易</strong></td></tr><tr><td align="left">调度者</td><td align="left">OS（线程调度）</td><td align="left">用户（显式）</td><td align="left"><strong>用户（隐式）</strong></td></tr><tr><td align="left">并发容量参考</td><td align="left">千级</td><td align="left">十万级</td><td align="left"><strong>十万级</strong></td></tr><tr><td align="left">典型场景</td><td align="left">磁盘；客户端</td><td align="left">网络；服务器</td><td align="left"><strong>全场景</strong></td></tr></tbody></table><p>从业务逻辑的角度看，同步式的表达更加流畅，语言噪音更小，<strong>简单易懂</strong>；而函数回调写的业务比较零散，仅因一个计时器就需要将业务分割成两部分（等待 5 秒，打印 Helloworld），当业务越来越复杂，代码分裂割据的现象就越严重。只需看 Boost.Asio 的 echo server 例子就能知道，回调不是一般人能喜欢写的。所以，co_context 选择了同步写法。</p><h2 id="抽象层次：从系统调用出发"><a href="#抽象层次：从系统调用出发" class="headerlink" title="抽象层次：从系统调用出发"></a>抽象层次：从系统调用出发</h2><p>在众多 C++ 异步框架中，抽象层次有高有低。<a href="https://www.boost.org/doc/libs/1_79_0/doc/html/boost_asio/overview.html">Asio</a> 对 Proactor 模式的应用登峰造极，做出 Executor，Strand，Buffer，Stream 等偏向编程的抽象；最近比较活跃的搜狗 <a href="https://github.com/sogou/workflow">Workflow</a> 面向任务流抽象，直接内置了通用网络协议，用户将基础任务和协议串联或并联成自己的应用；中文互联网教科书级别的 <a href="https://github.com/chenshuo/muduo">Muduo</a> 针对网络层和传输层抽象，对熟练计算机网络的同学比较友好；还有 libevent、libev、libuv 等等……任何一种抽象都在学习成本和开发效率上有所优劣。而 co_context 的做法是，直接对<strong>同步阻塞系统调用</strong>抽象（走操作系统的路，让操作系统无路可走）。偏底层的开发者基于 co_context 完成高级业务库后，偏上层的开发者同样是以同步编程的风格来描述业务逻辑。</p><h3 id="用系统调用构建你的库"><a href="#用系统调用构建你的库" class="headerlink" title="用系统调用构建你的库"></a>用系统调用构建你的库</h3><p>在 Linux 中，同步阻塞 API 直截了当地表达了程序员的意图，而 co_context 提供的 API 极力地继承了这种特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux 系统调用</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(fd, buf, count);</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">writev</span>(fd, iov, iovcnt);</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">accept4</span>(sockfd, addr, addrlen, flags); <span class="comment">// man7.org/linux/man-pages/man2/accept.2.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// co_context</span></span><br><span class="line"><span class="type">int</span> n = <span class="keyword">co_await</span> <span class="built_in">read</span>(fd, buf, count);</span><br><span class="line"><span class="type">int</span> n = <span class="keyword">co_await</span> <span class="built_in">writev</span>(fd, iov, iovcnt);</span><br><span class="line"><span class="type">int</span> fd = <span class="keyword">co_await</span> <span class="built_in">accept</span>(sockfd, addr, addrlen, flags);</span><br></pre></td></tr></table></figure><p>从实现的角度上说，因为底层的 io_uring 也是面向系统调用的，所以提供这些接口的实现并不困难。从用户的角度看，用这些系统调用来实现基本的功能实在是太简单了（相比用函数回调）。例如，实现一个 netcat 基础功能，将 TCP 连接上接收到的任何信息打印到 stdout：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task&lt;<span class="type">int</span>&gt; <span class="title">hear</span><span class="params">(co_context::socket peer)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">int</span> nr = <span class="keyword">co_await</span> peer.<span class="built_in">recv</span>(buf);</span><br><span class="line">    <span class="keyword">while</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">lazy::write</span><span class="params">(STDOUT_FILENO, &#123;buf, nr&#125;, <span class="comment">/*offset*/</span><span class="number">0</span>)</span></span>;</span><br><span class="line">        nr = <span class="keyword">co_await</span> peer.<span class="built_in">recv</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle_error(-nr); // 当场处理错误码</span></span><br><span class="line">    <span class="comment">// throw std::system_error&#123;-nr, std::system_category(), &quot;hear&quot;&#125;; // 或者，抛出异常</span></span><br><span class="line">    <span class="keyword">co_return</span> -nr; <span class="comment">// 或者，返回错误码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，上层可以同步地调用<code>hear</code>协程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task&lt;<span class="type">void</span>&gt; <span class="title">run</span><span class="params">(<span class="type">int</span> some_para)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> err = <span class="keyword">co_await</span> <span class="built_in">hear</span>(sockfd);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) <span class="built_in">handle_error</span>(err);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>task&lt;void&gt;</code>（或者缩写<code>task&lt;&gt;</code>）是一种特殊的协程类型，可以独立地被生成并运行，例如，开启 10000 个 <code>run()</code> 协程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i)</span><br><span class="line">    <span class="built_in">co_spawn</span>(<span class="built_in">run</span>(i));</span><br><span class="line"><span class="comment">// 是不是很像 std::thread&#123;run, i&#125;.detach() ？</span></span><br></pre></td></tr></table></figure><h3 id="库-调度器-x3D-应用"><a href="#库-调度器-x3D-应用" class="headerlink" title="库+调度器&#x3D;应用"></a>库+调度器&#x3D;应用</h3><p>上面的例子演示了如何用协程式 API 实现自己的业务库，但是，光有库是不能做成应用的，我们需要一个调度器来运行这些库函数。调度器负责管理所有的协程，在协程因等待 I&#x2F;O 而暂停时，调度器寻找下一个就绪的协程，并恢复其执行，如此往复。调度器可以掌控一个或多个线程。</p><p>co_context 的调度器名叫<code>io_context</code>，这是从 Boost.Asio 借鉴而来的。 与 Asio 需要经常指定 <code>io_context</code> 不同，co_context 是隐式指定的，默认沿用当前的调度器，所以<strong>调度器的存在感非常低</strong>。通常，只有为了更好的负载均衡，将任务分配到特定的线程组上，才需要显式指定调度器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">a</span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">b</span>() &#123;</span><br><span class="line">    <span class="built_in">co_spawn</span>(<span class="built_in">a</span>()); <span class="comment">// 不显式指定，则使用当前的调度器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">c</span>(io_context&amp; io) &#123;</span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">a</span>()); <span class="comment">// 显式指定调度器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io&#123;<span class="number">32768</span>&#125;;</span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">b</span>()); <span class="comment">// 根源的co_spawn必须指定调度器</span></span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">c</span>(io));</span><br><span class="line">    io.<span class="built_in">run</span>(); <span class="comment">// 调度器开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶-API"><a href="#高阶-API" class="headerlink" title="高阶 API"></a>高阶 API</h2><p>很多人，包括我的毕设答辩考官，可能会忽视协程式 API 的威力。“你是不是仅仅对系统调用做了一个迁移（简单包装）？”当然不是，co_context 提供的惰性求值 API 具有可组合的能力，在<strong>易用性</strong>和<strong>性能</strong>上都是大杀器。</p><p><img src="/2022/06/25/co-context-1/HO-api.png" alt="高阶API"></p><p>如上图所示，用户可以将两个原始的一阶 API 组合，形成二阶 API。只要有意义，用户要写成三四五六七八阶都不是问题。如下图所示，在运行时，co_context 将整个高<br>阶 API 转化为链表，整个链表只进入一次调度器，只进入一次 io_uring，显然可以节省调度开销。</p><p><img src="/2022/06/25/co-context-1/HO-api-principle.png" alt="高阶API原理"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>「面向系统调用」和「高阶 API 」是一套组合拳，从底层开始为用户提供了易用性（和性能）。因为使用了同步的代码风格，我们不难将已有的同步库改写成 co_context 的形式，从而获得强大的并发性能；如果原有库是基于系统调用，那么……可能加一次班就能完成迁移了。</p><p>co_context 在易用性上还有其他设计，例如：C++协程帮你托管了堆内存，你不再需要用<code>shared_ptr</code>了；当你忘记用<code>co_await</code>时， 编译器会向你道歉；等等，只不过这些内容有点喧宾夺主，我就不多写了。在未来的文章中，我可能会介绍这些易用性是怎样实现的。下一章，打算先介绍 co_context 的性能设计，看看它用了哪些 trick 来骗取性能。</p><hr><p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Codesire-Deng/co_context&quot;&gt;co_context&lt;/a&gt; 是最近开发的 C++ 异步协程框架，基于 Linux io_uring。&lt;strong&gt;「易用性」&lt;/strong&gt;和「性能」是我们最重视的属性，这篇文章，我们介绍在 co_context 中有关易用性的设计。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="C++协程" scheme="https://codesire-deng.github.io/tags/C-%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="co_context" scheme="https://codesire-deng.github.io/tags/co-context/"/>
    
  </entry>
  
  <entry>
    <title>co_context[0]: C++高性能协程框架</title>
    <link href="https://codesire-deng.github.io/2022/05/26/co-context-0/"/>
    <id>https://codesire-deng.github.io/2022/05/26/co-context-0/</id>
    <published>2022-05-26T12:45:57.000Z</published>
    <updated>2022-06-25T15:25:17.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Codesire-Deng/co_context">co_context</a> 是最近开发的 C++ 异步协程框架，以<strong>易用性</strong>为最高目标，尽量兼顾<strong>性能</strong>。希望从此 C++ 的异步能比 Node.js 更简单，更优雅。</p><p>co_context 是基于 Linux io_uring，I&#x2F;O 走内核态协议栈，这是 co_context 努力逼近的性能上限。</p><span id="more"></span><p>做了几个小测试，性能还是比较猛的。如果别的网络框架，但凡沾上 <code>shared_ptr</code>，<code>mutex</code>，<code>memory_order_seq_cst</code> 等等重型工具，多半要比 co_context 慢一些。</p><hr><p>2022&#x2F;5&#x2F;26 更新：</p><ul><li>新增 「I&#x2F;O 取消」和「超时 I&#x2F;O 取消」，API 更好用了；</li><li>更新调度策略，redis-PING QPS 突破 50 万了；</li><li>重做 redis-benchmark 的实验：<ul><li>发现后台运行 Chrome 会显著影响 CPU 调度，进而影响性能表现——关闭 Chrome；</li><li>发现网络代理会降低 localhost 通信的性能——关闭网络代理；</li></ul></li><li>链式 I&#x2F;O 中operator+ 的求值顺序是由编译器定义的，因此弃用，改用operator&amp;&amp; ；</li><li>毕设 co_context 通过审核了 ，过几天儿童节答辩 ~</li></ul><hr><h2 id="用例速览"><a href="#用例速览" class="headerlink" title="用例速览"></a>用例速览</h2><h3 id="redis-PING-INLINE"><a href="#redis-PING-INLINE" class="headerlink" title="redis-PING_INLINE"></a>redis-PING_INLINE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/io_context.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/lazy_io.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/net/acceptor.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint16_t</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">reply</span>(co_context::socket sock) &#123;</span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">co_await</span> sock.<span class="built_in">recv</span>(recv_buf);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">co_await</span> (sock.<span class="built_in">send</span>(&#123;<span class="string">&quot;+OK\r\n&quot;</span>, <span class="number">5</span>&#125;) &amp;&amp; sock.<span class="built_in">recv</span>(recv_buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">server</span>() &#123;</span><br><span class="line">    acceptor ac&#123;inet_address&#123;port&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sockfd; (sockfd = <span class="keyword">co_await</span> ac.<span class="built_in">accept</span>()) &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="built_in">co_spawn</span>(<span class="built_in">reply</span>(co_context::socket&#123;sockfd&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context ctx&#123;<span class="number">32768</span>&#125;;</span><br><span class="line">    ctx.<span class="built_in">co_spawn</span>(<span class="built_in">server</span>());</span><br><span class="line">    ctx.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 redis-server，但无论接收什么命令，都只会返回一个&quot;+OK&quot;。猜猜它的 QPS 是多少？单线程下，面向 1000 个客户端，co_context QPS 是 55 万，而 redis 本尊是 36 万，平均延迟、p99延迟等均碾压。虽然……这样的性能在网络框架里勉强及格 （毕竟隔壁 bRPC 动不动五百万并发。。）。</p><p>测试工具是 redis-benchmark，其线程开1~3个（使QPS最优），测试环境是单机 5800X, 32GB 3200MHZ-ddr4。</p><p><img src="/2022/05/26/co-context-0/redis-single-thread.png" alt="单线程"></p><h3 id="链式-I-x2F-O"><a href="#链式-I-x2F-O" class="headerlink" title="链式 I&#x2F;O"></a>链式 I&#x2F;O</h3><p>链式 I&#x2F;O 能减少再入内核态和调度器的次数，增强性能。只需用<code>&amp;&amp;</code>连接请求即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co_await 优先级太高，须加括号</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">co_await</span> (<span class="built_in">A</span>() &amp;&amp; <span class="built_in">timeout</span>(<span class="built_in">B</span>(), <span class="number">3</span>s) &amp;&amp; <span class="built_in">C</span>());</span><br></pre></td></tr></table></figure><p>先做 A，然后做 B（限时 3 秒），（如果没有超时或错误）最后做 C。有错误则返回错误，否则返回 C 的结果。</p><h3 id="一秒定时器"><a href="#一秒定时器" class="headerlink" title="一秒定时器"></a>一秒定时器</h3><p>接下来只展示核心代码了，因为非核心代码和上面差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">my_clock</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Time = %d\n&quot;</span>, cnt++);</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">timeout</span><span class="params">(<span class="number">1</span>s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔一秒，在屏幕上打印时间。当然，这种写法容易有累计误差，切勿模仿喔~</p><h3 id="网络超时取消"><a href="#网络超时取消" class="headerlink" title="网络超时取消"></a>网络超时取消</h3><p>用<code>timeout(req, time)</code>能够令<code>req</code>请求限制在<code>time</code>时间以内，若超时则返回失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">run</span>(co_context::socket peer) &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">int</span> nr = <span class="keyword">co_await</span> <span class="built_in">timeout</span>(peer.<span class="built_in">recv</span>(buf), <span class="number">3</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">lazy::write</span><span class="params">(STDOUT_FILENO, &#123;buf, (<span class="type">size_t</span>)nr&#125;, <span class="number">0</span>)</span></span>;</span><br><span class="line">        nr = <span class="keyword">co_await</span> <span class="built_in">timeout</span>(peer.<span class="built_in">recv</span>(buf), <span class="number">3</span>s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log_error</span>(-nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log_error</span><span class="params">(<span class="type">int</span> err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">case</span> ECANCELED: <span class="comment">// 超时取消</span></span><br><span class="line">            log::<span class="built_in">e</span>(<span class="string">&quot;timeout!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 其他错误</span></span><br><span class="line">            log::<span class="built_in">e</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(err)); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每次TCP<code>recv</code>调用限时3秒钟。</p><h3 id="I-x2F-O-取消"><a href="#I-x2F-O-取消" class="headerlink" title="I&#x2F;O 取消"></a>I&#x2F;O 取消</h3><p>I&#x2F;O 可以无理由取消订单，前提是货还没到你的手上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">cancel_fd</span><span class="params">(fd)</span></span>;</span><br></pre></td></tr></table></figure><p>取消与指定 fd 有关的 I&#x2F;O 操作。</p><p>PS: 内部还可以做更细致的取消操作，只是作者还没想好怎么设计 API 比较优雅~</p><h3 id="并发量限制"><a href="#并发量限制" class="headerlink" title="并发量限制"></a>并发量限制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counting_semaphore sem&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">co_await</span> sem.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="built_in">co_spawn</span>([]() -&gt; task&lt;&gt; &#123;</span><br><span class="line">            socket sock&#123;..&#125;;</span><br><span class="line">            <span class="keyword">co_await</span> sock.<span class="built_in">connect</span>(..) &amp;&amp; sock.<span class="built_in">send</span>(..) &amp;&amp; sock.<span class="built_in">recv</span>(..)</span><br><span class="line">                     &amp;&amp; sock.<span class="built_in">close</span>();</span><br><span class="line">            sem.<span class="built_in">release</span>();</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码将业务并发量限制在 100 以内。注意<code>counting_semaphore</code>是针对 co_context 特制的，wait-free，性能比较好。</p><h3 id="其他协程间同步工具"><a href="#其他协程间同步工具" class="headerlink" title="其他协程间同步工具"></a>其他协程间同步工具</h3><p>类似的同步工具还有<code>mutex</code>，<code>condition_variable</code>。所有的同步工具的使用体验和 C++ 标准定义的类似，不会有额外学习成本哦~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line">co_context::mutex mtx;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">add</span>() &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = <span class="keyword">co_await</span> mtx.<span class="built_in">lock_guard</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) ++cnt;</span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context ctx&#123;<span class="number">2048</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) ctx.<span class="built_in">co_spawn</span>(<span class="built_in">add</span>());</span><br><span class="line">    ctx.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将<code>cnt</code>安全地递增至 1e9。</p><h2 id="co-context-的主要内容"><a href="#co-context-的主要内容" class="headerlink" title="co_context 的主要内容"></a>co_context 的主要内容</h2><p>co_context 在 4 个方面有贡献：</p><ul><li>liburingcxx: io_uring 的高性能 C++ binding。</li><li>io_context: 针对 L1 cache 的高性能调度器。</li><li>coro: 面向用户的协程库，提供简洁、好用、符合直觉的 API，还提供了同步 syscall 的协程 API（基于同步syscall 的上层库可以快速地移植到 co_context）。</li><li>net: 基于 coro 提供一些便捷的网络抽象（非必需）。</li></ul><p>限于篇幅，co_context 的原理将写到其他文章中（也许就是将毕业设计报告的内容抄过来……逃）。</p><p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Codesire-Deng/co_context&quot;&gt;co_context&lt;/a&gt; 是最近开发的 C++ 异步协程框架，以&lt;strong&gt;易用性&lt;/strong&gt;为最高目标，尽量兼顾&lt;strong&gt;性能&lt;/strong&gt;。希望从此 C++ 的异步能比 Node.js 更简单，更优雅。&lt;/p&gt;
&lt;p&gt;co_context 是基于 Linux io_uring，I&amp;#x2F;O 走内核态协议栈，这是 co_context 努力逼近的性能上限。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="C++协程" scheme="https://codesire-deng.github.io/tags/C-%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="co_context" scheme="https://codesire-deng.github.io/tags/co-context/"/>
    
  </entry>
  
  <entry>
    <title>Intellisense and Copy elision</title>
    <link href="https://codesire-deng.github.io/2022/04/04/Intellisense-and-Copy-elision/"/>
    <id>https://codesire-deng.github.io/2022/04/04/Intellisense-and-Copy-elision/</id>
    <published>2022-04-04T11:35:59.000Z</published>
    <updated>2022-04-07T08:15:41.481Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发 <code>co_context</code>，遇到了很多 C++ 周边的坑。其中一个坑是 intellisense 翻脸不认 C++17 标准的强制拷贝消除（Mandatory elision of copy&#x2F;move operations）。</p><p>这个 intellisense 来自 Vscode Extention: C&#x2F;C++ (Microsoft)。</p><h2 id="Brief-Solution"><a href="#Brief-Solution" class="headerlink" title="Brief Solution"></a>Brief Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __INTELLISENSE__</span></span><br><span class="line"><span class="comment">// The fake code to cheat intellisense...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// The real code for compiler...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p><code>co_context</code> 要开发一个 <code>lock_guard</code>，但用户必须要写 <code>co_await</code>，导致只能写成以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lk = <span class="keyword">co_await</span> mtx.<span class="built_in">lock_guard</span>();</span><br></pre></td></tr></table></figure><p><code>lk</code> 在析构的时候会自动调用 <code>mtx.unlock()</code>。这看起来很美好，但这里发生了 Copy elision，根据 C++17 标准，这是强制编译器执行的优化，无论拷贝&#x2F;移动构造函数有没有副作用。为了防止用户误用，我干脆删除了拷贝&#x2F;移动构造函数，注意这也是符合标准的做法。</p><p>但问题是，intellisense 不知道 Copy elision！因为我删除了那些构造函数，导致 intellisense 会报错：「无法引用 xx 构造函数，它已经被删除」。</p><p>最糟糕的是，库的用户在正确使用 <code>lock_guard</code> 时，都可能收到这一条错误的报错（哪怕编译通过），这很有迷惑性，显然会大大降低用户体验。</p><h2 id="One-way-compromise"><a href="#One-way-compromise" class="headerlink" title="One way: compromise"></a>One way: compromise</h2><p>最初我选择向 intellisense 妥协：你想让我写移动构造，我写就是了。为了语义正确性，我不得不将 <code>lock_guard</code> 类内部的 <code>mutex&amp;</code> 改成 <code>mutex*</code>，以支持「移动」。</p><p>最后在 <code>~lock_guard()</code> 内，我不得不判断 <code>if (mtx != nullptr) mtx-&gt;unlock()</code>，这很丑，也影响了性能。我不能忍受。</p><h2 id="The-second-way-cheat"><a href="#The-second-way-cheat" class="headerlink" title="The second way: cheat"></a>The second way: cheat</h2><p>错误的根源是 intellisense 不知道 Copy elision。错误的代价不应由我来承担。</p><p>我为 <code>lock_guard</code> 增加了移动构造函数，但标注了 <code>[[deprecated]]</code>，而且内部是 <code>assert(false)</code>，这是为了防止用户误用。这成功地骗过了 intellisense。</p><p>因为保证不会拷贝&#x2F;移动，所以可以删除 <code>if (mtx != nullptr)</code> 这样的愚蠢代码啦！</p><h2 id="The-final-solution-ifdef"><a href="#The-final-solution-ifdef" class="headerlink" title="The final solution: #ifdef"></a>The final solution: #ifdef</h2><p>经过高人指点，欺骗 intellisense 有专门的宏来完成。所以最后的解决办法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __INTELLISENSE__</span></span><br><span class="line">    [[<span class="built_in">deprecated</span>(</span><br><span class="line">        <span class="string">&quot;This function is for cheating intellisense, &quot;</span></span><br><span class="line">        <span class="string">&quot;who doesn&#x27;t sense RVO. &quot;</span></span><br><span class="line">        <span class="string">&quot;You should NEVER use this explicitly or implicitly.&quot;</span>)]]</span><br><span class="line">    <span class="built_in">lock_guard</span>(lock_guard &amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">mtx</span>(other.mtx) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;Mandatory copy elision failed!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">lock_guard</span>(lock_guard &amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>[[deprecated]]</code> 和 <code>assert</code> 可以删去，因为编译器永远不会处理它们。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发 &lt;code&gt;co_context&lt;/code&gt;，遇到了很多 C++ 周边的坑。其中一个坑是 intellisense 翻脸不认 C++17 标准的强制拷贝消除（Mandatory elision of copy&amp;#x2F;move operations）。&lt;/p&gt;
&lt;p&gt;这个 intellisense 来自 Vscode Extention: C&amp;#x2F;C++ (Microsoft)。&lt;/p&gt;
&lt;h2 id=&quot;Brief-Solution&quot;&gt;&lt;a href=&quot;#Brief-Solution&quot; class=&quot;headerlink&quot; title=&quot;Brief Solution&quot;&gt;&lt;/a&gt;Brief Solution&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifdef&lt;/span&gt; __INTELLISENSE__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The fake code to cheat intellisense...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The real code for compiler...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Coroutine Tutorial: Generators</title>
    <link href="https://codesire-deng.github.io/2022/02/22/Generators-with-Coroutine/"/>
    <id>https://codesire-deng.github.io/2022/02/22/Generators-with-Coroutine/</id>
    <published>2022-02-22T08:28:51.000Z</published>
    <updated>2022-10-09T02:23:25.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>要掌握 C++20 协程，仅仅看完文档是远远不够的。C++ 和其他语言的协程的最大不同点在于，C++ 提供了最少量的编译器实现和极大量的「可定制点」，而其他语言可能连「调度器」都给用户准备好了。</p><p>在茫茫多的可定制点面前，如果你能一眼看出「为什么 C++ 要这样设计」，那么我愿称你为天才。否则，还是从常见的范式下手，逐渐体会设计者的思想吧。</p><p>我们将从最简单的范式——Generator 下手。</p><span id="more"></span><p><small>本文力求概念定义的权威性，但无法做任何保证。</small></p><h1 id="What-is-Generator"><a href="#What-is-Generator" class="headerlink" title="What is Generator"></a>What is Generator</h1><p>Generator 泛指一段序列（有限或无限长）的生成器。在协程的语境下，Generator 特指一个<strong>懒惰</strong>的协程，它每次运行时会在调用者线程<strong>同步</strong>地计算一个值，然后暂停自己，同时把值返回给调用者。</p><div class="note info"><p>因为 Generator 在是在调用者线程下立即同步执行的，所以它不需要任何调度器。</p></div><p>Fibonacci 数列就是 Generator 的 hello-world。我们来看一看效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a0;</span><br><span class="line">    <span class="keyword">co_yield</span> a1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a2; <span class="literal">true</span>;) &#123;</span><br><span class="line">        a2 = a0 + a1;</span><br><span class="line">        a0 = a1;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        <span class="keyword">co_yield</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len=<span class="number">10</span>; <span class="type">int</span> i : <span class="built_in">fibonacci</span>(<span class="number">1</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (--len == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现这个效果，只要实现 <code>Generator&lt;T&gt;</code><del>，虽然很麻烦</del>。</p><h1 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator"></a>Why Generator</h1><p>上一段例子很愚蠢，我随手写一个 <code>struct Fibo</code> 重载 <code>operator()</code>，内置一个迭代器不香？为什么要大费周章实现 Generator，还要付出协程的运行时代价？</p><p><del>我也不知道为什么，纯纯为了学而学</del> Generator 可以免去你每次重新设计结构体的麻烦，无需你重写各种迭代器，可以看作一个又香又臭的语法糖。更进一步，Generator 可以很方便地相互嵌套，相比其他做法大大降低了编程复杂度。</p><h1 id="Analyze-How-to"><a href="#Analyze-How-to" class="headerlink" title="Analyze How-to"></a>Analyze How-to</h1><p>希望你已经大致了解 C++ Coroutine 的运作方式，至少了解 <code>co_await</code> 关键字的作用。顺便推销一下我的另一篇文章 <a href="/2021/11/18/C-20-Coroutine/">C++20 Coroutine</a>，它可以帮助你记住 <code>co_await</code>。</p><p>现在按照协程的生命周期来分析 <code>Generator&lt;T&gt;</code>，看看它应该具有哪些接口和行为。</p><h2 id="get-return-object"><a href="#get-return-object" class="headerlink" title="get_return_object"></a>get_return_object</h2><p>协程在初次进入的时候会调用 <code>promise.get_return_object()</code>，其返回值会在第一次暂停的时候返回给 caller。caller 要向协程索取返回值，通常只能通过这个<code>return_object</code> 去要，所以它相当于一个 handler。</p><p>按照 C++ 标准规定 <code>promise.get_return_object()</code> 的返回值必须是协程类型，也就是 <code>Generator&lt;T&gt;</code>，也好，省得我们思考了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;&lt;unspecified&gt;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="inital-suspend"><a href="#inital-suspend" class="headerlink" title="inital_suspend"></a>inital_suspend</h2><p>协程在初次进入的时候（且在上一步之后）会调用 <code>co_await promise.inital_suspend()</code>。我们希望的是协程不要做任何计算（懒惰），并且直接让出执行权给 caller。所以有如下设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;&lt;unspecified&gt;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>别去找 <code>std::suspend_always</code> 的实现了，我已经给你准备好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_always</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_never</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，<code>std::suspend_always</code> 在被 <code>co_await</code> 的时候总是会让出执行权给 caller&#x2F;resumer，而且<strong>不做任何调度</strong>。如果 caller&#x2F;resumer 未来不将这个协程加入调度，那它就<strong>被永远遗忘</strong>在堆内存中了。</p><p>另一方面，可以发现 <code>co_await std::suspend_always&#123;&#125;</code> 的返回值总是 <code>void</code>。</p><h2 id="caller-resume"><a href="#caller-resume" class="headerlink" title="caller resume"></a>caller resume</h2><p>目前为止，一个协程已经构造好了，而且已经暂停了。用户程序大概长这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Generator&lt;<span class="type">int</span>&gt; fibo = <span class="built_in">fibonacci</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 运行时，因为 co_await initial_suspend() 而跳出协程，执行到这里</span></span><br><span class="line">    <span class="comment">// fibo 就是我们要用的 handler</span></span><br><span class="line">    <span class="comment">// 要再入协程、获取返回值、销毁协程等等都要靠 fibo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们想做两件事：</p><ol><li>resume 一下 <code>fibo</code>，从而计算出第一个值</li><li>通过 <code>fibo</code> 拿到第一个值</li></ol><p>根据 C++ 标准，要恢复一个协程，必须持有对应的 <code>std::coroutine_handle</code>，换句话说 <code>fibo</code> 必须持有 <code>std::coroutine_handle</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那 Generator 是由谁初始化的呢？别忘了，初始化的事是由 <code>promise.get_return_object()</code> 干的。</p><p>问题又来了，如何在 <code>promise.get_return_object()</code> 初始化 <code>std::coroutine_handle</code>？</p><p>我们要认识到以下事实：</p><div class="note info"><p>&amp;promise 和 coroutine_handle 一一对应，它们的偏移量是编译期已知的，可以互相换算。</p></div><p>也就是说，可以根据 <code>promise</code> 的地址算出协程的 <code>std::coroutine_handle</code>，也可以反过来用 <code>std::coroutine_handle</code> 换算出 <code>promise</code> 的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p><code>std::coroutine_handle</code> 的本质是指向协程帧的指针，通常按值传递。</p></div><p>现在，我们可以任意给 Generator 加成员方法，让它利用 <code>m_handle</code> 做任何事情，比如利用 <code>fibo.m_handle.resume()</code> 恢复协程，进行一次计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125; <span class="comment">// 计算下一个值</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="co-yield"><a href="#co-yield" class="headerlink" title="co_yield"></a>co_yield</h2><p>现在，用户调用了 <code>fibo.next()</code>，协程被恢复执行。现在我们想返回第一个值给用户，意味着必须暂停协程，归还执行权。C++ 给我们提供了关键字 <code>co_yield</code>，它是一个语法糖，<code>co_yield expr</code> 等价于 <code>co_await promise.yield_value(expr)</code>。</p><p>所以在 <code>promise.yield_value(expr)</code> 里面，我们要做两件事：</p><ol><li>将 <code>expr</code> 保存在 <code>promise</code> 里面，便于外部访问。</li><li>返回一个 <code>std::suspend_always&#123;&#125;</code>，令 caller 重获执行权。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p><code>std::coroutine_handle&lt;Promise&gt;::promise()</code> 可以拿到对应的 promise 对象，从而拿到计算结果。但请特别小心协程可能已经被销毁！</p></div><div class="note warning"><p>从容器的角度看，<code>T m_value</code> 是一个很烂的设计，仅供示意，请勿模仿！</p></div><h2 id="Finish-the-leftover"><a href="#Finish-the-leftover" class="headerlink" title="Finish the leftover"></a>Finish the leftover</h2><p>现在，Generator 已经具备我们所需的全部功能，但还有一些手续要办：</p><ol><li>异常处理</li><li>定义 <code>co_return</code> 的行为</li></ol><h3 id="uncaught-exception-handler"><a href="#uncaught-exception-handler" class="headerlink" title="uncaught exception handler"></a>uncaught exception handler</h3><p>协程运行时没有被显式 catch 的异常会导致立即调用 <code>promise.unhandled_exception()</code>，紧接着调用 <code>co_await promise.final_suspend()</code>。</p><p>简单起见，我们先不处理异常，留下一个空函数就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="define-co-return"><a href="#define-co-return" class="headerlink" title="define co_return"></a>define <code>co_return</code></h3><p>协程可以显式 <code>co_return [expr]</code>，或者因为执行完函数体而隐式 <code>co_return</code>。</p><p>我们的 fibonacci 不需要 <code>co_return</code> 任何东西，但是作为一篇负责任的教程，我还是会告诉你：</p><div class="note info"><p><code>co_return expr;</code> 会调用 <code>promise.return_value(expr)</code>，随后析构协程内的自动变量，但 promise 和协程参数仍然存活。</p><p>类似地 <code>co_return;</code> 或者 <code>co_return (void)expr;</code> 会调用 <code>promise.return_void()</code>。</p></div><div class="note warning"><p><code>return_value(expr)</code> 和 <code>return_void()</code> 是我们访问协程内自动变量的最后机会。但是 promise 和协程参数仍会存活。</p></div><p><code>return_xxx()</code> 和 自动变量析构后，协程执行 <code>co_await promise.final_suspend()</code>，若协程<strong>不暂停</strong>，则协程帧析构：</p><ol><li>析构 <code>promise</code></li><li>析构协程参数</li><li>释放堆空间</li><li>转移执行权</li></ol><p>若协程暂停，就<strong>只能</strong>通过 <code>std::coroutine_handle::destroy()</code> 来显式析构，无论是否已经析构都<strong>不能再 resume</strong>。</p><p>关于协程的各类元素的生命周期，是一大坑点，未来我会撰写一篇文章来表述。</p><p>言归正传，我们只要随便写一个 final_suspend() 就好，反正这个 Generator 永远不会 <code>co_return</code>。</p><h2 id="Demo-fibonacci"><a href="#Demo-fibonacci" class="headerlink" title="Demo: fibonacci"></a>Demo: fibonacci</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">promise_type</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~promise_type\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>() <span class="keyword">noexcept</span> : <span class="built_in">m_handle</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Generator\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_handle) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;m_handle.destroy()\n&quot;</span>;</span><br><span class="line">            m_handle.<span class="built_in">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO begin() end() operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibo</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a0;</span><br><span class="line">    <span class="keyword">co_yield</span> a1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a2; <span class="literal">true</span>;) &#123;</span><br><span class="line">        a2 = a0 + a1;</span><br><span class="line">        a0 = a1;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        <span class="keyword">co_yield</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">auto</span> fi = <span class="built_in">fibo</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        fi.<span class="built_in">next</span>();</span><br><span class="line">        cout &lt;&lt; fi.<span class="built_in">result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">~Generator</span><br><span class="line">m_handle.destroy()</span><br><span class="line">~promise_type</span><br></pre></td></tr></table></figure><h1 id="Conclusion-and-Prospect"><a href="#Conclusion-and-Prospect" class="headerlink" title="Conclusion and Prospect"></a>Conclusion and Prospect</h1><p>我们实现了一个基本能用的 Generator，因为是入门教程，代码故意写得很糙，聪明的你一定知道如何改进。</p><p>如果你想自己造一个 Generator，那么还需要改进的地方至少有：</p><ol><li><code>promise_type</code> 内置一个更高效、安全的容器</li><li><code>Generator&lt;T&gt;</code> 内置一个迭代器类，以支持 range for 循环。</li><li>如果你很熟悉生命周期的坑点，<code>promise_type</code> 内置的容器可以仅存放指向协程自动变量的指针，进一步压缩空间，提升 <code>yield</code> 效率。</li><li>利用 execution 来实现异步版本的 Generator。</li><li>思考递归 <code>yield</code> 的效率问题，以及如何改进（难但秀）。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="/2021/11/18/C-20-Coroutine/">C++20 Coroutine - 等疾风</a></li><li><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine (C++20) - cppreference</a></li><li><a href="https://github.com/lewissbaker/cppcoro">cppcoro - lewissbaker</a></li><li><a href="https://www.bilibili.com/video/BV1z5411Z7K5">协程上手经典案例：实现一个序列生成器 - Benny Huo</a></li></ul><h1 id="Some-Slight-Improvements"><a href="#Some-Slight-Improvements" class="headerlink" title="Some Slight Improvements"></a>Some Slight Improvements</h1><ol><li>使用 <code>std::optional</code> 来做容器，自动调用正确的构造&#x2F;析构函数，支持移动语义。(可以进一步改用 <code>std::variant</code>)。</li><li>定义了 Generator 的几个构造和赋值函数，增强了安全性(safety)。</li><li>在 <code>unhandled_exception()</code> 内存放了 <code>std::exception_ptr</code>。</li><li>用例改为稍微复杂一些的字符串生成，里面有一些性能问题，读者有兴趣的可以找找茬。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 Generator::promise_type  成为一个更安全高效的单元素容器</span></span><br><span class="line"><span class="comment">// 限制了 Generator 的所有权，删除了默认构造，拷贝构造和拷贝赋值</span></span><br><span class="line"><span class="comment">// Generator 保证在构造后持有</span></span><br><span class="line"><span class="comment">// coroutine_handle，但可能被移动走，所以析构时要检查非空</span></span><br><span class="line"><span class="comment">// TODO 迭代器，异常传播</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">promise_type</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *m_value; &#125;</span><br><span class="line">        <span class="function">T &amp;<span class="title">result</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T &amp;&amp;value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; m_exception = std::<span class="built_in">current_exception</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        std::optional&lt;T&gt; m_value;</span><br><span class="line">        std::exception_ptr m_exception;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line">    <span class="function">T &amp;<span class="title">result</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(<span class="type">const</span> Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    Generator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    Generator &amp;<span class="keyword">operator</span>=(Generator &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != other) &#123;</span><br><span class="line">            m_handle = other.m_handle;</span><br><span class="line">            other.m_handle = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_handle) m_handle.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO begin() end() operator* operator-&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator&lt;std::string&gt; <span class="title">lottery</span><span class="params">(<span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    std::string winningNumbers;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> numLen = std::<span class="built_in">to_string</span>(mod - <span class="number">1</span>).<span class="built_in">size</span>();</span><br><span class="line">        winningNumbers.<span class="built_in">reserve</span>(size * (numLen + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_yield</span> winningNumbers += std::<span class="built_in">to_string</span>(<span class="built_in">rng</span>() % mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        winningNumbers += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">co_yield</span> winningNumbers += std::<span class="built_in">to_string</span>(<span class="built_in">rng</span>() % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">auto</span> fi = <span class="built_in">lottery</span>(<span class="number">10</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        fi.<span class="built_in">next</span>();</span><br><span class="line">        cout &lt;&lt; fi.<span class="built_in">result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">253</span><br><span class="line">253 148</span><br><span class="line">253 148 56</span><br><span class="line">253 148 56 2</span><br><span class="line">253 148 56 2 179</span><br><span class="line">253 148 56 2 179 41</span><br><span class="line">253 148 56 2 179 41 96</span><br><span class="line">253 148 56 2 179 41 96 10</span><br><span class="line">253 148 56 2 179 41 96 10 125</span><br><span class="line">253 148 56 2 179 41 96 10 125 123</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;要掌握 C++20 协程，仅仅看完文档是远远不够的。C++ 和其他语言的协程的最大不同点在于，C++ 提供了最少量的编译器实现和极大量的「可定制点」，而其他语言可能连「调度器」都给用户准备好了。&lt;/p&gt;
&lt;p&gt;在茫茫多的可定制点面前，如果你能一眼看出「为什么 C++ 要这样设计」，那么我愿称你为天才。否则，还是从常见的范式下手，逐渐体会设计者的思想吧。&lt;/p&gt;
&lt;p&gt;我们将从最简单的范式——Generator 下手。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="C++协程" scheme="https://codesire-deng.github.io/tags/C-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>One Minute to C++ &quot;defer&quot;</title>
    <link href="https://codesire-deng.github.io/2022/02/06/One-Minute-to-C-defer/"/>
    <id>https://codesire-deng.github.io/2022/02/06/One-Minute-to-C-defer/</id>
    <published>2022-02-06T08:01:36.000Z</published>
    <updated>2022-02-06T09:13:45.481Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lambda&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Defer</span> : Lambda &#123;</span><br><span class="line">    ~<span class="built_in">Defer</span>() &#123; Lambda::<span class="built_in">operator</span>()(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lambda&gt;</span></span><br><span class="line"><span class="function"><span class="title">Defer</span><span class="params">(Lambda)</span> -&gt; Defer&lt;Lambda&gt;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage</span></span><br><span class="line">Defer guard&#123;[sockfd]&#123;</span><br><span class="line">    <span class="built_in">shutdown</span>(sockfd, SHUT_WR);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>This is a short tutorial on implementing golang-style &quot;defer&quot; in C++.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The favored technique will be:</span><br><span class="line"><span class="addition">+ C++ template and lambda</span></span><br><span class="line"><span class="deletion">- C macro</span></span><br></pre></td></tr></table></figure><h1 id="The-Explaination"><a href="#The-Explaination" class="headerlink" title="The Explaination"></a>The Explaination</h1><ol><li>Inheriting from a lambda type, we define a template class <code>Defer</code> whose dtor calls the <code>Lambda::operator()</code>.</li><li>Explicitly deduce a ctor <code>Defer(Lambda)</code> to the exact type <code>Defer&lt;Lambda&gt;</code>. This step can be omitted in C++20 or later.</li><li>Define a <code>Defer</code> object, initialized with the lambda, at any scope, similar to golang.</li></ol><h1 id="Tips-and-More"><a href="#Tips-and-More" class="headerlink" title="Tips and More"></a>Tips and More</h1><ol><li>You may need to capture some local variables into the lambda.</li><li><code>-O1</code> is recommended for the lambda inlining, which makes this idiom zero-overhead.</li><li>Using C macro, this idiom can be developed more concise. Personally I don&#39;t like C macro, however, because of safety concerns.</li><li>A library: <a href="https://github.com/lizho/FakeGolang/blob/master/include/fake_golang.h">lizho&#x2F;FakeGolang</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; Lambda&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Defer&lt;/span&gt; : Lambda &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~&lt;span class=&quot;built_in&quot;&gt;Defer&lt;/span&gt;() &amp;#123; Lambda::&lt;span class=&quot;built_in&quot;&gt;operator&lt;/span&gt;()(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; Lambda&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Defer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Lambda)&lt;/span&gt; -&amp;gt; Defer&amp;lt;Lambda&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// usage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Defer guard&amp;#123;[sockfd]&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;shutdown&lt;/span&gt;(sockfd, SHUT_WR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Expression Templates</title>
    <link href="https://codesire-deng.github.io/2022/01/31/Expression-Templates/"/>
    <id>https://codesire-deng.github.io/2022/01/31/Expression-Templates/</id>
    <published>2022-01-31T07:58:13.000Z</published>
    <updated>2022-02-02T13:02:40.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>在研究 CRTP 时发现了一种经典应用——表达式模板。今天学一学，顺便水一篇博客。🐶</p><h1 id="Motivation-and-example"><a href="#Motivation-and-example" class="headerlink" title="Motivation and example"></a>Motivation and example</h1><p>表达式模板是一种模板元编程，它在编译期展开向量的一系列复合运算，从而将辅助空间从 $O(n)$ 降到 $O(1)$。相比于朴素算法，表达式模板属于惰性求值，求值时间点是赋值运算。</p><span id="more"></span><p>举个例子，有这样一个 vector 运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tot = (a + b) * c;</span><br></pre></td></tr></table></figure><p>朴素算法的语义是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp0 = a + b; <span class="comment">// allocating O(n) space</span></span><br><span class="line">    <span class="keyword">auto</span> tmp1 = tmp0 * c;</span><br><span class="line">    tot = tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使你知道「引用限定成员函数」，使你可以抹掉 <code>tmp1</code> 的空间分配，但是 <code>tmp0</code> 的辅助空间总是逃不掉。</p><p>能帮助你的只有表达式模板，它可以表达出这样的语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>, n=a.<span class="built_in">size</span>(); i&lt;n; ++i) &#123;</span><br><span class="line">    tot[i] = (a[i] + b[i]) * c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来需要的辅助空间就是寄存器级别的！去掉了函数调用也更方便编译器做进一步的优化。</p><h1 id="My-first-attempt"><a href="#My-first-attempt" class="headerlink" title="My first attempt"></a>My first attempt</h1><details class="note primary"><summary><p>我的首次尝试</p></summary><p>忍住不看教程，我先试着实现出来，看看差距有多大。🤔</p><p>我的想法：</p><ol><li>利用类型系统，将懒惰信息记录在模板参数中</li><li>定义惰性二元运算符，它的操作数可以是 vector 或者惰性二元运算符。</li><li>魔改 <code>vector</code>，在赋值运算符中触发求值；重载加减乘除运算。</li></ol><h2 id="Draft-1"><a href="#Draft-1" class="headerlink" title="Draft 1"></a>Draft 1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeferredOperator</span> &#123;</span><br><span class="line">    <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">    <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">DeferredOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        BinaryOperator, <span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        : lhs(lhs), rhs(rhs) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs[pos], rhs[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lhs.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Op&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(Op &amp;&amp;op) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = op.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = op[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    vec = <span class="built_in">DeferredOperator</span>(</span><br><span class="line">        std::multiplies&lt;<span class="type">int</span>&gt;&#123;&#125;, <span class="built_in">DeferredOperator</span>(std::plus&lt;<span class="type">int</span>&gt;&#123;&#125;, a, b), c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == (<span class="number">1</span> + <span class="number">3</span>) * <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="What-39-s-wrong"><a href="#What-39-s-wrong" class="headerlink" title="What&#39;s wrong"></a>What&#39;s wrong</h2><p>这段程序是正确的！😁但也有一些犯蠢的地方：</p><ol><li>没有重载运算符，用起来太丑；</li><li>显式模板参数太多，比如 <code>int</code> 出现太多次。理想中应该只在 <code>Vec</code> 定义时表明<code>T = int</code>，后面的通通自动推导；</li><li>魔改的 <code>Vec</code> 类没有沿用 <code>std::vector</code> 的非默认构造函数；</li><li>当调用 <code>vec = vec</code> 时会错误地调用惰性求值版本；</li><li>没有显式 CRTP，证明不够熟练；</li><li>在计算前调用 <code>vector::resize()</code> 真的好吗？有点违反零开销抽象的感觉。</li></ol></details><h1 id="The-second-attempt"><a href="#The-second-attempt" class="headerlink" title="The second attempt"></a>The second attempt</h1><details class="note primary"><summary><p>查文档再改进</p></summary><p>针对上一章节列出的缺点，我查阅文档做了一些改进：</p><h2 id="Inheriting-constructors"><a href="#Inheriting-constructors" class="headerlink" title="Inheriting constructors"></a>Inheriting constructors</h2><p><a href="https://en.cppreference.com/w/cpp/language/using_declaration">cppreference</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就能使用 <code>std::vector</code> 的构造接口了，我们的 C++ 真的太好用啦！</p><h2 id="Template-Inner-Class"><a href="#Template-Inner-Class" class="headerlink" title="Template Inner Class"></a>Template Inner Class</h2><p>我们可以将 <code>DeferredOperator</code> 类定义在 <code>Vec</code> 内部，这样就不用到处传递基础数据类型啦！</p><h2 id="Who-needs-operator"><a href="#Who-needs-operator" class="headerlink" title="Who needs operator+()?"></a>Who needs operator+()?</h2><ol><li><code>Vec</code> 类需要实现 <code>operator+()</code>，并由这个函数返回一个 <code>DeferredOperator</code></li><li><code>DeferredOperator</code> 类需要实现 <code>operator+()</code>，这个函数同样返回一个 <code>DeferredOperator</code></li></ol><h2 id="Ambiguity-of-operator-x3D"><a href="#Ambiguity-of-operator-x3D" class="headerlink" title="Ambiguity of operator&#x3D;()"></a>Ambiguity of operator&#x3D;()</h2><p>为了区分 <code>Vec = Vec</code> 和 <code>Vec = DeferredOperator</code>，我们需要更精细地定义参数。</p><h2 id="Draft-2"><a href="#Draft-2" class="headerlink" title="Draft 2"></a>Draft 2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DeferredOperator</span> &#123;</span><br><span class="line">        <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">        <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="title">DeferredOperator</span><span class="params">(<span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : lhs(lhs), rhs(rhs) &#123;</span>&#125;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs[pos], rhs[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterRHS&gt;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> OuterRHS &amp;outerRHS) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DeferredOperator&lt;std::plus&lt;&gt;, DeferredOperator, OuterRHS&gt;(</span><br><span class="line">                *<span class="keyword">this</span>, outerRHS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lhs.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> RHS &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DeferredOperator&lt;std::plus&lt;&gt;, Vec, RHS&gt;(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DeferredOperator&lt;BinaryOperator,LHS,RHS&gt; &amp;op) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tag\n&quot;</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = op.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = op[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; vec, <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">1</span>), <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">3</span>), <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    vec = a; <span class="comment">// check bug</span></span><br><span class="line">    vec = a + b + c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == (<span class="number">1</span> + <span class="number">3</span>) + <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Direction-of-improvement"><a href="#Direction-of-improvement" class="headerlink" title="Direction of improvement"></a>Direction of improvement</h2><p>WoW! 这段代码也是正确的！但还是写得有点臭：</p><ol><li>这里只写了重载加法。如果每种运算符都要写两个成员函数，那也太难看了。</li><li>只对 <code>Vec</code> 类实现了惰性加法。万一再来一个 <code>Matrix</code> 类呢？惰性运算能不能接口化？</li><li>CRTP 在哪？</li></ol></details><h1 id="Peak-of-Evolution"><a href="#Peak-of-Evolution" class="headerlink" title="Peak of Evolution"></a>Peak of Evolution</h1><p>这次依然是原创代码，改进了一些地方：</p><h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>多层次的 CRTP 用起来容易头晕，应该事先设计好类的关系：</p><p><img src="/2022/01/31/Expression-Templates/crtpEt.svg" alt="CRTP relationship"></p><p>橙色和红色的类才是 CRTP 的模板实参。白色的类主要用作接口，类似于抽象类。</p><h2 id="ET-interface"><a href="#ET-interface" class="headerlink" title="ET interface"></a>ET interface</h2><ul><li>用户类只要继承 <code>VectorExpresstion</code> 接口，同时定义合适的 <code>operator[]</code> 和 <code>operator=</code> 即可实现模板表达式。</li><li>用户可以在 <code>operator=</code> 中做性能优化，例如手工循环展开、SIMD 等等，非常灵活。</li><li>用户还可以自定义运算符，但我暂时想不到有什么不啰嗦的实现方法（除了宏）。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// necessary header for Expression Template library</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header for user-define things</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// helper class for CRTP. For more info, please see my previous blog</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Interface</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> Interface&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// my Expression Template library implementation</span></span><br><span class="line"><span class="keyword">namespace</span> ET &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base class for lazy evaluation</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Expression</span> : CRTP&lt;T, Expression&gt; &#123;</span><br><span class="line">    <span class="comment">// use a looong function name to avoid ambiguity</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">evaluate</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">self</span>()[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">selfSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">self</span>().<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class to indicate a single value (instead of an vector)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArithmeticExpression</span> : Expression&lt;ArithmeticExpression&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="built_in">ArithmeticExpression</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;std::<span class="type">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;, <span class="type">bool</span>&gt; = <span class="literal">true</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">ArithmeticExpression</span>(<span class="type">const</span> T value) <span class="keyword">noexcept</span> : <span class="built_in">val</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> T <span class="keyword">operator</span>[](<span class="type">size_t</span>) <span class="type">const</span> &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// return void for easier metaprogramming</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class to indicate an vector (instead of a single arithmetic value)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VectorExpression</span> : Expression&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryExpression</span></span><br><span class="line">    : VectorExpression&lt;BinaryExpression&lt;BinaryOperator, LHS, RHS&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// evaluation happens when operator[] is called</span></span><br><span class="line">        <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs.<span class="built_in">evaluate</span>(i), rhs.<span class="built_in">evaluate</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return the size of an *vector*</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!std::is_same_v&lt;<span class="keyword">decltype</span>(lhs.selfSize()), <span class="type">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> lhs.<span class="title">selfSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rhs.<span class="built_in">selfSize</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BinaryExpression</span>(<span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs) : <span class="built_in">lhs</span>(lhs), <span class="built_in">rhs</span>(rhs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">    <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> AddExpression = BinaryExpression&lt;std::plus&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> SubExpression = BinaryExpression&lt;std::minus&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> MulExpression = BinaryExpression&lt;std::multiplies&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> DivExpression = BinaryExpression&lt;std::divides&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded operator to export:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> ETNum = ET::ArithmeticExpression&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>+(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">// notice Expression&lt;E1&gt; -&gt; E1</span></span><br><span class="line">    <span class="comment">// so &quot;Expression&quot; is removed</span></span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">AddExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>-(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">SubExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>*(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">MulExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>/(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">DivExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-define operator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I find it hard to convert a function into an operator() overloading.</span></span><br><span class="line"><span class="comment">// If you have a good idea, please tell me!</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POW</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp &amp;&amp;<span class="type">__t</span>, _Up &amp;&amp;__u)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(std::forward&lt;_Tp&gt;(<span class="type">__t</span>), std::forward&lt;_Up&gt;(__u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span></span><br><span class="line"><span class="function"><span class="title">Pow</span><span class="params">(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">BinaryExpression</span>&lt;POW, E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-define vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec</span><br><span class="line">    : Container</span><br><span class="line">    , ET::VectorExpression&lt;Vec&lt;T, Container&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Exp&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ET::Expression&lt;Exp&gt; &amp;exp) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = exp.<span class="built_in">selfSize</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = exp.<span class="built_in">evaluate</span>(i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">double</span>&gt; ans, <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">1</span>), <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">2</span>), <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">8</span>), <span class="built_in">d</span>(<span class="number">5</span>, <span class="number">7</span>), <span class="built_in">e</span>(<span class="number">5</span>, <span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">Pow</span>((a + b) * c / d + <span class="built_in">ETNum</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>), e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : ans) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == <span class="built_in">pow</span>(((<span class="number">1</span> + <span class="number">2</span>) * <span class="number">8</span> / <span class="number">7.0</span> + <span class="number">1</span>), <span class="number">0.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Conclusion-and-Prospect"><a href="#Conclusion-and-Prospect" class="headerlink" title="Conclusion and Prospect"></a>Conclusion and Prospect</h1><p>一个基本可用的表达式模板库诞生了。但是要记住：</p><ol><li>表达式模板离开了内联优化就是负优化。经过简单测试，gcc 至少要在 <code>-O1</code> 条件下才有内联成员函数的能力。</li><li>使用表达式模板和其他优化手段并不冲突，可以在自定义 <code>operator=</code> 处做 SIMD，循环展开等等。</li></ol><p>我不得不承认这份代码对比基础库的水准还是差了很多，至少有以下方面可以改进：</p><ul><li>more type trait，描述表达式的可加性、可乘性、可被除和可除性等等。</li><li>进一步简化用户自定义运算符的代码。</li><li>实现一元运算符。</li><li>在矢量和标量的混合运算中抹去显式构造标量。</li></ul><p>但模板元编程暂时不是我的主要学习方向，所以还是再等等吧~</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://en.wikipedia.org/wiki/Expression_templates">Expression templates - Wikipedia</a></li><li><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template">More C++ Idioms&#x2F;Expression-template - Wikibooks</a></li><li><a href="https://en.cppreference.com/w/cpp/language/using_declaration">Using-declaration - cppreference.com</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;在研究 CRTP 时发现了一种经典应用——表达式模板。今天学一学，顺便水一篇博客。🐶&lt;/p&gt;
&lt;h1 id=&quot;Motivation-and-example&quot;&gt;&lt;a href=&quot;#Motivation-and-example&quot; class=&quot;headerlink&quot; title=&quot;Motivation and example&quot;&gt;&lt;/a&gt;Motivation and example&lt;/h1&gt;&lt;p&gt;表达式模板是一种模板元编程，它在编译期展开向量的一系列复合运算，从而将辅助空间从 $O(n)$ 降到 $O(1)$。相比于朴素算法，表达式模板属于惰性求值，求值时间点是赋值运算。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ 多态</title>
    <link href="https://codesire-deng.github.io/2022/01/28/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://codesire-deng.github.io/2022/01/28/C-%E5%A4%9A%E6%80%81/</id>
    <published>2022-01-28T09:42:04.000Z</published>
    <updated>2022-02-01T08:05:38.439Z</updated>
    
    <content type="html"><![CDATA[<small>病重躺家，药不能停。<br/>何以解忧？唯有博客。<br/>数据在校，不在我心。<br/>宿舍断电，学校英明！<br/>回滚旧版，泪眼嘤嘤。<br/>&nbsp;H T M L ，手写还行！</small><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>「多态」是一个很宽泛的理念，对应繁多实现。本文将记录我所看到的多态的各种形态。作者见识短浅，还请读者多多指教。</p><ul><li>本文已计划的内容：<ul><li><input checked="" disabled="" type="checkbox"> 基于 <code>std::visit</code><ul><li><input checked="" disabled="" type="checkbox"> 实现运行时多态的优化</li><li><input checked="" disabled="" type="checkbox"> 实现<em>重载模式</em></li></ul></li><li><input checked="" disabled="" type="checkbox"> CRTP 实现静态多态<ul><li><input checked="" disabled="" type="checkbox"> 静态多态</li><li><input checked="" disabled="" type="checkbox"> 静态接口</li><li><input checked="" disabled="" type="checkbox"> CRTP 的一些分析和 trick</li></ul></li><li><input disabled="" type="checkbox"> C++20 前基于 SFINAE 的模板偏特化</li><li><input disabled="" type="checkbox"> C++20 后基于 <code>concepts</code> 的模板特化</li><li><input disabled="" type="checkbox"> Hack 虚函数表，用于优化<span id="more"></span></li></ul></li><li>本文<strong>不会</strong>出现的内容：<ul><li><code>virtual</code> 虚函数的基础用法</li><li>函数指针模拟虚函数</li><li>运行时反射</li></ul></li></ul><h1 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h1><h2 id="Runtime-Branching"><a href="#Runtime-Branching" class="headerlink" title="Runtime Branching"></a>Runtime Branching</h2><p>假如你要对一个矢量做线性变换 $\vec{x} &#x3D; k \cdot \vec{x} + b$，又想针对 $k&#x3D;1$ 或 $b&#x3D;0$ 的情况做优化，应该怎么办？</p><p>这是最简单却很慢的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">1</span>)</span><br><span class="line">        x[i] *= k;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">        x[i] += b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码满足速度要求，但是太啰嗦：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想两全其美怎么办？可以利用 <code>variant</code> 搭配 <code>visit</code> 使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since C++17</span></span><br><span class="line"><span class="keyword">using</span> bool_variant = std::variant&lt;std::true_type, std::false_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> bool_variant <span class="title">to_variant</span><span class="params">(<span class="type">bool</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">        <span class="keyword">return</span> std::true_type&#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> std::false_type&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linear</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;x, <span class="type">int</span> k, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    bool_variant has_k = <span class="built_in">to_variant</span>(k != <span class="number">1</span>);</span><br><span class="line">    bool_variant has_b = <span class="built_in">to_variant</span>(b != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> transform = [=, &amp;x](<span class="keyword">auto</span> has_k, <span class="keyword">auto</span> has_b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;xi : x) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">constexpr</span> (has_k)</span><br><span class="line">                xi *= k;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_b)</span></span></span><br><span class="line"><span class="function">                xi +</span>= b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(transform, has_k, has_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译器为 <code>transform</code> 生成四个特化版本，正是我们想要的东西。<code>std::visit()</code> 会在运行时判断 <code>variant</code> 内储存的是哪个 type，然后挑选正确的重载分支。</p><p><code>variant</code> + <code>constexpr if</code> 并不是唯一的玩法，我们来看看 <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">cppreference</a> 还有什么花活。</p><h2 id="The-Overload-Pattern"><a href="#The-Overload-Pattern" class="headerlink" title="The Overload Pattern"></a>The <em>Overload Pattern</em></h2><p>假设你要 log 一个 <code>variant&lt;int, float, string&gt;</code>，你刚刚学到了 <code>constexpr if</code>，于是你想到这一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> always_false_v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ifs_variant = std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = [](<span class="type">const</span> <span class="keyword">auto</span> &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">float</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">static_assert</span>(always_false_v&lt;T&gt;, <span class="string">&quot;non-exhaustive visitor!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三秒之后你觉得这段代码太丑，太多的 <code>if constexpr</code> 和 <code>is_same_v</code> 语句影响阅读，你也不想用 <code>always_false_v&lt;T&gt;</code> 这样的孤儿代码。于是你想到了重载 <code>opeartor()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; logger;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会在缺少某个重载时报错（模板巨型报错），长度也合理，你的血压下降了一些，但仍未到安全区，因为 <code>void operator()</code> 的重复依然很丑。你想用模板元编程自动化这些函数重载。你的目标是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="comment">// Import all function whatever the parameter is.</span></span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样当你用 lambda 的类型做模板参数，就能自动导入 lambda 的 <code>opeartor()</code>。问题来了，你怎么传入 lambda 的类型？你根本没有办法用尖括号 <code>&lt;&gt;</code> 来指定 lambda 类型！而自动类型推导至少需要一个函数调用，你想到了构造函数！可以在构造函数中传入 lambda，这样就能推导出 <code>Lambdas</code> 的具体类型！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Overloaded</span>(Lambdas&amp;&amp;...) &#123;&#125; <span class="comment">// Bang!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = Overloaded&#123;</span><br><span class="line">        [](<span class="type">int</span> i) &#123; std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">float</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">const</span> std::string &amp;s) &#123; std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bang! 第五行编译报错，编译器说，你企图使用 Lambda 的默认构造函数，但这个函数是 <code>deleted</code>！</p><p>想了半天，你顿悟过来，Overloaded 的构造函数一定要显式调用 Lambdas 的构造函数才行，于是你写出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Overloaded</span>(Lambdas &amp;&amp;...t) : Lambdas&#123;std::forward&lt;Lambdas&gt;(t)&#125;... &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译终于过了！你还擅长举一反三，联想到 <code>make_tuple()</code> 可以在没有尖括号 <code>&lt;&gt;</code> 的情况下工作，你可以模仿它，于是你写出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line">    <span class="comment">// no more explicit ctor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">make_Overloaded</span><span class="params">(Lambdas &amp;&amp;...t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Overloaded&lt;Lambdas...&gt;&#123;std::forward&lt;Lambdas&gt;(t)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很秀也很正确。可惜好景不长，一个保洁阿姨路过了你，说，小伙子你写的不行，来看我秀一手：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">Overloaded</span><span class="params">(Ts...)</span> -&gt; Overloaded&lt;Ts...&gt;</span>;</span><br></pre></td></tr></table></figure><p>编译通过！阿姨的第二行模板恰好替代了 <code>make_Overloaded</code>，正确推导出所有模板参数！这是 C++17 的新功能 *<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Custom Template Argument Deduction Rules</a>*。这一功能在 C++20 中更加智能，所以你可以删掉那行显式推导规则。</p><p>现在，你进化成了 <code>std::visit</code> 不用 <code>Overloaded&#123;&#125;</code> 就不舒服星人。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span> <span class="comment">// C++17</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ifs_variant = std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">Overloaded</span><span class="params">(Ts...)</span> -&gt; Overloaded&lt;Ts...&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">visit</span>(Overloaded&#123;</span><br><span class="line">        [](<span class="type">int</span> i) &#123; std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">float</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">const</span> std::string &amp;s) &#123; std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">    &#125;, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifs_variant i&#123;<span class="number">10</span>&#125;, <span class="built_in">f</span>(<span class="number">0.7f</span>), s&#123;<span class="string">&quot;string&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">log</span>(i);</span><br><span class="line">    <span class="built_in">log</span>(f);</span><br><span class="line">    <span class="built_in">log</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-CRTP"><a href="#The-CRTP" class="headerlink" title="The CRTP"></a>The <em>CRTP</em></h1><p>Curiously recurring template pattern (CRTP) 是指一个类的父类的模板参数含有自己。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : Counter&lt;Foo&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此一来，父类在编译期就知道自己的派生类型，可以利用这一点做很多事，比如模板化的对象计数器、编译期多态、非退化的链式调用、模板化接口实现等等。网上很多声音说 CRTP 主要是用来消除动态绑定，但我认为 CRTP 主要是用来约束和简化代码的。我们来看看 CRTP 到底有什么用。</p><h2 id="Static-Polymorphism"><a href="#Static-Polymorphism" class="headerlink" title="Static Polymorphism"></a>Static Polymorphism</h2><p>由于父类知道派生类型，我们可以用 <code>static_cast&lt;T*&gt;(this)</code> 一步到位，将自己向下转型。还可以调用 <code>T::static_func</code> 实现静态分发。</p><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">member_func_impl</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_func_impl</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func_impl</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Obj::member_func_impl\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func_impl</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Obj::static_func_impl\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obj a;</span><br><span class="line">    Base&lt;Obj&gt; &amp;ref = a;</span><br><span class="line">    ref.<span class="built_in">member_func</span>();</span><br><span class="line">    Base&lt;Obj&gt;::<span class="built_in">static_func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会不会觉得有点脱裤子放屁？这样写有什么优势？用了 CRTP 之后，就宣告丧失了动态分发的能力，那为什么不干脆把 <code>Base</code> 类删掉呢？</p><p>有人说，<code>Base</code> 类描述了子类应该实现的几个函数，而且没有运行时开销。我认为最好使用 C++20 concept 来实现这种编译期约束。用 CRTP 是可以的，但是请注意标识符命名，我们来看一些 Bugs。</p><h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// Notice the &quot;T::member_func()&quot;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;T::<span class="built_in">member_func</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_func</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="comment">// empty!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译没有任何报错，而程序在运行时会因为无穷递归而陷入栈溢出。所以千万<strong>不要为了美观，让子类重复基类的函数名</strong>。</p><p>我们再看一个人为制造的错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj2&gt; &#123; <span class="comment">// a bug compiles</span></span><br><span class="line">    <span class="comment">// implementation which is unused</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会给你任何提醒，而你，<code>Obj</code>，沦为 <code>Obj2</code> 的替身。所幸的是，这个 bug 是可以修复的！只要将 <code>Base</code> 的构造函数设为私有，再加一个友元即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj2&gt; &#123; <span class="comment">// Instantiating Obj does not compile</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，<code>Obj</code> 无权访问 <code>Base</code> 的构造函数，如果企图构造 <code>Obj</code> 对象，编译器会报错，然而你还是要检查半天才能发现，原来是 CRTP 写错了！更惨的是，如果你只调用静态成员，那么编译通过！天王老子来了都不报错！慢慢找 Bug 吧你就。</p><h2 id="Template-Interface-Implementation"><a href="#Template-Interface-Implementation" class="headerlink" title="Template Interface Implementation"></a>Template Interface Implementation</h2><p>目前为止 CRTP 被我批评得太多了，实际上 CRTP 还是有点用的，它可以模板化接口实现，而这一点在 C++20 concept 中我暂时没发现对应的东西。</p><p>假设你要设计一个 <code>Scaleable</code> 接口，对于每一个具体类，它的逻辑都是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable &#123;</span><br><span class="line">    <span class="comment">// getter, setter ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">double</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">setValue</span>(<span class="built_in">getValue</span>() * k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你立即想到  </p><ol><li>你不需要 <code>Scaleable</code> 的动态绑定  </li><li>每个类都复制粘贴一样的代码十分愚蠢  </li><li>C++20 concept 不能提供默认成员实现（作者以为的。如果可以请告诉我）</li></ol><p>你知道可以用 CRTP！于是你设计出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line">    <span class="function">T &amp;<span class="title">scale</span><span class="params">(K &amp;&amp;multiplicator)</span> </span>&#123;</span><br><span class="line">        T &amp;self = <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        self.<span class="built_in">setValue</span>(self.<span class="built_in">getValue</span>() * multiplicator);</span><br><span class="line">        <span class="keyword">return</span> self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">double</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码很漂亮，还支持非退化的链式调用。最重要的是，它在 <code>Obj</code> 定义时就表明了 Scaleable 的语义。如果使用 C++20 concept 或者其他非成员函数去实现，<code>scale</code> 的实现就可能藏在某个 header 里，你不能一眼看出 <code>Obj</code> 是否 Scaleable，语义的表达就会被割裂。</p><p>聪明的你又想到了接口方法还可以是类外的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T &amp;<span class="title">scale</span><span class="params">(Scaleable&lt;T&gt; &amp;x, <span class="type">double</span> k)</span> </span>&#123;</span><br><span class="line">    T &amp;self = <span class="built_in">static_cast</span>&lt;T &amp;&gt;(x);</span><br><span class="line">    self.<span class="built_in">setValue</span>(self.<span class="built_in">getValue</span>() * k);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很像 C++20 concept？我觉得很像！</p><h2 id="A-CRTP-Helper"><a href="#A-CRTP-Helper" class="headerlink" title="A CRTP Helper"></a>A CRTP Helper</h2><p>每次实现 CRTP 接口的时候，有很多重复工作要做，比如千篇一律的 <code>static_cast</code> 要写，还有 private ctor + friend class 定式，太繁琐。<br>本来使用 CRTP 的初衷就是简化代码，如今岂不是南辕北辙？</p><p>你想到可以抽象出所有的 CRTP 接口的公共部分，做成一个基类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> : CRTP&lt;T&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>这看起来很美好，可是很快你又发现了问题：多个接口造成菱形继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diamond inheritance: CRTP&lt;T&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable&lt;Obj&gt;, Lengthable&lt;Obj&gt; &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用虚继承无助于解决问题：被虚继承的基类是不能用 <code>static_cast</code> 向下转型的。</p><p>试过很多方案都不能解决菱形继承问题（如果有请告诉我），只能硬避开菱形继承了：</p><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Interface</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> Interface&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> : CRTP&lt;T, Scaleable&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lengthable</span> : CRTP&lt;T, Lengthable&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>这样一来，<code>Scaleable</code> 和 <code>Lengthable</code> 的基类是两个不同的类，同时保持了零开销抽象，完美解决问题。</p><p>仔细观察你会发现，CRTP 避开菱形继承的手段恰好是 CRTP！</p><p>顺便提醒一句，调用 <code>self()</code> 的时候必须写 <code>this-&gt;self()</code>，否则编译器不知道正确的名字空间。</p><h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>你很可能已经感觉到把 CRTP 当作接口用有什么好处：  </p><ol><li>接口表达了清晰、明确的语义；  </li><li>既可以重写实现，又可以提供默认实现，十分灵活；  </li><li>编译期内联能力，零开销抽象；  </li><li>链式调用时类型不会退化。<br>但 CRTP 也有不足之处：  </li><li>本质上是语言表达能力不足的妥协（还是推荐 concept）；  </li><li>要求类继承接口，不利于库设计；  </li><li>难以表达两种接口的交集；  </li><li>容易写 Bug，编译报错信息不友好；  </li><li>宣告放弃动态绑定，需要谨慎设计。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.bilibili.com/video/BV1pq4y1y7oN">双笙子佯谬 - 聊一聊C++设计模式、函数式编程等</a></li><li><a href="https://en.cppreference.com/w/cpp/utility/variant/visit">std::visit - cppreference.com</a></li><li><a href="https://www.cppstories.com/2019/02/2lines3featuresoverload.html/">2 Lines Of Code and 3 C++17 Features - The overload Pattern - C++ Stories</a></li><li><a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern - Wikipedia</a></li><li><a href="https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/">What the Curiously Recurring Template Pattern can bring to your code - Fluent C++</a></li><li><a href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">An Implementation Helper For The Curiously Recurring Template Pattern - Fluent C++</a></li><li><a href="http://baiy.cn/doc/cpp/inside_rtti.htm">白杨 - RTTI、虚函数和虚基类的实现方式、开销分析及使用指导</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;small&gt;
病重躺家，药不能停。&lt;br/&gt;
何以解忧？唯有博客。&lt;br/&gt;
数据在校，不在我心。&lt;br/&gt;
宿舍断电，学校英明！&lt;br/&gt;
回滚旧版，泪眼嘤嘤。&lt;br/&gt;
&amp;nbsp;H T M L ，手写还行！
&lt;/small&gt;

&lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;「多态」是一个很宽泛的理念，对应繁多实现。本文将记录我所看到的多态的各种形态。作者见识短浅，还请读者多多指教。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本文已计划的内容：&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 基于 &lt;code&gt;std::visit&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 实现运行时多态的优化&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 实现&lt;em&gt;重载模式&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; CRTP 实现静态多态&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 静态多态&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 静态接口&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; CRTP 的一些分析和 trick&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; C++20 前基于 SFINAE 的模板偏特化&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; C++20 后基于 &lt;code&gt;concepts&lt;/code&gt; 的模板特化&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Hack 虚函数表，用于优化</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Smart Pointer</title>
    <link href="https://codesire-deng.github.io/2021/12/15/C-smart-pointer/"/>
    <id>https://codesire-deng.github.io/2021/12/15/C-smart-pointer/</id>
    <published>2021-12-14T19:01:23.000Z</published>
    <updated>2022-04-07T15:29:15.458Z</updated>
    
    <content type="html"><![CDATA[<p>本文意在阐述 C++ 智能指针的实现原理，应用场景和潜在的坑。</p><span id="more"></span><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>基于引用计数的智能指针。在构造和析构时修改引用计数。当引用计数为 0 时，析构资源。</p><p>单个引用计数器是线程安全的。但是，shared_ptr 并非线程安全，至少因为两个原因：</p><ol><li>「改写资源指针」与「改写引用计数」，这两步并非原子化。</li><li>「改写共享引用计数」与「改写弱引用计数」，这两步也非原子化。</li></ol><p>陈硕的书和<a href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html">博客</a>给出了一个竞争条件的例子。如果要从多个线程读写同一个 shared_ptr 对象，是<strong>需要加锁</strong>的。</p><h3 id="shared-ptr-的实现原理"><a href="#shared-ptr-的实现原理" class="headerlink" title="shared_ptr 的实现原理"></a>shared_ptr 的实现原理</h3><ol><li>一个 <code>shared_ptr</code> 持有两个裸指针，分别指向资源和「控制块」 (control block)</li><li>控制块主要用于实现引用计数。具体的内容有：<ol><li>指向所管理资源的指针，或者是资源本身</li><li>deleter（已擦除类型）</li><li>allocator（已擦除类型）</li><li><code>shared_ptr</code> 共享引用计数器</li><li><code>weak_ptr</code> 弱引用计数器 （主流实现中 <code>shared_ptr</code> 亦计入弱引用计数）</li></ol></li><li>若使用 <code>make_shared</code> 或 <code>allocate_shared</code> 来构造指针，则资源和控制块一同参与内存申请。<em>这是潜在坑点。</em></li><li>若弱引用计数器不清零，则控制块占用的内存不会被回收。因此若控制块很大（直接存放了资源），则空间性能可能变差。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别名构造函数（aliasing constructor）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( <span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r, element_type* ptr )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新智能指针共享与 r 的控制块，但是 this-&gt;get() 总是返回 ptr，这可以与 r.get() 不相同！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">场景：ptr 是 *r 的数据成员，若 r 存活，则 ptr 必定存活。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="shared-ptr-的潜在坑点"><a href="#shared-ptr-的潜在坑点" class="headerlink" title="shared_ptr 的潜在坑点"></a>shared_ptr 的潜在坑点</h3><ol><li>环形引用导致内存泄漏：使用一个 <code>weak_ptr</code> 来打破环形引用。</li><li>不支持 <code>shared_ptr&lt;T[]&gt;</code>：使用 <code>vector</code> 或 <code>array</code> 作容器。</li><li>容许基类析构函数不是虚函数（似乎是因为构造是泛型的）：小心。</li><li>退化成链状的数据结构在析构时<strong>栈溢出</strong>：反思数据结构的退化，以及是否滥用了 <code>shared_ptr</code>。</li><li>重复使用一个裸指针构造两个 <code>shared_ptr</code>，导致双重释放：<ol><li>裸指针用完就扔。</li><li>不要使用 <code>this</code> 来构造智能指针，而是使用 <code>shared_from_this</code>。<em>这是潜在坑点。</em></li></ol></li><li>若没有任何 <code>shared_ptr</code> 持有对象，此时调用 <code>shared_from_this</code> 就会出问题：<ol><li>C++17 之前，这是 UB。</li><li>C++17 以后，程序抛出 <code>std::bad_weak_ptr</code> 异常。</li><li>最佳实践是禁止访问构造函数，而提供工厂函数返回智能指针。</li></ol></li><li>将 <code>shared_ptr</code> 复制给未知的函数，可能导致环形引用。<ul><li>好比不要在上锁后执行为未知用户代码</li><li>GC 语言同样有回调地狱导致内存泄漏的问题</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enable_shared_from_this 最佳实践</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Best</span> : std::enable_shared_from_this&lt;Best&gt; <span class="comment">// 公有继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Best&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工厂函数返回智能指针</span></span><br><span class="line">    <span class="comment">// nodiscard 防止暴毙</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">static</span> std::shared_ptr&lt;Best&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能使用 make_shared 因为构造函数是私有的，不能转发</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Best&gt;(<span class="keyword">new</span> <span class="built_in">Best</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Best</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr-的应用场景-x2F-条件"><a href="#shared-ptr-的应用场景-x2F-条件" class="headerlink" title="shared_ptr 的应用场景&#x2F;条件"></a>shared_ptr 的应用场景&#x2F;条件</h3><ol><li>多线程&#x2F;异步协作，难以确定资源生命周期。</li><li>主从关系明确，不存在环形引用：树、链表、DAG</li><li>可以在构造函数参数中提供自定义析构器：<code>[](Y* rc) &#123; delect rc; &#125;</code>。</li><li>原本使用 <code>unique_ptr</code> 的数据结构，需要对外提供强引用，则可以改用 <code>shared_ptr</code>。</li></ol><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>独占所有权的智能指针。当持有资源且退出作用域时，会析构资源。所有权只能移动或引用，不能拷贝。</p><h3 id="unique-ptr-的潜在坑点"><a href="#unique-ptr-的潜在坑点" class="headerlink" title="unique_ptr 的潜在坑点"></a>unique_ptr 的潜在坑点</h3><ol><li>退化成链的数据结构在析构时<strong>栈溢出</strong>：反思数据结构；重写数据结构的析构函数。</li></ol><h3 id="unique-ptr-的应用场景"><a href="#unique-ptr-的应用场景" class="headerlink" title="unique_ptr 的应用场景"></a>unique_ptr 的应用场景</h3><ol><li>提供动态对象的 RAII，保证发生异常时对象仍被析构。</li><li>表示对堆对象的独占关系。适合用作类的数据成员，例如表示树的儿子。<ul><li>父亲指针永远只用裸指针，因为儿子存活时父亲一定存活</li><li>单&#x2F;双向链表是树的特例，也适用 <code>unique_ptr</code> + 裸指针。</li></ul></li><li>在接口中明确表达「传递所有权」的语义。</li><li>作为具有移动语义的单个容器使用。</li><li>管理运行时确定长度的定长数组（<code>unique_ptr&lt;T[]&gt;</code> 正确使用 <code>new []</code> <code>delete []</code>）</li><li>用于 Pimpl 编译隔离</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pimpl 抽象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Pimpl = <span class="type">const</span> unique_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>; <span class="comment">// 定义于 *.cpp</span></span><br><span class="line">    Pimpl&lt;Impl&gt; pimpl;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时定长数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">const</span> unique_ptr&lt;Data[]&gt; array;</span><br><span class="line">    <span class="type">size_t</span> arr_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size): <span class="built_in">arr_size</span>(<span class="built_in">make_unique</span>&lt;Data[]&gt;(size)) &#123;&#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>从 <code>shared_ptr</code> 构造而来，但不参与引用计数。</p><h3 id="weak-ptr-的潜在坑点"><a href="#weak-ptr-的潜在坑点" class="headerlink" title="weak_ptr 的潜在坑点"></a>weak_ptr 的潜在坑点</h3><p>良好的设计使得 <code>weak_ptr</code> 坑点较少，只需记得弱引用的存在会使得控制块无法释放即可。</p><h3 id="weak-ptr-的应用场景"><a href="#weak-ptr-的应用场景" class="headerlink" title="weak_ptr 的应用场景"></a>weak_ptr 的应用场景</h3><ol><li>打破 <code>shared_ptr</code> 的循环引用。常用于环形链表、回调函数。</li><li>作为「可空资源的观察者」。根据资源是否为空表现不同的行为。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weak_ptr 做回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad</span><span class="params">(<span class="type">const</span> shared_ptr&lt;X&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">on_draw</span>([=]&#123; x-&gt;<span class="built_in">extra_work</span>(); &#125;); <span class="comment">// x 已经泄露</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good</span><span class="params">(<span class="type">const</span> shared_ptr&lt;X&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">on_draw</span>([w=<span class="built_in">weak_ptr</span>&lt;X&gt;(x)] &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> x = w.<span class="built_in">lock</span>()) x-&gt;<span class="built_in">extra_work</span>(); <span class="comment">// x 有机会析构</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// weak_ptr 做 cache</span></span><br><span class="line"><span class="function">shared_ptr&lt;Payload&gt; <span class="title">create</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> map&lt;<span class="type">int</span>, weak_ptr&lt;Payload&gt;&gt; cache;</span><br><span class="line">    <span class="type">static</span> mutex mut_cache;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">hold</span><span class="params">(mut_cache)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> sp = cache[id].<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!sp) cache[id] = sp = <span class="built_in">make_shared</span>&lt;Payload&gt;();</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://en.cppreference.com/w/cpp/memory">cppreference</a></li><li><a href="https://www.youtube.com/watch?v=JfmTagWcqoE">CppCon 2016: Herb Sutter “Leak-Freedom in C++... By Default.”</a></li><li><a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">Senlin《谈谈 shared_ptr 的那些坑》</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文意在阐述 C++ 智能指针的实现原理，应用场景和潜在的坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++20 Coroutine</title>
    <link href="https://codesire-deng.github.io/2021/11/18/C-20-Coroutine/"/>
    <id>https://codesire-deng.github.io/2021/11/18/C-20-Coroutine/</id>
    <published>2021-11-18T12:48:05.000Z</published>
    <updated>2022-04-04T11:34:09.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>协程</strong>(coroutine)是能够暂停和恢复的函数。</p></blockquote><p>协程是<strong>线程阻塞造成性能下降</strong>的最佳解决方案，尤其是应用在静态线程池中。</p><span id="more"></span><small><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>GoLang 设计的 goroutine 简单好用，大名鼎鼎；虚拟机语言（例如 C#，Javascript，Java）的协程更是逆天改命，强势占领高性能并发的高地；机器队这边简直神速，而我们的人工队 C++ 在干什么呢，不会还没做完 STL network 吧，不会连 <code>format</code> 的编译器支持都没有吧，不会还没推广 <code>import &lt;module&gt;</code> 吧 🥵🥵🥵……</p></small><h2 id="C-的协程"><a href="#C-的协程" class="headerlink" title="C++的协程"></a>C++的协程</h2><p>C++的协程是：</p><ol><li>对称的。一个协程暂停后，可返回 caller 或恢复任意协程。</li><li>语言级特性。编译器知道你在使用协程。然而不比库强到哪里去。</li><li>无栈(Stackless) 的。没有独立运行时栈，无惧爆栈，调度成本低。</li></ol><p>一个协程在被命令「暂停」时，会保证将数据和当前运行位置保存在堆内存（以便恢复现场），然后转移运行权。</p><p>协程允许程序员更美观地编写异步代码，也使懒惰求值的算法成为可能。</p><p>当一个函数出现以下三种关键字之一，它就是协程：</p><ol><li><code>co_await</code> 暂停（直到被命令「恢复」）。</li><li><code>co_yield</code> 暂停同时返回一个值。</li><li><code>co_return</code> 结束整个协程并返回一个值。</li></ol><h2 id="使用协程的理由"><a href="#使用协程的理由" class="headerlink" title="使用协程的理由"></a>使用协程的理由</h2><ol><li>相比于回调和 sender&#x2F;receiver，协程的使用<strong>成本更低</strong>，<strong>性能下限更高</strong>。</li><li>降低使用者的心智负担和阅历要求，催化高质量工程，有望成为<strong>资本宠儿</strong>。<ul><li>例如可以摆脱 asio 里常见的 <code>std::shared_ptr</code>。</li></ul></li></ol><h2 id="C-协程的弱点"><a href="#C-协程的弱点" class="headerlink" title="C++协程的弱点"></a>C++协程的弱点</h2><ol><li>除非编译器优化，每个协程都需要通过 <code>operator new</code> 来分配 frame：<ul><li>动态内存分配可能引发性能问题；</li><li>在嵌入式或异构（例如 GPU）环境下，缺乏动态内存分配能力，难以工作。</li></ul></li><li>除非编译器优化，协程的可定制点太多，需要大量间接调用&#x2F;跳转（而不是内联），同样引起性能问题。<ul><li>目前，编译器通常难以内联协程；</li><li>HALO 优化理论：<a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2021/p2300r3.html#biblio-p0981r0">P0981R0</a>。</li></ul></li><li><strong>动态分配</strong>和<strong>间接调用</strong>的存在，导致协程暂时无法成为异步框架的最优方法。</li><li>Debug 的体验风评不佳。</li></ol><h2 id="协程的限制"><a href="#协程的限制" class="headerlink" title="协程的限制"></a>协程的限制</h2><ol><li>不能使用变参模板</li><li>不能使用 <code>return</code></li><li>不能使用占位符返回类型 （<code>auto</code> 或者 Concept）</li><li>不能是 constexpr 函数</li><li>不能是构造函数或者析构函数</li><li>不能是 <code>main</code> 函数</li></ol><h2 id="协程的运行过程"><a href="#协程的运行过程" class="headerlink" title="协程的运行过程"></a>协程的运行过程</h2><p>所有协程必须关联着几个对象：</p><ol><li><strong>promise object</strong>，在协程内部进行操作，协程向其写入结果或者异常。</li><li><strong>coroutine handle</strong>，在协程外部进行操作，用于恢复协程或者销毁协程帧(frame)。</li><li><strong>coroutine state</strong>，保存协程的信息，分配于堆内存上（除非被优化），对程序员不可见。具体保存着：<ol><li>promise object</li><li>所有协程参数（按值复制或移动）</li><li>记录暂停点的状态机</li><li>局部变量和临时变量</li></ol></li></ol><hr><p>当协程「开始」时，它会：</p><ol><li>使用 <code>operater new</code> 来构造 coroutine state。</li><li>将所有协程参数拷贝或移动到 coroutine state。<em>小心发生「垂悬引用」，尤其在协程恢复后。</em></li><li>构造 promise object。优先调用接受所有协程参数的构造函数，否则调用默认构造函数。</li><li>调用 <code>promise.get_return_object()</code>，其结果保存为本地变量。此结果在第一次暂停时会返回给 caller。包括这一步和以前的步骤，所有异常都会抛给 caller，而不是放入 promise object。</li><li>调用 <code>promise.initial_suspend()</code>，紧接着 <code>co_await</code> 它。<em>常见的返回值是 <code>suspend_always</code> 用于懒汉协程，或者 <code>suspend_never</code> 用于饿汉协程</em></li><li>当 <code>co_await promise.initial_suspend()</code> 恢复后，协程开始运行其函数体。</li></ol><hr><p>当协程到达暂停点，它会：</p><ol><li>将 return object 返回给执行权所有者，类型应为协程的返回类型，允许发生隐式转换。</li></ol><hr><p>当协程到达 <code>co_return [expr]</code> 语句，它会：</p><ol><li>调用 <code>promise.return_void()</code>，条件是：<ol><li><code>co_return;</code></li><li><code>co_return expr</code> 而 expr 的类型是 void</li><li>函数体结束</li></ol></li><li>或者调用 <code>promise.return_value(expr)</code>。</li><li>析构所有自动变量。</li><li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。</li></ol><hr><p>当协程因未捕获异常而结束，它会：</p><ol><li>捕获这个异常，并在 <code>catch</code> 块中调用 <code>promise.unhandled_exception()</code></li><li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。此时恢复另一个协程是 UB。</li></ol><hr><p>当 coroutine state 被析构（要么遇到 <code>co_return</code>，要么未捕获异常，在要么被 handle 销毁）时，它会：</p><ol><li>析构 promise object。</li><li>析构所有协程参数。</li><li>使用 <code>operator delete</code> 来释放coroutine state。</li><li>转移执行权。</li></ol><h2 id="关于堆分配"><a href="#关于堆分配" class="headerlink" title="关于堆分配"></a>关于堆分配</h2><p>动态内存分配可能成为<strong>严重性能瓶颈</strong>！</p><p>程序员可通过自定义 <code>operator new</code> 来控制 coroutine state 的分配。这部分暂时忽略不讲。</p><h2 id="Promise类型推导"><a href="#Promise类型推导" class="headerlink" title="Promise类型推导"></a>Promise类型推导</h2><p>这部分暂时忽略不讲。</p><h2 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h2><p>一元运算符 <code>co_await</code> 会暂停协程并将转移执行权。其操作数必须定义 <code>operator co_await</code>，或者能通过当前协程的 <code>Promise::await_transform</code> 转换成这种类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">co_await</span> expr</span><br></pre></td></tr></table></figure><p><img src="/2021/11/18/C-20-Coroutine/co_await.svg" alt="co_await"></p><p>首先，<code>expr</code> 要被转换为 awaitable，规则如下：</p><ol><li>如果 <code>expr</code> 是由 initial suspend point，final suspend point 或者 yield expression 生成的，那么 awaitable 就是 <code>expr</code> 本身。</li><li>否则，如果当前协程有定义 <code>Promise::await_transform</code>，那么 awaitable 就是 <code>promise.await_transform(expr)</code>。</li><li>否则，awaitable 就是 <code>expr</code> 本身。</li></ol><p>然后生成一个 awaiter object，规则如下：</p><ol><li>根据重载解析的结果调用 <code>opeartor co_await(awaitable)</code> 或者 <code>awaitable.operator co_await()</code></li><li>如果重载解析找不到函数，那么 awaiter 就是 awaitable 本身。</li><li>如果重载解析有歧义，那么程序是 ill-formed。</li></ol><p>然后，调用 <code>awaiter.await_ready()</code>并判断，决定是否暂停协程：</p><ul><li>若 <code>false</code>，协程暂停，必要的信息存放于 coroutine state。然后调用 <code>awaiter.await_suspend(handle)</code>。在这个函数中，通过 <code>handle</code> 可以访问 coroutine state，也是这个函数有责任安排协程在某个 executor 上恢复（甚至立即就地恢复），或者干脆销毁协程：<ul><li>若 <code>awaiter.await_suspend(handle)</code> 返回 void，执行权立即转移（给 caller&#x2F;resumer）。</li><li>否则若返回 bool，<ul><li>若 <code>true</code> 则转移执行权（给 caller&#x2F;resumer）。</li><li>若 <code>false</code> 则恢复当前协程。</li></ul></li><li>否则返回一个 coroutine handle（对应其他协程），调用这个 <code>other_handle.resume()</code>。注意链式调用可能最终恢复当前协程。</li><li>当前协程恢复后，返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li></ul></li><li>若 <code>true</code>，协程直接返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li></ul><p>注意在进入 <code>awaiter.await_suspend(handle)</code> 之前，当前协程已经完全暂停，此时当前 handle 可以在线程之间自由传递，并由其他调度者恢复。在这种情况下，协程可能已经被恢复，awaiter 随之已经被析构，所以 <code>await_suspend()</code> 不应再访问 <code>*this</code>。</p><h2 id="co-yield"><a href="#co-yield" class="headerlink" title="co_yield"></a>co_yield</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">co_yield</span> expr</span><br><span class="line"><span class="keyword">co_yield</span> braced-init-list</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">co_await</span> promise.<span class="built_in">yield_value</span>(expr)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt;(coroutine)是能够暂停和恢复的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协程是&lt;strong&gt;线程阻塞造成性能下降&lt;/strong&gt;的最佳解决方案，尤其是应用在静态线程池中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="语法" scheme="https://codesire-deng.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
    <category term="C++协程" scheme="https://codesire-deng.github.io/tags/C-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程实战</title>
    <link href="https://codesire-deng.github.io/2021/11/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://codesire-deng.github.io/2021/11/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</id>
    <published>2021-11-08T09:39:50.000Z</published>
    <updated>2022-03-06T09:45:13.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前方施工中"><a href="#前方施工中" class="headerlink" title="前方施工中"></a>前方施工中</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://chenshuo.com/practical-network-programming/">chenshuo.com&#x2F;pnp</a></li><li><a href="https://www.bilibili.com/video/BV1TA411q75p">陈硕-网络编程实战(TCP&#x2F;UDP&#x2F;Socket)</a></li><li>原来的 <a href="http://boolan.com/course/10093">Boolan 博览课</a>已经 404</li></ul><span id="more"></span><h2 id="如何保证可靠的-TCP-连接"><a href="#如何保证可靠的-TCP-连接" class="headerlink" title="如何保证可靠的 TCP 连接"></a>如何保证可靠的 TCP 连接</h2><h3 id="发送比接收更难"><a href="#发送比接收更难" class="headerlink" title="发送比接收更难"></a>发送比接收更难</h3><ul><li>按难度排序：<ol><li>服务器建立 TCP &lt; 客户端建立 TCP &lt; 销毁 TCP</li><li>接收 TCP 数据 &lt; 发送 TCP 数据 （尤其在非阻塞 IO 中）</li></ol></li><li>常见错误：<code>send()</code>+<code>close()</code> 导致丢数据<ul><li>如果接收缓冲区里有数据，<code>close()</code> 会导致 RST 段（而不是 FIN 段）强行断连，不论发送缓冲区是否为空，导致对方丢数据。</li><li><code>SO_LINGER</code> 不能解决这个问题。</li><li>正确发送端做法：<code>send()</code>+<code>shutdown_write()</code>+<code>read_until_eof()</code>+<code>close()</code></li><li>正确接收端做法：<code>read() -&gt; 0</code> + nothing to send + <code>close()</code></li><li>再考虑服务器防御：<code>shutdown_write()</code> 后设置超时，无论如何都关闭连接。</li><li>更好的做法是在协议中包含数据长度，使 App 能够判断数据是否完整。</li><li>还有一点漏洞：sender 无法保证 receiver 已经正确处理数据，例如 receiver 崩溃时，sender 也会读到 eof。</li></ul></li></ul><h3 id="启用-SO-REUSEADDR"><a href="#启用-SO-REUSEADDR" class="headerlink" title="启用 SO_REUSEADDR"></a>启用 SO_REUSEADDR</h3><ul><li>允许重复监听同一个端口<ul><li>以便 server 崩溃之后可以立即重启</li><li>以便多进程 server 监听同一个端口</li></ul></li></ul><h3 id="在-Server-中处理-SIGPIPE-信号"><a href="#在-Server-中处理-SIGPIPE-信号" class="headerlink" title="在 Server 中处理 SIGPIPE 信号"></a>在 Server 中处理 SIGPIPE 信号</h3><ul><li>在 Linux I&#x2F;O 中，若输出管道已经关闭，则 writer 会收到 SIGPIPE 信号。默认的反应行为是中止进程。</li><li>默认行为在多数场景下十分好用，可以提前结束工作流，减少 CPU 浪费。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip -c huge.log.gz | grep ERROR | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>然而在网络编程中，若 Client 已经关闭，则 Server 同样会收到 SIGPIPE 信号。</li><li>Server 应当小心处理 SIGPIPE 信号，以防 Client 出错或者恶意响应。</li><li>若直接忽略 SIGPIPE 信号，则应当检查<code>printf()</code>的返回值，在出错时<code>exit()</code>。</li></ul><h3 id="Nagle-算法-TCP-NODELAY"><a href="#Nagle-算法-TCP-NODELAY" class="headerlink" title="Nagle 算法, TCP_NODELAY"></a>Nagle 算法, TCP_NODELAY</h3><ul><li>影响「请求-响应」型协议。</li><li>如果有报文段未收到 ack，<code>write()</code> 就不会发送数据，避免应用层太拉发太多小数据。</li><li>对于「写-写-读」模式，第二次写会被延迟一个 RTT(Round-Trip Time, 往返延迟)。<ul><li>解决办法：应用层缓冲，改成「写-读」模式</li><li>然而难以解决并发请求问题</li></ul></li><li>应当考虑关闭 Nagle 算法<ul><li>Go 语言就是这么干的</li></ul></li></ul><h2 id="起线程还是-IO-复用"><a href="#起线程还是-IO-复用" class="headerlink" title="起线程还是 IO 复用"></a>起线程还是 IO 复用</h2><p>服务器应该选用「thread-per-connect」还是「IO-multiplexing」模式？</p><p>开销的根源在于切换。起线程会有切换开销，IO 复用也有系统调用的开销。</p><ul><li>若客户端不超过硬件并发数，就（几乎）没有线程切换开销。</li><li>若客户端很多，则 IO 复用的系统调用开销小于线程切换开销。</li></ul><h2 id="netcat-实现"><a href="#netcat-实现" class="headerlink" title="netcat 实现"></a>netcat 实现</h2><ol><li>阻塞式，2 threads per connection</li><li>IO-multiplexing</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前方施工中&quot;&gt;&lt;a href=&quot;#前方施工中&quot; class=&quot;headerlink&quot; title=&quot;前方施工中&quot;&gt;&lt;/a&gt;前方施工中&lt;/h2&gt;&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://chenshuo.com/practical-network-programming/&quot;&gt;chenshuo.com&amp;#x2F;pnp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1TA411q75p&quot;&gt;陈硕-网络编程实战(TCP&amp;#x2F;UDP&amp;#x2F;Socket)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原来的 &lt;a href=&quot;http://boolan.com/course/10093&quot;&gt;Boolan 博览课&lt;/a&gt;已经 404&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
    <category term="计算机网络" scheme="https://codesire-deng.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 学习笔记</title>
    <link href="https://codesire-deng.github.io/2021/08/05/cuda/"/>
    <id>https://codesire-deng.github.io/2021/08/05/cuda/</id>
    <published>2021-08-05T15:50:25.000Z</published>
    <updated>2021-08-15T08:12:13.883Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li>《CUDA 编程 基础与实践》樊哲勇</li><li><a href="https://docs.nvidia.com/cuda/index.html">CUDA Toolkit Documentation</a></li></ul><h2 id="获得-GPU-加速的关键"><a href="#获得-GPU-加速的关键" class="headerlink" title="获得 GPU 加速的关键"></a>获得 GPU 加速的关键</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol><li>数据传输比例较小</li><li>核函数的算术强度较高</li><li>核函数中定义的线程数目较多</li></ol><h4 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h4><ol><li>减少主机与设备之间的数据传输</li><li>提高核函数的算术强度</li><li>增大核函数的并行规模</li></ol><span id="more"></span><h2 id="SM-流多处理器"><a href="#SM-流多处理器" class="headerlink" title="SM 流多处理器"></a>SM 流多处理器</h2><p>官方有时简称 Multiprocessor</p><h3 id="SM-的构成"><a href="#SM-的构成" class="headerlink" title="SM 的构成"></a>SM 的构成</h3><ol><li>寄存器</li><li>共享内存</li><li>常量内存的缓存</li><li>纹理和表面内存的缓存</li><li>L1 缓存</li><li>（常见4个）线程束调度器</li><li>执行核心：INT32, FP32, FP64, 单精度浮点数超于函数的特殊函数单元(special function unit, SFUs), 混合精度的张量核心(tensor cores)</li></ol><h3 id="SM-的占有率"><a href="#SM-的占有率" class="headerlink" title="SM 的占有率"></a>SM 的占有率</h3><p>当并行规模较小，有些 SM 占有率为零，导致程序性能低下。当并行规模足够大时，也有可能得到非 100% 的占有率。</p><p>考虑指标（查询官方文档 CUDA_Occupancy_Calculator.xls 的图灵架构）：</p><ol><li>一个 SM 最多拥有线程块个数$\ N_b &#x3D; 16$。</li><li>一个 SM 最多拥有的线程个数$\ N_t &#x3D; 1536$。</li><li>线程块大小最大为$\ 1024$。</li></ol><p>当并行规模足够大（核函数配置的总线程数足够多），需要分几种情况讨论 SM 的理论占有率：</p><ol><li>寄存器核共享内存使用量很少。SM 的占有率完全由线程块大小决定。首先，由于线程束大小是 32，线程块大小最好是 32 的倍数。其次，线程块大小不能小于$\ N_t&#x2F;N_b$​，才可能利用最大线程数量。因此，96 的线程块大小就能获得 100% 的占有率。类似的，128 的线程块大小在开普勒架构下能获得满占有率。（我选择 128）</li><li>寄存器带来占有率瓶颈。一个 SM 最多有 65536（64K）个寄存器。如果令线程数最大化（1536），那么平均一个线程可用 42.7 个寄存器。当每个线程所用的寄存器个数大于 42 时，SM 的占有率将低于 50%。</li><li>有限的共享内存对占有率的约束。一个 SM 拥有 65536 字节共享内存。如果线程块大小为 128，且SM 是线程满载（1536），要令占有率为 100%，则网格大小为 12，一个线程块最多有 5461 字节的共享内存。</li></ol><h3 id="运行时API查询设备"><a href="#运行时API查询设备" class="headerlink" title="运行时API查询设备"></a>运行时API查询设备</h3><p>参考<code>deviceQuery.cpp</code></p><h2 id="全局内存的合理使用"><a href="#全局内存的合理使用" class="headerlink" title="全局内存的合理使用"></a>全局内存的合理使用</h2><h3 id="合并访问"><a href="#合并访问" class="headerlink" title="合并访问"></a>合并访问</h3><p>全局内存具有最高的延迟，所以配置有缓存，每次 Cache Miss 默认读取 32 字节。由于缓存命中问题，需要提高内存访问的合并度，从而提高效率。简单起见，只考虑全局内存到 L2 缓存。可以定义合并度(degree of coalescing) 为<strong>一个线程束</strong>请求的字节数除以实际数据传输处理的字节数。合并度体现了显存带宽的利用率。</p><p>CUDA 运行时 API 函数分配的内存的首地址至少是256字节的整数倍。</p><p>只要确保每当线程束读取一次内存后，该内存对应的32字节范围都被当前线程束利用，则合并度就是100%。</p><p>对于一个线程束访问同一个全局内存地址的 4 字节，属于广播式的非合并访问（因为只用了 4 字节而非 32 字节，合并度为 12.5%）。如果内存只读，那么适合采用常量内存。</p><h3 id="写优先于只读"><a href="#写优先于只读" class="headerlink" title="写优先于只读"></a>写优先于只读</h3><p>有时候合并写入与合并读取无法兼顾，例如矩阵转置。此时应当优先保证写入是合并的。</p><p>这是因为从帕斯卡架构开始，若编译器判定一个全局内存变量在整个核函数的范围内都<strong>只读</strong>，则会自动用函数<code>__ldg()</code>读取全局内存，附带缓存效果，缓解非合并访问的影响。但对于全局内存的写入，没有类似的优化手段。</p><h2 id="共享内存的合理使用"><a href="#共享内存的合理使用" class="headerlink" title="共享内存的合理使用"></a>共享内存的合理使用</h2><p>在核函数内，使用<code>__shared__</code>修饰的变量（数组）将使用共享内存。同一线程块使用同一个共享内存副本，而不同线程块的共享内存是互相独立的，不可见的。</p><p>利用共享内存，可以消除一些无法兼顾读写合并的全局内存访问，例如数组归约，先将要读取的数据从全局内存拷贝至共享内存（然后<code>__syncthreads()</code>同步一下），可以带来细微的性能提升。</p><p>对共享内存的访问越频繁，性能提升越明显。</p><h3 id="动态共享内存"><a href="#动态共享内存" class="headerlink" title="动态共享内存"></a>动态共享内存</h3><p>共享内存大小可以在核函数的执行配置中指定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;grid_size, block_size, <span class="built_in">sizeof</span>(real) * block_size&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>同时要修改共享内存变量的声明方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">__shared__ real a[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">extern</span> __shared__ real a[];</span><br></pre></td></tr></table></figure><p>动态和静态的声明方式在性能上几乎没有差别。</p><h3 id="避免共享内存的bank冲突"><a href="#避免共享内存的bank冲突" class="headerlink" title="避免共享内存的bank冲突"></a>避免共享内存的bank冲突</h3><p>共享内存在物理上被分为 32 个（恰好是线程束大小）个 bank，多个线程同时访问同一个 bank 会导致冲突；多个线程同时访问不同的 bank 能取得更高的性能。</p><p>除了开普勒架构（8 字节）外，每 4 个字节被划分到一个 bank。例如 <code>0000</code> 属于 bank0，<code>0004</code> 属于 bank1 …… <code>0128</code> 属于 bank0。可以看出，每个 bank 的相邻层的地址相差 128。</p><p>一个线程束试图同时访问同一个 bank 中的 n 层数据将导致 n 次 内存事务(memory transaction)。亦称为 n 路 bank 冲突。n 很大的 bank 冲突是要尽量避免的。</p><p>在矩阵转置中，写入共享内存时易产生 bank 冲突，可以通过修改数组大小解决。</p><p>记得双精度浮点数占 8 字节。</p><h2 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h2><p>例如在数组归约（加法）中，要令GPU完成求和，需要使用原子操作。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>原子函数在全局内存和共享内存上体现原子性。</p><p>原子函数不依赖内存栅栏，不需要线程同步或顺序约束（参考<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomic-functions">官方文档</a>）。</p><p>原子函数只能用于设备函数。</p><h3 id="原子性粒度"><a href="#原子性粒度" class="headerlink" title="原子性粒度"></a>原子性粒度</h3><p>系统原子性：在任意 CPU 和 GPU 的任意线程上保持原子性。函数名有后缀<code>_system</code>，如<code>atomicAdd_system</code>。</p><p>设备原子性：在当前 GPU 的任意线程上保持原子性。函数名无附加后缀。</p><p>线程块原子性：在当前 GPU 的同一线程块中的任意线程上保持原子性。函数名有后缀<code>_block</code>，如<code>atomicAdd_block</code>。</p><h3 id="原子函数速查"><a href="#原子函数速查" class="headerlink" title="原子函数速查"></a>原子函数速查</h3><p><strong>注意：所有的函数都返回旧值</strong></p><p>支持的类型可参考书第 92 页。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T in &#123;int, unsigned int, unsigned long long int&#125;</span></span><br><span class="line"><span class="keyword">using</span> UI = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">T <span class="title">atomicAdd</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 加法，支持浮点</span></span><br><span class="line"><span class="function">T <span class="title">atomicSub</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 减法，支持浮点</span></span><br><span class="line"><span class="function">T <span class="title">atomicExch</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// new = val，支持float</span></span><br><span class="line"><span class="function">T <span class="title">atomicMin</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 最小值</span></span><br><span class="line"><span class="function">T <span class="title">atomicMax</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 最大值</span></span><br><span class="line"><span class="function">UI <span class="title">atomicInc</span><span class="params">(UI *address, UI val)</span></span>; <span class="comment">// new = (old &gt;= val) ? 0 : (old+1)</span></span><br><span class="line"><span class="function">UI <span class="title">atomicDec</span><span class="params">(UI *address, UI val)</span></span>; <span class="comment">// new = ((old == 0) || (old &gt; val)) ? val : (old-1)</span></span><br><span class="line"><span class="function">T <span class="title">atomicAnd</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位与</span></span><br><span class="line"><span class="function">T <span class="title">atomicOr</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位或</span></span><br><span class="line"><span class="function">T <span class="title">atomicXor</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位异或</span></span><br><span class="line"><span class="function">T <span class="title">atomicCAS</span><span class="params">(T *address, T compare, T val)</span></span>; <span class="comment">// new = old == compare ? val : old。支持unsigned short int</span></span><br></pre></td></tr></table></figure><h2 id="线程束与协作组"><a href="#线程束与协作组" class="headerlink" title="线程束与协作组"></a>线程束与协作组</h2><h3 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h3><p>单指令-多线程（single instruction multiple thread, SIMT）：不同线程共享同一个 PC。SIMT 的通病是分支发散（branch divergence），所有的分支会产生串行的时间开销。</p><p>在伏特架构之前，一个线程束共享一个 PC。不同线程束之间没有分支发散问题。</p><p>从伏特架构开始，引入了独立线程调度（independent thread scheduling）机制。每个线程有自己的 PC，使得需要用户自己控制线程束内的同步。另一个代价是每个线程需要用两个寄存器来做 PC。如果旧代码出现线程束内不安全的问题，可以指定虚拟架构为低于伏特架构的计算能力。</p><h3 id="线程束内的线程同步"><a href="#线程束内的线程同步" class="headerlink" title="线程束内的线程同步"></a>线程束内的线程同步</h3><p><code>__syncwarp()</code>比线程块同步函数<code>__syncthreads()</code>更加廉价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">void</span> __syncwarp(<span class="type">unsigned</span> mask = <span class="number">0xffffffff</span>);</span><br></pre></td></tr></table></figure><p>其中掩码表示参与同步的线程，默认 32 个线程全部参与。</p><p>在分治时，当问题规模缩小到一个线程束内，可以不使用<code>__syncthreads</code>而用<code>__syncwarp</code>。</p><h3 id="更多线程束内的基本函数"><a href="#更多线程束内的基本函数" class="headerlink" title="更多线程束内的基本函数"></a>更多线程束内的基本函数</h3><p><strong>注意：若当前线程不参与，则函数的返回值是无定义的。</strong></p><p>线程束表决函数（warp vote functions）</p><p>线程束匹配函数（warp match functions）<em>待续</em></p><p>线程束洗牌函数（warp shuffle functions）</p><p>线程束矩阵函数（warp matrix functions）<em>待续</em></p><h4 id="线程束表决"><a href="#线程束表决" class="headerlink" title="线程束表决"></a>线程束表决</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __ballot_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步表决下一次参与意愿（当 predicate 非零，则令返回值对应位置 1， 否则置 0。）。相当于从旧掩码表决出一个新掩码。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __all_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步投票，一票否决，返回投票是否通过。所有参与线程都同意才通过。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __any_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步投票，一票通过，返回投票是否通过。</span></span><br></pre></td></tr></table></figure><h4 id="线程束洗牌"><a href="#线程束洗牌" class="headerlink" title="线程束洗牌"></a>线程束洗牌</h4><p>定义“束内指标” <code>int lane_id = threadIdx.x % w</code>。</p><p><code>w</code> 是逻辑线程束大小，只能取 2、4、8、16、32 中的一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T __shfl_sync(<span class="type">unsigned</span> mask, T v, <span class="type">int</span> srcLane, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 参与线程返回标号为 srcLane 的变量 v 的值。这是一种广播式数据交换。 </span></span><br><span class="line"></span><br><span class="line">T __shfl_up_sync(<span class="type">unsigned</span> mask, T v, <span class="type">unsigned</span> d, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t - d 的线程中的 v 的值；若 t - d &lt; 0 则返回原来的 v。相当于数据向上平移。</span></span><br><span class="line"></span><br><span class="line">T __shfl_down_sync(<span class="type">unsigned</span> mask, T v, <span class="type">unsigned</span> d, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t + d 的线程中的 v 的值；若 t + d &gt;= w 则返回原来的 v。相当于数据向下平移。</span></span><br><span class="line"></span><br><span class="line">T __shfl_xor_sync(<span class="type">unsigned</span> mask, T v, <span class="type">int</span> laneMask, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t ^ laneMask 的线程中的 v 的值；相当于对应的两个线程交换数据。</span></span><br></pre></td></tr></table></figure><p>使用线程束洗牌优化数组归约：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> FULL_MASK = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">reduce_shfl</span><span class="params">(<span class="type">const</span> real *d_x, real *d_y, <span class="type">const</span> <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = bid * blockDim.x + tid;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ real s_y[];</span><br><span class="line">    s_y[tid] = (n &lt; N ? d_x[n] : <span class="number">0.0</span>);</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = blockDim.x &gt;&gt; <span class="number">1</span>; offset &gt;= <span class="number">32</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; offset) &#123;</span><br><span class="line">            s_y[tid] += s_y[tid + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real y = s_y[tid]; <span class="comment">// 寄存器优化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">16</span>; offset &gt; <span class="number">0</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        y +=  __shfl_down_sync(FULL_MASK, y, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">atomicAdd</span>(d_y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协作组"><a href="#协作组" class="headerlink" title="协作组"></a>协作组</h3><p>协作组（cooperative groups）可以看作线程块和线程束同步机制的推广。范围涵盖线程块内部，线程块之间（网格级）及设备之间的同步与协作。</p><p>引入头文件和命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> cg = cooperative_groups; <span class="comment">// 仅供参考</span></span><br></pre></td></tr></table></figure><h4 id="线程块级别的协作组"><a href="#线程块级别的协作组" class="headerlink" title="线程块级别的协作组"></a>线程块级别的协作组</h4><p>基本类型<code>thread_group</code>。有如下成员：</p><ol><li><code>void sync()</code> 同步组内所有线程</li><li><code>unsigned size()</code> 返回组内总的线程数目</li><li><code>unsigned thread_rank()</code> 返回当前线程的组内标号</li><li><code>bool is_valid()</code> 检查定义的组是否违反 CUDA 的任何限制</li></ol><p>导出类型<code>thread_block</code>，额外函数：</p><ol><li><code>dim3 group_index()</code> 返回当前线程的线程块指标，相当于 blockIdx</li><li><code>dim3 thread_index()</code> 相当于 threadIdx</li></ol><p>于是可以抽象出当前线程块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread_block g = <span class="built_in">this_thread_block</span>();</span><br><span class="line">g.<span class="built_in">sync</span>(); <span class="comment">// 等价于 __syncthreads()</span></span><br></pre></td></tr></table></figure><p>可以将 <code>thread_block</code> 进行多次分割（但一组线程的数量只能是 2 的幂次）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_group g32 = <span class="built_in">tiled_partition</span>(<span class="built_in">this_thread_block</span>(), <span class="number">32</span>); <span class="comment">// 相当于线程束</span></span><br><span class="line">thread_group g4 = <span class="built_in">tiled_partition</span>(g32, <span class="number">4</span>); <span class="comment">// 再次分割</span></span><br><span class="line"><span class="comment">// ---------- 模板化版本 ----------</span></span><br><span class="line">thread_block_tile&lt;<span class="number">32</span>&gt; g32 = <span class="built_in">tiled_partition</span>&lt;<span class="number">32</span>&gt;(<span class="built_in">this_thread_block</span>());</span><br></pre></td></tr></table></figure><p>这样的“线程块片”可以模仿线程束的一些行为，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __ballot_sync(<span class="type">int</span> predicate);</span><br><span class="line"><span class="type">int</span> __all_sync(<span class="type">int</span> predicate);</span><br><span class="line"><span class="type">int</span> __any_sync(<span class="type">int</span> predicate);</span><br><span class="line">T __shfl_sync(T v, <span class="type">int</span> srcLane);</span><br><span class="line">T __shfl_up_sync(T v, <span class="type">unsigned</span> d);</span><br><span class="line">T __shfl_down_sync(T v, <span class="type">unsigned</span> d);</span><br><span class="line">T __shfl_xor_sync(T v, <span class="type">int</span> laneMask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对线程束的不同点：1. 不允许掩码，所有线程必须参与 2. 洗牌函数不再需要宽度参数，宽度由线程块片大小确定</span></span><br></pre></td></tr></table></figure><h3 id="再次优化数组归约"><a href="#再次优化数组归约" class="headerlink" title="再次优化数组归约"></a>再次优化数组归约</h3><p>这次我们采用的技巧有：</p><ol><li>使用静态全局内存</li><li>调用两次核函数，舍弃原子加法函数（这会提高精确度）</li><li>提高线程利用率（在规约之前进行小部分求和）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;real.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;widgets.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> FULL_MASK = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">reduce_cp</span><span class="params">(<span class="type">const</span> real *d_x, real *d_y, <span class="type">const</span> <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ real s_y[];</span><br><span class="line"></span><br><span class="line">    real y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> stride = blockDim.x * gridDim.x; <span class="comment">// 以网格大小为跨度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = bid * blockDim.x + tid; n &lt; N; n += stride) &#123;</span><br><span class="line">        y += d_x[n]; <span class="comment">// 确保一个网格能覆盖所有数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    s_y[tid] = y;</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程块内，跨线程束折半归约</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = blockDim.x &gt;&gt; <span class="number">1</span>; offset &gt;= <span class="number">32</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; offset) &#123;</span><br><span class="line">            s_y[tid] += s_y[tid + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y = s_y[tid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">16</span>; offset &gt; <span class="number">0</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        y += __shfl_down_sync(FULL_MASK, y, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        d_y[bid] = y; <span class="comment">// 返回线程块结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> GRID_SIZE = <span class="number">10240</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> BLOCK_SIZE = <span class="number">128</span>;</span><br><span class="line">__device__ real d_input[N];</span><br><span class="line">__device__ real d_output[GRID_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function">real <span class="title">reduce</span><span class="params">(<span class="type">const</span> real *d_x)</span> </span>&#123;</span><br><span class="line">    real *d_y;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaGetSymbolAddress</span>((<span class="type">void</span>**)&amp;d_y, d_output));</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> shared_size = <span class="built_in">sizeof</span>(real) * BLOCK_SIZE;</span><br><span class="line">    reduce_cp&lt;&lt;&lt;GRID_SIZE, BLOCK_SIZE, shared_size&gt;&gt;&gt;(d_x, d_y, N);</span><br><span class="line">    reduce_cp&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1024</span>, <span class="built_in">sizeof</span>(real) * <span class="number">1024</span>&gt;&gt;&gt;(d_y, d_y, GRID_SIZE);</span><br><span class="line"></span><br><span class="line">    real h_y[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpy</span>(h_y, d_y, <span class="built_in">sizeof</span>(real), cudaMemcpyDeviceToHost));</span><br><span class="line">    <span class="comment">// CHECK(cudaMemcpyFromSymbol(h_y, d_output, sizeof(real)));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h_y[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">static</span> real input[N];</span><br><span class="line">    std::<span class="built_in">fill_n</span>(input, N, <span class="number">1.23f</span>);</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpyToSymbol</span>(d_input, input, N * <span class="built_in">sizeof</span>(real)));</span><br><span class="line">    real *d_x;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaGetSymbolAddress</span>((<span class="type">void</span>**)&amp;d_x, d_input));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="built_in">reduce</span>(d_x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 123000064.000000</span></span><br><span class="line"><span class="comment">// 对比 CPU 裸归约方法的加速比：67</span></span><br></pre></td></tr></table></figure><h2 id="CUDA-流"><a href="#CUDA-流" class="headerlink" title="CUDA 流"></a>CUDA 流</h2><h3 id="核函数外部的并行"><a href="#核函数外部的并行" class="headerlink" title="核函数外部的并行"></a>核函数外部的并行</h3><p>主要有以下情形：</p><ol><li>核函数计算与数据传输之间的并行</li><li>主机计算与数据传输之间的并行</li><li>不同的数据传输之间的并行</li><li>核函数计算与主机计算之间的并行</li><li>不同核函数之间的并行</li></ol><p>若两个任务的运行时间相近，则尽量令他们并行。反之，则并行和串行的性能差距不大。</p><p>使用 CUDA 流的主要目的是尽量取得核函数外部的并行能力。</p><h3 id="使用-CUDA-流"><a href="#使用-CUDA-流" class="headerlink" title="使用 CUDA 流"></a>使用 CUDA 流</h3><p>CUDA 流的使用相对简单，只要记住一些规则就好。</p><ol><li><p>CUDA 程序有一个默认流。若 API 不需要指定流句柄，可推测它用于默认流。</p></li><li><p>创建、销毁 CUDA 流</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : stream) &#123;</span><br><span class="line">    <span class="built_in">cudaStreamCreate</span>(&amp;s); <span class="comment">// 创建流，获得句柄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : stream) &#123;</span><br><span class="line">    <span class="built_in">cudaStreamDestroy</span>(s); <span class="comment">// 销毁流，句柄不抹除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测 CUDA 流是否空闲 </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaStreamSynchronize</span><span class="params">(cudaStream_t stream)</span></span>; <span class="comment">// 阻塞主机，直到 CUDA 流完成所有操作</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaStreamQuery</span><span class="params">(cudaStream_t stream)</span></span>; <span class="comment">// 返回 cudaSuccess（已完成）/ cudaErrorNotReady（未完成）</span></span><br></pre></td></tr></table></figure></li><li><p><code>cudaMemcpy</code> 会阻塞主机。但是核函数的调用总是异步的。应该尽量早地调用核函数，随后再进行主机的计算任务。</p></li><li><p>在核函数配置中指派 CUDA 流：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_kernel&lt;&lt;&lt;N_grid, N_block, N_shared, stream_id&gt;&gt;&gt;(...); <span class="comment">// 四个模板参数必须齐全</span></span><br></pre></td></tr></table></figure></li><li><p>异步的数据传输需要：</p><ol><li>使用 <code>cudaMemcpyAsync</code> 函数。</li><li>涉及的主机内存必须是不可分页的，否则 API 将会退化为同步版本。</li></ol><p> 异步传输的过程将由 GPU 的 DMA（direct memory access）接管。</p></li><li><p>可以用 CUDA 运行时 API 来申请不可分页的内存（non-pageable memory），又称固定内存（pinned memory）。不可分页意味着操作系统无权修改虚拟地址所对应的物理地址。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocHost</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaHostAlloc</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> flags)</span></span>;</span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaFreeHost</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>良好的 CUDA 流指派会从流水线重叠中获得并行加速。但是 CUDA 流是有启动开销，且硬件环境有限，过多的 CUDA 流会拉低性能。</p></li></ol><h2 id="指令速查"><a href="#指令速查" class="headerlink" title="指令速查"></a>指令速查</h2><h3 id="编译器选项"><a href="#编译器选项" class="headerlink" title="编译器选项"></a>编译器选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--ptxas-options=-v <span class="comment"># 报道每个核函数的寄存器使用数量</span></span><br><span class="line">--maxrregcount= <span class="comment"># 限制所有核函数的寄存器使用量</span></span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="comment"># 核函数修饰符</span></span><br><span class="line">__device__ <span class="comment"># 设备函数、变量修饰符</span></span><br><span class="line">__host__ <span class="comment"># 主机函数修饰符，一般只与__device__同时出现</span></span><br><span class="line">__noinline__ <span class="comment"># 建议函数非内联</span></span><br><span class="line">__forceinline__ <span class="comment"># 建议函数内联</span></span><br><span class="line">__launch_bounds__() <span class="comment"># 修饰核函数，限制寄存器使用量</span></span><br><span class="line">__shared__ <span class="comment"># 修饰全局变量，使它成为共享内存</span></span><br><span class="line">__managed__ <span class="comment"># 修饰全局变量，使它成为统一内存，必须与__device__同时出现</span></span><br></pre></td></tr></table></figure><h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="CMake模板"><a href="#CMake模板" class="headerlink" title="CMake模板"></a>CMake模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2021/08/02</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello LANGUAGES CUDA VERSION <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(USE_DOUBLE <span class="string">&quot;Use real as double, otherwise float&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(CUDAToolkit REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set(CMAKE_CUDA_COMPILER_ID NVIDIA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set(ENV&#123;PATH&#125; &quot;C:/Program\ Files\ (x86)/Microsoft\ Visual\ Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64:$ENV&#123;PATH&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># report registers used in each core function</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(--ptxas-options=-v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(./<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute capability, see https://developer.nvidia.com/zh-cn/cuda-gpus#compute</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> hello PROPERTY CUDA_ARCHITECTURES <span class="number">86</span>)</span><br><span class="line"><span class="comment"># set_property(TARGET hello PROPERTY CUDA_ARCHITECTURES 75)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install(TARGETS hello DESTINATION .)</span></span><br></pre></td></tr></table></figure><h3 id="报错、计时工具"><a href="#报错、计时工具" class="headerlink" title="报错、计时工具"></a>报错、计时工具</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widgets.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(callee)                                            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                         \</span></span><br><span class="line"><span class="meta">        const cudaError_t err = callee;                          \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (err == cudaSuccess) break;                           \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;CUDA error at %s(%d)\n&quot;</span>, __FILE__, __LINE__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Function:   %s\n&quot;</span>, __FUNCTION__);            \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Error code: %d\n&quot;</span>, err);                     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Error hint: %s\n&quot;</span>, cudaGetErrorString(err)); \</span></span><br><span class="line"><span class="meta">        exit(1);                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cudaTiming</span><span class="params">(<span class="type">const</span> F &amp;func)</span> </span>&#123;</span><br><span class="line">    cudaEvent_t start, stop;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventCreate</span>(&amp;start));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventCreate</span>(&amp;stop));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventRecord</span>(start));</span><br><span class="line">    <span class="built_in">cudaEventQuery</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventRecord</span>(stop));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventSynchronize</span>(stop));</span><br><span class="line">    <span class="type">float</span> elapsed_time;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventElapsedTime</span>(&amp;elapsed_time, start, stop));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CUDA Time = %g ms.\n&quot;</span>, elapsed_time);</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventDestroy</span>(start));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventDestroy</span>(stop));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hostTiming</span><span class="params">(<span class="type">const</span> F &amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt; duration = end - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host Time = %g ms.\n&quot;</span>, duration.<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="精度控制模板"><a href="#精度控制模板" class="headerlink" title="精度控制模板"></a>精度控制模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// real.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_DOUBLE</span></span><br><span class="line"><span class="keyword">using</span> real = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">constexpr</span> real EPS = <span class="number">1e-15</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> real = <span class="type">float</span>;</span><br><span class="line"><span class="keyword">constexpr</span> real EPS = <span class="number">1e-6</span>f;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《CUDA 编程 基础与实践》樊哲勇&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.nvidia.com/cuda/index.html&quot;&gt;CUDA Toolkit Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;获得-GPU-加速的关键&quot;&gt;&lt;a href=&quot;#获得-GPU-加速的关键&quot; class=&quot;headerlink&quot; title=&quot;获得 GPU 加速的关键&quot;&gt;&lt;/a&gt;获得 GPU 加速的关键&lt;/h2&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;h4 id=&quot;必要条件&quot;&gt;&lt;a href=&quot;#必要条件&quot; class=&quot;headerlink&quot; title=&quot;必要条件&quot;&gt;&lt;/a&gt;必要条件&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;数据传输比例较小&lt;/li&gt;
&lt;li&gt;核函数的算术强度较高&lt;/li&gt;
&lt;li&gt;核函数中定义的线程数目较多&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;提高性能的技巧&quot;&gt;&lt;a href=&quot;#提高性能的技巧&quot; class=&quot;headerlink&quot; title=&quot;提高性能的技巧&quot;&gt;&lt;/a&gt;提高性能的技巧&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;减少主机与设备之间的数据传输&lt;/li&gt;
&lt;li&gt;提高核函数的算术强度&lt;/li&gt;
&lt;li&gt;增大核函数的并行规模&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="GPGPU" scheme="https://codesire-deng.github.io/tags/GPGPU/"/>
    
  </entry>
  
  <entry>
    <title>C++ 标准笔记</title>
    <link href="https://codesire-deng.github.io/2021/05/03/C/"/>
    <id>https://codesire-deng.github.io/2021/05/03/C/</id>
    <published>2021-05-03T11:15:20.000Z</published>
    <updated>2022-01-02T14:23:10.973Z</updated>
    
    <content type="html"><![CDATA[<p>本文始于 2018&#x2F;6&#x2F;27，用于汇聚关于 C++ 的实用知识和碰到的坑，温故而知新。</p><blockquote><p>2022&#x2F;1&#x2F;2 【更改】标题改为《C++ 标准笔记》<br>2022&#x2F;1&#x2F;2 【新增】StandardLayout<br>2022&#x2F;1&#x2F;2 【新增】bit field</p><p>更新预告：</p><ol><li>CRTP 原理，目的和应用</li><li>CRTP 应用之表达式模板</li></ol></blockquote><span id="more"></span><h2 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h2><ul><li>union可匿名，常在结构定义中。</li><li>用于节省内存，尤其在嵌入式系统中。</li><li>union的定义形式与struct相同。</li></ul><hr><h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum 枚举"></a>enum 枚举</h2><ul><li>enum A {a,b,c};   首项默认为0，默认后项比前项大一。<br>A被看做一种类型，甚至可以省略；a,c,b被看做常量。<br>a,b,c可以自动提升为int, 但int不能自动转换为枚举类型，除非强制转换A（1）。<br>每个enum根据其常量的最大最小值确定其上下限。</li><li>enum创建的常量是静态的, 可以用作静态类成员常量. 运行时所有对象不会包含枚举</li><li><strong>更强的安全性--类作用域内枚举(C++11)</strong><ul><li>enum class name : type {...};</li><li>enum struct name {...};</li><li>class或struct二选一, <code>:type</code>可选.</li><li>作用域内枚举不允许隐式地转换为整型</li><li>默认底层为int</li><li>调用格式为name::x</li></ul></li><li>:type 放在枚举名后以指定底层, 否则将随实现而异.</li></ul><hr><h2 id="char-字符型"><a href="#char-字符型" class="headerlink" title="char 字符型"></a>char 字符型</h2><ul><li>char类型被输入输出流区别对待。cout &lt;&lt; (int*) st &lt;&lt; endl;</li><li>char类型数组的初始化被C++区别对待：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>; 合法,<span class="string">&quot;abcd&quot;</span>被转换为&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;, 可供修改</span><br><span class="line"><span class="type">char</span> s2[<span class="number">5</span>] = s1; 错误，即使s1是<span class="type">const</span>。</span><br><span class="line"><span class="type">char</span>* s3 = <span class="string">&quot;abcd&quot;</span>; 警告, <span class="string">&quot;abcd&quot;</span>是常量,不能修改.   参数<span class="type">char</span> s3[]=<span class="string">&quot;abcd&quot;</span>亦等价警告.</span><br></pre></td></tr></table></figure></li><li><code>const char []</code>所定义的字符串被保护，有内存位置隔离，不允许跟踪（但允许查看）地址。</li><li>char是否带符号取决于系统。</li><li>wchar_t可以表示系统使用的最大扩展字符集，输入输出用wcin,wcout</li><li>raw r&quot;(a&#x2F;b\c回车defg*)&quot;,   标识符  &quot;(   )&quot;  可变为 &quot;*@(  )*@&quot; 等等，保持平移对称</li></ul><h3 id="lt-cstring-gt-常用函数"><a href="#lt-cstring-gt-常用函数" class="headerlink" title="&lt;cstring&gt;常用函数"></a>&lt;cstring&gt;常用函数</h3><ul><li><code>char* strcpy(char* dest, const char* src)</code><ul><li>以src覆盖dest, 直到遇到src的终止符.返回dest.</li></ul></li><li><code>char* strncpy(char* dest, const char* src, size_t count)</code><ul><li>以src的前n位覆盖dest, 若遇到src的终止符则用0填充剩余位.返回dest.</li></ul></li><li><code>char* strcat(char *dest, char *src)</code><ul><li>将src复制到dest的末尾.返回dest.</li></ul></li><li><code>int strcmp(char *str1, char *str2)</code><ul><li>按字典序比较, 返回-1,0,1.</li></ul></li><li><code>int stricmp(char *str1, char *str2)</code><ul><li>按字典序但对大小写不敏感比较.</li></ul></li><li><code>int strncmp(char *str1, char *str2, size_t count)</code><ul><li>按字典序比较前n位</li></ul></li><li><code>int strnicmp(char *str1, char *str2, size_t count)</code><ul><li>按字典序但对大小写不敏感比较前n位</li></ul></li></ul><hr><h2 id="vector与array-模板类"><a href="#vector与array-模板类" class="headerlink" title="vector与array 模板类"></a>vector与array 模板类</h2><ul><li><code>vector&lt;typename&gt; arr(n_elem);</code> 也可以不指定长度</li><li><code>array&lt;typename, n_elem&gt; arr;</code> 定长数组。 等长数组可以直接复制。</li><li>下标可越界，欲防止越界用 <code>arr.at(x)</code></li></ul><hr><h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><ul><li><code>cin.getline(arr, arsize)</code> 空行不设置failbit</li><li><code>cin.get(arr, arsize)</code> 行读取结束后不丢弃换行符（无法跨越）</li><li><code>cin.get()</code> 读取一个任意字符，返回char值</li><li><code>cin.get(char)</code>返回cin</li><li><code>string</code>类读行 <code>getline(cin, str);</code></li></ul><hr><h2 id="fstream-文件流（以fin-fout为例）"><a href="#fstream-文件流（以fin-fout为例）" class="headerlink" title="fstream 文件流（以fin, fout为例）"></a>fstream 文件流（以fin, fout为例）</h2><ul><li>打开文件： <code>.open(&quot;filename&quot;);</code></li><li>关闭文件： <code>.close();</code></li><li>检测最后一次读入遇到EOF： <code>fin.eof();</code></li><li>检测最后一次读入遇到类型不匹配（包括EOF）： <code>fin.fail();</code></li><li>检测最后一次读入文件损坏、故障： <code>fin.bad();</code></li><li>检测最后一次读入完全正常： <code>fin.good();</code>  等价于 <code>(bool) fin &gt;&gt; value;</code></li><li>清空错误标记，准许读入： <code>.clear();</code></li></ul><hr><h2 id="switch-结构控制"><a href="#switch-结构控制" class="headerlink" title="switch 结构控制"></a>switch 结构控制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constValue1 : statement1</span><br><span class="line">            <span class="keyword">break</span>;(optional)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> constValue2 : statement2</span><br><span class="line">            <span class="keyword">break</span>;(optional)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> : statement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><code>exit(EXIT_FAILURE);</code>   ： cstdlib, 同操作系统通信的参数值</li><li><code>nullptr</code> : C++11 关键字, 空指针值.</li></ul><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>应当将空指针写为<code>nullptr</code>. <code>delete</code>和<code>delete []</code> 都可以作用于空指针.</li><li>const 指针 将受保护，非const 指针 不能复制其值（除非利用强制类型转换），不允许通过const 指针 修改所指向值。<br>为了防止欺骗const检查，不允许令const 二级指针指向非const 一级指针</li></ul><hr><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>声明：<code>typename (*pointer name)(parameter list...);</code></li><li>获得某函数的地址：<code>pointer = function name;</code></li><li>使用函数指针：<code>(*pointer)(parameter list...);</code>  或  <code>pointer(parameter list...);</code></li><li>举例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span>* <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">指向f1的指针：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*p1)(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>) = f1; 或 <span class="keyword">auto</span> p1 = f1;</span><br><span class="line"></span><br><span class="line">由f1,f2,f3组成数组：<span class="comment">//[]优先级高于*</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*ar[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>) = &#123;f1, f2, f3&#125;; 不允许<span class="keyword">auto</span></span><br><span class="line"></span><br><span class="line">指向ar[<span class="number">3</span>]的指针：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*(*arp)[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span>[], <span class="type">int</span>) = &amp;ar; 或 <span class="keyword">auto</span> arp = &amp;ar；</span><br><span class="line"></span><br><span class="line">还可以用<span class="keyword">typedef</span>简化声明：</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">double</span>* (*p_fun)<span class="built_in">const</span>(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">p_fun ar[<span class="number">3</span>] = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure></li><li>分析方法: 从变量名开始, 往右往左结合, 逐步解释结合体.<ul><li>当遇到一个指针, 总是关心它指向什么类型</li><li>当遇到一个数组, 总是关心它的元素的类型</li><li>当遇到一个函数, 总是关心它的返回值类型</li></ul></li></ul><hr><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>参量（argument）是实参，参数（parameter）是形参。</li></ul><hr><h2 id="函数重载（函数多态）"><a href="#函数重载（函数多态）" class="headerlink" title="函数重载（函数多态）"></a>函数重载（函数多态）</h2><ul><li>同名函数共存要求：函数特征标（函数参数列表）不同。</li><li>当需要自动类型转换但选项不唯一时，编译不通过。</li><li>不区分const和非const变量（包括指针）。</li><li>区分指向const的指针和指向非const的指针。</li><li>区分指向const的引用和指向非const的引用。（编译器调用最匹配的版本）</li><li>如果没有右值引用参数版本，右值参量将赋给const引用参量。</li></ul><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>左值引用<ul><li>非const引用可以引自可修改的左值（防止修改const值和修改临时变量）</li><li>const引用可以引自任何左值、右值（毕竟数值不会变）</li><li>基类引用可以指向派生类对象</li></ul></li><li>指针也能被引用, 例如 int*&amp; x &#x3D; ptr;</li></ul><hr><h2 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h2><ul><li>||, &amp;&amp;具有短路作用,结果必然时短路,不计算右边的表达式</li></ul><hr><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><ul><li>在声明时用或在第一次调用前的定义用都行</li><li>不能处理递归, 编译器有权拒绝采用.</li><li>函数默认值必须放在原型声明中, 不能放在和声明分离的定义中.只能从右到左地提供默认值</li></ul><hr><h2 id="decltype-expression"><a href="#decltype-expression" class="headerlink" title="decltype(expression)"></a>decltype(expression)</h2><ul><li><p><strong>decltype(expression)核对表</strong></p><ol><li>如果expression是一个不带括号的标识符, 则返回相同类型, 包括const,*等限定符</li><li>否则,如果expression是一个函数调用(需要提供参数),则返回相同类型</li><li>否则,如果expression是一个带括号的左值,则返回其引用</li><li>否则,返回expression的类型(例:右值)</li></ol></li><li><p>可以利用<strong>typedef</strong> decltype(expression) somename;简化声明</p></li><li><p><strong>decltype 用于函数返回类型声明</strong></p><ul><li>声明返回类型时未知参数列表, 所以需要后置声明  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span>     <span class="comment">// &quot;-&gt; 已知类型&quot;  也行</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p><strong>创建模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//也可以用class代替typename</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp;, T&amp;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>显式具体化</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp;, <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>&amp;, <span class="type">int</span>&amp;);</span><br></pre></td></tr></table></figure><p>  <em>为什么需要显示具体化?常规函数不能替代吗?</em></p></li><li><p><strong>显式实例化</strong></p><ul><li>不使用函数就能依照模板生成实例, 常用在库中</li><li><code>template void swap&lt;int&gt;(int&amp;, int&amp;);</code></li><li>使用函数时<code>add&lt;double&gt;((int)a, (double)b);</code> 会强制使用<double>模板.注意引用类型不能隐式类型转换.后续的强制使用仍需加&lt;double&gt;</li></ul></li></ul><hr><h2 id="变量名"><a href="#变量名" class="headerlink" title="::变量名"></a>::变量名</h2><ul><li>表明采用全局变量而非局部变量</li></ul><hr><h2 id="储存空间"><a href="#储存空间" class="headerlink" title="储存空间"></a>储存空间</h2><ol><li>静态储存: 保证初始化为0, 生命周期和程序相同.</li><li>自动储存(栈内存): 不保证初始化;</li><li>动态储存(堆内存): 不保证初始化;</li></ol><hr><h2 id="储存说明符"><a href="#储存说明符" class="headerlink" title="储存说明符"></a>储存说明符</h2><ul><li>static用于变量   <em>编译阶段尽量初始化, 运行时直接分配空间,程序结束时销毁, 首次遇到时再保证初始化</em><ul><li>静态外部链接性变量: 直接在非被包括区域定义, 在其他单元中可用extern引用声明(不允许再次初始化)(ODR单定义规则)</li><li>静态内部链接性变量: 在非被包括区域加static, 限定在本单元内可以访问</li><li>静态无链接性变量:在被包括区域加static, 限定在本包括区域内可以访问</li></ul></li><li>static用于函数 覆盖函数的默认外部链接性为内部链接性,必须同时用于原型和定义中.</li><li>thread_local 变量持续性与所属线程的持续性相同, 可与static, extern结合使用(其他声明中不能使用多个储存说明符)</li><li>mutable 使得const对象中的属性能被修改,而不受const限制</li><li>register C++11之前是寄存器变量,不能取地址;  之后是显式指明自动变量(无实际作用,避免旧代码非法)</li></ul><hr><h2 id="显式指出语言链接性以帮助链接程序寻找匹配函数"><a href="#显式指出语言链接性以帮助链接程序寻找匹配函数" class="headerlink" title="显式指出语言链接性以帮助链接程序寻找匹配函数:"></a>显式指出语言链接性以帮助链接程序寻找匹配函数:</h2><pre><code>extern &quot;C&quot; void spiff(int);</code></pre><hr><h2 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv-限定符"></a>cv-限定符</h2><pre><code>- const全局变量带有隐式static使得变量链接性为内部, 导致多文件同时include一个头文件时不会发生定义冲突 *可以使用extern覆盖隐式static使变量链接性为外部. 在其他单元中仍需用extern来引用它.*- volatile 提示编译器该变量会在程序之外被修改, 不要进行寄存器缓存优化. 多见于驱动程序.</code></pre><hr><h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><ul><li>原函数:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[] (std::size_T); <span class="comment">// new int[40] --&gt; new(40*sizeof(int))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="type">void</span> *);</span><br></pre></td></tr></table></figure></li><li>new, delete函数可以替换.</li><li>new在堆中查找满足要求的内存块</li><li>定位new运算符<ul><li><code>typename* p = new (MemAddress) typename</code></li><li>返回(void *)指定的内存地址</li><li>允许重载</li><li><strong>注意非堆内存不可delete</strong></li><li><strong>若内存中存放了对象，则需要手动调用析构函数，再由MemAddress释放内存，且需注意new []与delete []对应</strong></li></ul></li><li>元素的创建与销毁应遵循FILO顺序</li></ul><hr><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><ul><li>声明区域: 可以声明变量的区域, 例如所在的文件, 代码块.</li><li>潜在作用域: 从声明点开始到声明区域的结尾. 可能被局部变量隐藏,故称潜在.</li><li>自定义名称空间:<code>namespace Somewhat &#123;...&#125;</code><ul><li>只能在函数外部定义, 允许在另一个名称空间中嵌套</li><li>因此, 默认情况下声明的名称的链接性为外部(除非它引用了常量)</li><li>可以在其他合法位置继续添加名称, 提供定义.</li></ul></li><li><code>using namespace Somewhat;</code>编译指令<ul><li>每个声明区域中都有一条隐式的<code>using namespace 全局名称空间;</code></li><li>若某处使用过<code>using namespace</code>编译指令,则其子声明区域也隐式添加这条语句.</li><li>局部变量拥有最高优先权,能隐藏各种using namespace同名变量(因为名称空间都在函数外部定义)</li></ul></li><li><code>using</code>声明<ul><li>类似于声明了一个局部变量, 在代码块中不允许同级同名.</li><li>因此使用using声明比使用using编译指令更安全.</li></ul></li><li>名称空间可以拥有别名, 用于简化代码: namespace MEF &#x3D; myth::elements::fire;</li><li>名称空间可以匿名, 声明之后自动隐式using, 用于避免其他using并替代static全局变量.</li><li>&lt;.h&gt;文件是不支持名称空间的版本.新版一般将函数搬到std中.</li><li>使用建议: 在大型程序&#x2F;多单元程序使用<ul><li>少用<code>using namespace</code></li><li>避免在头文件中使用using编译指令,若必须使用,则在所有#include之后使用</li><li>避免直接声明外部全局变量和静态全局变量,改用已命名的名称空间</li><li>using声明首选用在局部而不是全局</li></ul></li></ul><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>构造函数<ul><li>调用示例:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Classname object; <span class="comment">// 调用空参数构造函数</span></span><br><span class="line"><span class="function">Classname <span class="title">object</span><span class="params">()</span></span>; <span class="comment">// 警告, 正在声明函数</span></span><br><span class="line"><span class="function">Classname <span class="title">object</span><span class="params">(one, two, ...)</span></span>; <span class="comment">// 调用对应的构造函数</span></span><br><span class="line">Classname object = <span class="built_in">Classname</span>(one, ...); <span class="comment">// 有可能先构造临时对象</span></span><br><span class="line">Classname* p = <span class="keyword">new</span> <span class="built_in">Classname</span>(...);</span><br><span class="line">Classname object&#123;...&#125;; Classname object = Classname&#123;...&#125;; <span class="comment">// C++11</span></span><br><span class="line">Classname* p = <span class="keyword">new</span> Classname&#123;&#125;; <span class="comment">// C++11</span></span><br><span class="line">Classname object = value; <span class="comment">// 调用一个参数的构造函数, 可用explicit(修饰构造函数)关闭这种特性</span></span><br></pre></td></tr></table></figure></li><li>重载构造函数中使用的new或new []必须对应，因为析构函数只有一个。</li><li>初始化列表<ul><li>参数列表后由冒号引出的初始化信息。在此初始化对象将使用复制构造函数，而不是空构造函数加赋值运算符，因此效率更高。</li><li>初始化的顺序按照成员变量的声明顺序，而与初始化列表顺序无关。</li><li>一旦进入花括号，成员变量将完成默认的初始化，对象初步创建完成。因此，成员变量中，非静态常量与引用必须由此列表进行初始化。</li><li>类内初始化可等价于默认的列表初始化。列表初始化会覆盖类内初始化。</li><li>初始化列表负责调用基类构造函数（基类已在派生类类域中，无需加作用域解析符）</li><li>初始化列表负责调用成员对象的非默认构造函数</li></ul></li><li>默认不能继承构造函数（C++11）</li></ul></li><li>析构函数<ul><li>只能有一个析构函数, 且参数必须为空</li><li>注意用delete对应构造函数或其他过程的new</li><li>若对象由定位new运算符创建，则需要手动调用析构函数，且遵循FILO顺序。</li><li>必须以delete或delete []对应构造函数中的new或new []。</li><li>最后会自动调用基类的析构函数</li><li>应当将析构函数声明为虚函数</li><li>不能继承析构函数</li></ul></li><li>封装是一个编译期的概念<ul><li>编译期不存在实例，编译器仅针对类型做检查</li><li>可以在类方法中访问同类对象的私有成员</li></ul></li><li><em>同struct</em> : 避免环形构造<ul><li>编译器禁用简单环形定义, 如 <code> struct A &#123; A a; &#125;; // 使用了未完成的定义</code></li><li>编译器不能辨别复杂环形定义, 如<code>struct A &#123; A()&#123;&#125; A* a = new A(); &#125;</code></li></ul></li><li>非静态变量在运行时才会创建, 所以如int arr[MAXN]的MAXN必须是静态量,可以是全局const, 类中static const, enum{MAXN&#x3D;x}.</li><li>友元函数<ul><li>在共有部分声明友元函数原型, 也可以紧接定义以设为内联函数.后置的定义无需friend修饰</li><li>友元函数视为类外函数, 但可以访问类私有成员变量.</li><li>类的显式二元重载运算符应当用友元, 尽管没有直接修改类私有成员变量</li><li>重载&lt;&lt; : <code>std::ostream&amp; operator &lt;&lt; (const std::ostream&amp; os, const Classname&amp; obj)</code>以方便输出.</li><li>友元函数可方便隐式类型转换, 不必苛求由对象发起函数调用.例如cmp(&quot;asd&quot;, obj),可以对应原型cmp(string, string);</li><li>可以在派生类友元函数中，强制向上转型并使用基类友元函<br>  数据类型, 否则易有二义性<br>  函数, 避免隐式转换出错<br>  ass_name&amp;)&#96;<br>  始化、按值传递、按值返回、上转型并使用基类友元函数。</li></ul></li><li>转换函数<code>operator typeName()</code><ul><li>用途:将类转换成基础数据类型</li><li>必须是成员方法</li><li>不能指定返回类型</li><li>不能有参数</li><li>用于cout时应显式标明类型</li><li>应当用explicit修饰</li></ul></li><li>复制构造函数<code>Class_name(const Class_name&amp;)</code><ul><li>在初始化对象时使用(显示的初始化、按值传递、按值返回、编译器生成临时对象)</li><li><strong>新版本C++可用移动构造函数</strong></li><li>例:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class_name <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">Class_name* pa = <span class="keyword">new</span> <span class="built_in">Class_name</span>(b);</span><br><span class="line">Class_name a = b; <span class="comment">// 可能生成临时对象后调用赋值运算符函数,根据实现而异.</span></span><br><span class="line">Class_name a = <span class="built_in">Class_name</span>(b); <span class="comment">// 同上</span></span><br><span class="line">按值传递函数调用<span class="built_in">func</span>(b); <span class="comment">// 按值传递也初始化了参数</span></span><br></pre></td></tr></table></figure></li><li>默认的复制构造函数，是在初始化列表中调用所有成员的复制构造函数。默认复制派生类对象的基类部分</li><li>应注意<strong>深度复制</strong>, 即妥善处理指针所指向内容的复制</li></ul></li><li>赋值运算符函数<ul><li>考虑妥善处理原来已有的,即将被抛弃的数据.</li><li>考虑自己赋值给自己的情况, 小心赋值前删除了自身数据.</li><li>记住返回自身引用, 即 <code>return *this</code></li><li>不能继承赋值运算符函数</li><li>不建议设置为虚方法，为了避免同基类的不同派生类互相赋值</li></ul></li><li>默认方法的潜在危险<ul><li>某个类在开发初期不需要复制构造函数&#x2F;赋值运算符重载，但在以后可能需要</li><li>可能写出符合常理的代码，但由于未覆盖默认方法而运行时异常</li><li>可能在未察觉的情况下调用了默认方法（用重载加法时按值传递、按值返回将调用复制构造函数）</li><li>解决办法：<ul><li>不管默认方法是否需要，总是提供正确的代码</li><li>将空方法设为private，并留下错误信息</li><li>使用delete（C++11）</li></ul></li></ul></li><li><code>[ ]</code>(取位)运算符: 两个操作数分立于左中括号两侧。只能是成员函数。</li><li>const对象<ul><li>只能使用const函数, 若返回引用, 则返回类型为const type&amp;</li></ul></li><li>静态类成员函数<ul><li>原型含static, 定义不含</li><li>和Java不同, 不能通过对象来调用静态成员函数</li><li>调用格式 <code>Class_name::s_method();</code></li></ul></li><li>静态类成员变量<ul><li>在类中声明, 不可定义</li><li>在类外定义并分配内存, 可以不初始化</li><li>静态常量在声明同时定义.</li></ul></li><li>派生&#x2F;继承<ul><li><code>class newClass : public baseClase</code></li><li>默认继承为private继承。私有继承的向上转型必须显式写出</li><li>多重继承的向上转型也应显示写出，以防不同基类的方法冲突</li><li>派生类中一旦定义某方法与基类方法同名，则基类所有该名方法被隐藏。与参数列表（特征标）无关。<ul><li>可用基类名::方法名的途径调用隐藏的方法</li><li>重新定义继承的方法，应确保与原来的原型完全相同</li><li>若返回类型为基类引用或指针，则可以修改为派生类的引用或指针（返回类型协变）</li><li>若基类虚方法被重载了，则应在派生类中重新定义所有的基类版本</li></ul></li><li>若派生类构造函数使用了new，则应提供复制构造函数&#x2F;赋值运算符（含<code>base::operator=(o);</code>）&#x2F;虚析构函数的定义</li><li>公有继承表达了is-a关系，私有继承&#x2F;包含表达了has-a关系。通常使用组合包含层次化来建立has-a关系。如果需要访问原有类的保护成员或重新定义虚方法，才使用私有继承。</li><li>欲调用基类对象，对(*this)强制向上转型(const Base &amp;)即可</li><li>用using改变继承成员权限：在派生类的public处<code>using Base::methodName;</code>(省略using的技术是即将被抛弃的旧技术)</li></ul></li><li>虚方法<ul><li>若希望通过基类引用或指针调用派生类方法，则需要将基类方法声明为virtual虚方法（一般也将派生类方法声明为virtual）</li><li>应当将析构函数定义为虚方法，以确保正确地销毁对象</li><li>在类中欲调用基类方法(而不是本类方法)，需使用作用域解析符<code>Base::baseMethod();</code></li><li>编译器对虚方法的一般实现：把类的所有虚函数的地址制作成表，在对象中添加隐藏的虚函数表指针，在运行时通过指针检索虚函数。</li><li>与Java不同，派生类虚方法的访问权限允许变严格，但由基类引用或指针的多态效果仍然生效。</li><li>派生类中一旦定义虚方法，就将隐藏基类所有同名方法，故应在派生类中重新定义所有的基类重载方法</li><li>可以令虚方法声明结尾处为<code>=0</code>，使方法成为纯虚方法。纯虚方法可以不提供定义。含有至少一个纯虚方法的类为抽象类，不能声明对象。</li></ul></li><li>访问权限<ul><li>private：仅本类和友元函数有权访问。对数据成员的理想访问控制。</li><li>protected：本类和派生类有权访问。在派生链中，此权限类似public；在类外部，此权限类似peivate。此权限通常只给成员函数。</li><li>public：在同一域中就能访问。</li></ul></li><li>引用限定成员函数<ul><li>函数签名的最后可以标注<code>&amp;</code>或<code>&amp;&amp;</code>来做「引用限定 ref-qualified」。<ol><li>非限定成员函数可由左值调用，也可由右值调用。此时不能再定义引用限定成员函数。</li><li>左值限定成员函数仅可由左值调用。</li><li>右值限定成员函数仅可由右值调用。</li></ol></li></ul></li></ul><hr><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda是一种匿名函数，它在普通函数的基础上增加了一些功能。Lambda是通过函数对象实现的，具有在编译器内联的能力，因此性能可以比函数指针更好。</p><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> q, <span class="type">int</span> p) &#123; <span class="keyword">return</span> q &gt; p; &#125; <span class="comment">// 常见的比较函数</span></span><br><span class="line">[mask](<span class="type">int</span> x) &#123; <span class="keyword">return</span> mask &amp; x; &#125; <span class="comment">// 判断有无交集</span></span><br><span class="line">[&amp;flag](<span class="type">int</span> x) &#123; flag[x] = <span class="literal">true</span>; &#125; <span class="comment">// 修改自动变量flag数组</span></span><br><span class="line">[&amp;](<span class="type">int</span> x)-&gt;<span class="type">int</span> &#123;   <span class="comment">// 按引用捕获当前作用域的全部自动变量。不是简单地return故要声明类型</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; mx) mx = x;</span><br><span class="line">    <span class="keyword">return</span> tot += x;</span><br><span class="line">&#125;</span><br><span class="line">[k, &amp;](<span class="type">int</span> del) &#123;  <span class="comment">// 按值捕获k、按引用捕获其他变量</span></span><br><span class="line">    sth += del;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl; <span class="comment">// k是只读的？？！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>rvalue,（非严格定义: ）匿名的临时值，常出现在等号的右方。最大特征是不可取地址，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// (2+3) 就是一个右值， &amp;(2+3)没有意义</span></span><br></pre></td></tr></table></figure><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>有时候运算过程中会生成一些体积大的临时对象，在完成表达式后这些临时对象会析构，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">  <span class="type">char</span>* data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//... 使用new和delete的模仿string类，具有拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;MyString&gt; arr; arr.<span class="built_in">reverse</span>(<span class="number">10</span>); <span class="comment">// 保留10个string的空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  arr.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">&quot;Hello_rvalue&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第8行发生如下事件：</p><ol><li>MyString(&quot;Hello_rvalue&quot;) 产生一个右值。</li><li>push_back接收一个右值参数，并调用MyString的<strong>拷贝构造函数</strong>新建一个对象。</li><li>MyString(&quot;Hello_rvalue&quot;)生命周期结束，析构。</li></ol><p>发现拷贝构造函数存在资源浪费：既然右值的资源已经没有后续价值，大可以将其资源“偷”过来使用。</p><p>于是，MyString类新增<strong>移动构造函数</strong>（还有<strong>移动赋值函数</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">  <span class="comment">// ... 同上</span></span><br><span class="line">  <span class="built_in">MyString</span>(MyString&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = x-&gt;data;</span><br><span class="line">    x-&gt;data = <span class="literal">nullptr</span>; <span class="comment">// 资源被偷走</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; x) &#123;</span><br><span class="line">    <span class="comment">// 类似移动构造函数，不赘述</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此一来，push_back将自动调用移动构造函数来创建对象，避免大量new内存。</p><p>右值引用的存在，就是为了<strong>尽量榨干临时对象的价值</strong>。</p><p>要利用右值引用，最重要的是<strong>合理地定义移动构造和移动赋值</strong>。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>有时候一些左值就像右值一样即将消亡，弃之可惜，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="function">string <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">tmp += <span class="string">&quot; rvalue?&quot;</span>; <span class="comment">// tmp经过一系列复杂的处理</span></span><br><span class="line">  arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能像右值引用一般把tmp的资源“偷”走就好了，于是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="function">string <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">tmp += <span class="string">&quot; rvalue?&quot;</span>; <span class="comment">// tmp经过一系列复杂的处理</span></span><br><span class="line">  arr.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp)); <span class="comment">// 强制转换为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，move(tmp)后由于资源已经被偷走，tmp可能像野指针一样危险。被move后对象的行为由程序员负责。</p><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是针对c++模板函数的概念。</p><p>我们不得不先介绍c++引用折叠概念：</p><table><thead><tr><th>typename T</th><th>T&amp;</th><th>T&amp;&amp;</th></tr></thead><tbody><tr><td>G</td><td>G&amp;</td><td>G&amp;&amp;</td></tr><tr><td>G&amp;</td><td>G&amp;</td><td><strong>G&amp;</strong></td></tr><tr><td>G&amp;&amp;</td><td><strong>G&amp;</strong></td><td>G&amp;&amp;</td></tr></tbody></table><p>模板函数的右值引用具有欺骗性！在模板实例化时，<code>T&amp; &amp;&amp;</code> 和<code>T&amp;&amp; &amp;</code>都会被转换为<code>T&amp;</code>。只有<code>T&amp;&amp; &amp;&amp;</code>会成为<code>T&amp;&amp;</code>。利用这一点，我们可只定义<code>T&amp;&amp;</code>的函数行为。</p><p><em>（对于简单的情况，<code>T &amp;&amp;</code> 等价于 <code>T&amp;&amp; </code>）</em></p><p>但此时也出现了另一个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;&amp; x1)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp;&amp; x2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望，若f1接收左值，那么f2也应该接收左值；如果f1接收右值，那么f2也应该接收右值。但c++规定，“右值引用”是一个左值，因为它有名字，还可以取地址。在这里，f2无论如何都会接收左值。怎样才能写出自动接收左右值的模板函数呢？</p><p>利用<strong>任意表达式都能生成匿名值</strong>，最简单的，就像<code>static_cast&lt;T&amp;&amp;&gt;(x1)</code>，此时表达式的结果可以转化为右值。再加上引用折叠的特性，就是<code>std::forward</code>的基本原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T可以是scalar,object,lref。 但不可能是rref！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;&amp; x1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现了左值转发为左值，右值转发为右值。</span></span><br><span class="line">  <span class="built_in">f2</span>(std::forward&lt;T&gt;(x1)); <span class="comment">// 不能依赖C++17的自动推导，因为x1总是lref！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附：std的实现</span></span><br><span class="line"><span class="comment">// FUNCTION TEMPLATE forward</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an lvalue as either an lvalue or an rvalue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg); <span class="comment">// 注意这里可能发生引用折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FUNCTION TEMPLATE move</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg); <span class="comment">// 注意这里不可能发生引用折叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>捕获异常时，从具体到抽象，最后到<code>...</code>。</li><li>如果异常携带字符串信息，则可能引发<code>std::bad_alloc</code>，惊不惊喜！</li><li>std定义的异常分类：<code>#include &lt;stdexcept&gt;</code>  <ol><li><code>logic_error</code> 逻辑出错。</li><li><code>invalid_argument</code> 无效参数。</li><li><code>domain_error</code> 值域错误。（继承自<code>logic_error</code>）</li><li><code>length_error</code> 试图超越最大体积。（继承自<code>logic_error</code>）</li><li><code>out_of_range</code> 试图越界。（继承自<code>logic_error</code>）</li><li><code>runtime_error</code> 仅在运行时可知的错误。</li><li><code>range_error</code> 计算结果无法用目标类型表示。（继承自<code>runtime_error</code>）</li><li><code>overflow_error</code> 算术上溢。（继承自<code>runtime_error</code>）</li><li><code>underflow_error</code> 算术下溢。（继承自<code>runtime_error</code>）</li><li><code>tx_exception</code> 可用于回滚或取消transaction的异常。（Transactional Memory Technical Specification, TM TS）</li></ol></li></ul><hr><h2 id="constexpr-if"><a href="#constexpr-if" class="headerlink" title="constexpr if"></a>constexpr if</h2><p>使用 <code>if constexpr</code>，将在编译期计算分支选择</p><p>常常配合 <code>&lt;type_traits&gt;</code> 或变参模板使用。</p><ol><li>条件必须能在编译期计算，并转换为 <code>bool</code>。</li><li>被抛弃的分支：<ol><li>不参与函数返回值类型推导</li><li>可以使用有声明但没有定义的变量（不属于 ORD-use）</li></ol></li><li>在一个<a href="https://en.cppreference.com/w/cpp/language/templates#Templated_entity">模板实体</a>中，被抛弃的分支不引起后续的实例化。常用于 <code>if constexpr (sizeof...(rs) &gt; 0) &#123; f(rs...) &#125;</code></li><li>在一个非模板实体中，被抛弃的分支依然参与语义分析（例如你不能使用一个未声明的变量）。所以 <code>if constexpr</code> 不能替代 <code>#if</code></li><li>任何时候，被抛弃的分支都不允许 ill-formed（例如 <code>static_assert(false,&quot;&quot;)</code>）。你可能需要 Concept。</li></ol><hr><h2 id="StandardLayout"><a href="#StandardLayout" class="headerlink" title="StandardLayout"></a>StandardLayout</h2><p><em><a href="https://en.cppreference.com/w/cpp/language/data_members#Standard_layout">StandardLayout</a></em> 的前身是 <em>POD</em>。为了内存对齐，各路厂商的编译器会对结构体的数据成员进行偏移量编排。如果需要字节级粒度的操作（常见于网络），我们需要弄清楚结构体内部的具体布局。</p><h3 id="结构体布局"><a href="#结构体布局" class="headerlink" title="结构体布局"></a>结构体布局</h3><p>C++标准 对结构体布局仅做了很有限的规定：</p><ol><li>同一访问权限的字段的相对顺序与定义相对顺序相同：先定义的在低地址，后定义的在高地址。</li><li>不同访问权限的字段的相对顺序是未指定的。</li><li>为了内存对齐，允许编译器在字段之间、结构体的末尾添加空字节。</li></ol><h3 id="标准局部（原-POD）"><a href="#标准局部（原-POD）" class="headerlink" title="标准局部（原 POD）"></a>标准局部（原 POD）</h3><ul><li>C++11 以前，<em>PODType</em> 等价于 <em>StandardLayoutType</em></li><li>C++11 开始，<em>StandardLayoutType</em> 要求类满足以下条件：<ol><li>所有非静态数据成员具有同一个访问权限。</li><li>没有虚函数，没有虚基类。</li><li>任何非静态数据成员都不是引用类型。</li><li>所有非静态数据成员和基类都是 standard layout。</li><li>不存在菱形继承。</li><li><strong>bit-fields（位域）和所有非静态数据成员在同一个类内定义。</strong></li><li>其他复杂的条件（参考 cppref）</li></ol></li></ul><p><em>StandardLayout（标准布局）</em> 是 C++ 标准提出的概念，但没做具体布局。</p><p>常见的实现遵循以下原则，可以帮助我们肉眼判断 size 和 alignment：</p><ol><li>结构体自身对齐到最宽的<strong>基础类型</strong>数据成员。（嵌套 struct 的情况下要展开判断）</li><li>结构体内<strong>基础类型</strong>字段对齐到自身大小，<strong>子 struct</strong> 则按照上一条对齐。（在字段之间 padding）</li><li>结构体的 size 必须是对齐字节的整数倍。（在结构体末尾 padding）</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    size = 8</span></span><br><span class="line"><span class="comment">    alignment = 4</span></span><br><span class="line"><span class="comment">    |a___|bbbb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    size = 16</span></span><br><span class="line"><span class="comment">    alignment = 4</span></span><br><span class="line"><span class="comment">    |c___|a___|bbbb|d___</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    A obj; <span class="comment">// obj 要对齐到 4 字节，char c 和 char a 不能紧贴相邻</span></span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否标准布局</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line">std::is_standard_layout&lt;B&gt;::value;</span><br></pre></td></tr></table></figure><hr><h2 id="bit-field"><a href="#bit-field" class="headerlink" title="bit field"></a>bit field</h2><p>bit field（位域）是一种<strong>语法糖</strong>。它用于极致紧凑地在内存中排列结构体内容，但是需要额外位操作指令。</p><p>这里介绍位域的实现原理。</p><ul><li>C++ 标准没有规定位域应该如何实现，所以，使用位域的 C++ 程序本质上是<strong>不可移植</strong>的。</li><li>要考虑字节<strong>内外部</strong>的大小端问题。通常内外部的大小端保持一致，如 x86 就是不同字节小端在前（低地址），同一字节内小端在前（低编号）。</li><li>编译器会额外添加位操作指令（如 <code>shl</code>, <code>shr</code>, <code>sar</code>, <code>or</code> 等）来保证读写位域的语义正确性。</li><li>位域的类型决定了对齐边界。例如 <code>int x : 17</code> 会保证 <code>x</code> 不会越过 4 字节的对齐边界。</li><li>相邻的位域，如果对齐长度相同，编译器会尽量将他们装在一起，如果装得下的话。</li><li>可以使用匿名位域做人工 padding。长度为 0 的匿名位域会强制下一个位域重新开始对齐。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文始于 2018&amp;#x2F;6&amp;#x2F;27，用于汇聚关于 C++ 的实用知识和碰到的坑，温故而知新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2022&amp;#x2F;1&amp;#x2F;2 【更改】标题改为《C++ 标准笔记》&lt;br&gt;2022&amp;#x2F;1&amp;#x2F;2 【新增】StandardLayout&lt;br&gt;2022&amp;#x2F;1&amp;#x2F;2 【新增】bit field&lt;/p&gt;
&lt;p&gt;更新预告：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CRTP 原理，目的和应用&lt;/li&gt;
&lt;li&gt;CRTP 应用之表达式模板&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="语法" scheme="https://codesire-deng.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency With C++</title>
    <link href="https://codesire-deng.github.io/2021/04/01/Concurrency-with-C/"/>
    <id>https://codesire-deng.github.io/2021/04/01/Concurrency-with-C/</id>
    <published>2021-04-01T02:47:34.000Z</published>
    <updated>2022-03-06T09:45:13.756Z</updated>
    
    <content type="html"><![CDATA[<p>不同语言&#x2F;操作系统&#x2F;硬件的线程实现还不一样，因此学一个比较主流的多线程库还是挺重要的。<br>C++ STL的线程支持库就是一个好例子。在这之前，最好先复习一下基础知识。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><strong>不变量(invariants)</strong> 是指对数据结构的断言<ul><li>例：某种帐本，任意前缀和不为负数。</li><li>例：链表某个节点的后继的前驱是自己。</li><li>众所周知，不良的并发编程会破坏不变量！</li><li>破坏不变量的根源是写操作。<span id="more"></span></li></ul></li><li>在并发中的<strong>竞争条件(race condition)</strong> 是指，任何结果依赖于在两个或多个线程上操作执行的相对顺序。<ul><li>有问题的竞争条件会破坏不变量，引发Bug。</li><li>Debug模式下可能无法发现有问题的竞争条件。</li><li>下文的竞争条件默认是有问题的。</li><li>在类内部使用互斥锁<em>不能</em>完全消除竞争条件。<ul><li>例：<code>return &amp;locked_data;</code> 泄露指针或引用，使得数据离开内部锁的保护！</li><li>例：<code>template&lt;typename F&gt; ... F(&amp;locked_data);</code> 可能已经泄露了指针或引用！</li><li>例：<code>if (!s.empty()) s.pop();</code> 很可能引发一次不安全的pop！</li><li>例：<code>tmp = s.top(); s.pop(); return tmp;</code> 在return时发生构造函数异常，数据丢失！</li><li>解决办法：<ol><li>传入引用或指针来接收返回值。缺点：一些类不支持赋值。</li><li>要求拷贝&#x2F;移动构造函数不抛出异常。缺点：用户说我偏不。</li><li>返回指向原返回值的指针，最好配合shared_ptr。缺点：性能损耗。</li><li>1+2 或者 1+3。</li></ol></li></ul></li></ul></li><li><strong>死锁</strong><ul><li>四要素：互斥，持有并等待，非抢占，循环等待。</li><li>解决办法：破坏四要素中任意一个<ol><li>保证上锁的顺序是唯一的。</li><li>使用<code>std::lock()</code>。</li></ol></li></ul></li><li><strong>锁的粒度</strong>是指单个锁保护的数据量和保护时间。<ul><li>挑选合适的数据量大小。</li><li>在耗时的操作中尽可能地释放锁，例如I&#x2F;O操作。</li></ul></li><li><strong>懒汉模式</strong>特指单例模式中的延迟初始化。<ul><li>裸懒汉模式显然是线程不安全的。</li><li>双重检查加锁也充满了陷阱，因为最外层的检查可能是错误的（赋好了指针，但未彻底完成初始化）！</li><li>理想的解决方法是保证标志位是最后初始化的（要防止编译器乱序优化），而不要将指针看作标志位。</li><li>使用<code>std::call_once</code>！</li><li>还可以利用C++的static局部变量实现懒汉模式。C++11标准保证这是线程安全的！</li></ul></li><li><strong>读写锁</strong>是指共享锁。<ul><li>用于很少更新的数据结构。</li><li>C++11啥也没有。</li><li>C++14新增<code>shared_timed_mutex</code>。</li><li>C++17新增<code>shared_mutex</code>，性能更好，好耶！</li><li>推荐将<code>shared_mutex</code>声明为<code>mutable</code>。</li><li>当心读者太多，写者饿死！</li></ul></li><li><strong>递归锁</strong>允许一个线程多次上锁，但必须进行相同次数的释放锁。<ul><li>例：<code>A.a()</code>需要锁，<code>A.b()</code>也需要锁，而且<code>A.a()</code>需要调用<code>A.b()</code>。</li><li>不建议这样用，因为<code>A.b()</code>可能要面对错误的数据。</li><li>建议抽出<code>A.a()</code>和<code>A.b()</code>的公共部分，成为一个新的私有函数，且不上锁（因为已经上了锁）。</li></ul></li></ul><hr><h2 id="C-Library"><a href="#C-Library" class="headerlink" title="C++ Library"></a>C++ Library</h2><h3 id="Thread-线程"><a href="#Thread-线程" class="headerlink" title="Thread 线程"></a>Thread 线程</h3><p><a href="https://en.cppreference.com/w/cpp/thread">cppreference thread</a></p><p><code>#include &lt;thread&gt;</code></p><p>起一个线程！</p><ul><li><code>thread</code> 类<ul><li>默认构造不代表任何线程</li><li>可移动，不可复制</li><li>构造函数完成后立即就绪</li><li>若子线程抛出异常，则调用<code>std::terminate</code>中止进程</li><li>使用<code>thread_local</code>关键字，令变量的生命周期和所属线程相同</li><li><code>join()</code> 调用者等待，直到线程执行完毕</li><li><code>detach()</code> 分离线程和线程对象，此时可以安全地销毁线程对象。</li><li><code>joinable()</code> 是否可以使用<code>join()</code>。正在运行中、未分离的线程都是 joinable.</li><li><code>thread::hardware_concurrency()</code> 获取线程数参考值。</li></ul></li><li><code>this_thread</code> 命名空间<ul><li><code>yield()</code> 建议当前线程进入就绪状态</li><li><code>get_id()</code> 获取线程id。结果可用<code>&lt;&lt;</code>序列化，虽然意义不大。</li><li><code>sleep_for(duration)</code>&#x2F;<code>sleep_until(time_point)</code> 当前线程阻塞一段时间</li></ul></li></ul><hr><p>提到多线程，几乎避不开互斥、同步等概念。</p><h3 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h3><p><a href="https://en.cppreference.com/w/cpp/header/mutex">cppreference mutex</a></p><p><code>#include &lt;mutex&gt;</code></p><p>主要用于保护<strong>数据</strong>的操作原子性。</p><p>若多个线程请求同一个锁，而此锁尚未被释放，则当锁释放时，其中一个线程获得锁（退出阻塞），其余线程维持阻塞。</p><ul><li><code>mutex</code> 类<ul><li><code>lock()</code> 阻塞，直到获得锁</li><li><code>unlock()</code></li><li><code>try_lock()</code> 若无法获得锁，则返回 false 但不阻塞</li><li>小心<code>mutex</code>的生命周期。销毁一个被其他线程持有的锁是后果无定义的。</li><li>销毁线程前应当释放锁，否则后果无定义。</li><li>不可拷贝，不可移动</li><li>同一线程不可对同一<code>mutex</code>多次上锁，这样做的后果是无定义的。</li></ul></li><li><code>recursive_mutex</code> 类<ul><li>同一线程可以多次上锁。上锁和解锁应一一对应。</li><li>例如<code>std::lock_guard&lt;std::recursive_mutex&gt; lk(m);</code></li></ul></li><li><code>timed_mutex</code> 类<ul><li><code>try_lock_for(timeout_duration)</code> 最多等待一段时间，无法获得锁则返回 false</li><li><code>try_lock_until(timeout_time)</code> 最多等待至一个时间点，无法获得锁则返回 false</li></ul></li><li><code>recursive_timed_mutex</code> 类<ul><li>混合了两者的功能</li></ul></li><li><code>void lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn)</code> 全局函数<ul><li>安全地“同时”请求多个互斥锁</li><li>保证不会引发死锁</li></ul></li><li><code>lock_guard</code> 类<ul><li>RAII 请求和释放一个锁</li><li>必须拥有一个锁</li><li><code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>假定已经获得了锁</li></ul></li><li><code>scoped_lock</code> 类<ul><li>RAII 同时请求和释放多个锁</li><li>保证不会引发死锁</li></ul></li><li><code>unique_lock</code> 类<ul><li>RAII 独占锁</li><li>可以主动解锁。常见于条件变量。暂时或提前释放锁通常可提高时间性能。</li><li>可以不拥有锁，因此有空间和性能损耗。常见于需要延迟上锁或转移所有权。</li><li>adopt_lock假定已经获得了锁，defer_lock假定延迟获得锁。</li><li>若延迟上锁，随后可用<code>std::lock(unique_lock, ...)</code>上锁。</li></ul></li><li><code>shared_lock</code> 类<ul><li>RAII 共享锁</li></ul></li><li><code>void call_once( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args );</code> 函数<ul><li>全局仅执行函数<code>f(args)</code>一次</li><li>若<code>flag</code>是复位，则允许执行<code>f(args)</code></li><li>支持多线程并发</li><li>若<code>f(args)</code>正常结束，则<code>flag</code>置位，防止第二次调用</li><li>若<code>f(args)</code>抛出未处理的异常，则<code>flag</code>保持复位，允许第二次调用</li><li>一个<code>flag</code>可以对应多个<code>f</code>，不保证哪个函数先执行。</li></ul></li></ul><h3 id="Condition-Variable-条件变量"><a href="#Condition-Variable-条件变量" class="headerlink" title="Condition Variable 条件变量"></a>Condition Variable 条件变量</h3><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference condition_variable</a></p><p>条件变量可以用来阻塞一个或多个线程，直到某个活动线程修改一个共享变量（即条件），并通知条件变量。</p><ol><li>为了保护上述共享变量，需要上互斥锁。</li><li>对比互斥锁的优势是：避免定时，定向唤醒，占用资源低，事件驱动。</li><li>被唤醒的线程需要手动或自动地检查条件，若条件失败，则再次被阻塞，等待被唤醒。</li></ol><p><code>#include &lt;condition_variable&gt;</code></p><ul><li><code>condition_variable</code>类<ul><li>只有默认构造函数</li><li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock );</code> <ul><li>释放锁，然后进入阻塞，直到被唤醒。</li><li>被唤醒后，先获得锁。</li></ul></li><li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred );</code> <ul><li>释放锁，然后进入阻塞，直到被唤醒。</li><li>被唤醒后，先获得锁</li><li>只要<code>pred</code>不满足，就会再次释放锁然后阻塞。</li><li>避免在<code>pred</code>里加副作用，因为无法确定它会执行多少次。</li></ul></li><li><code>notify_one()</code>&#x2F;<code>notify_all()</code> <ul><li>唤醒关联的阻塞线程。</li><li>当前线程应当事先释放锁（lock_guard应已析构）。</li></ul></li><li><code>void notify_all_at_thread_exit( std::condition_variable&amp; cond, std::unique_lock&lt;std::mutex&gt; lk );</code> <ul><li>全局函数。 </li><li>线程退出时（所有thread_local被销毁后），释放锁，然后唤醒全部。</li></ul></li></ul></li></ul><hr><h3 id="Future-amp-Async-未来与异步"><a href="#Future-amp-Async-未来与异步" class="headerlink" title="Future &amp; Async 未来与异步"></a>Future &amp; Async 未来与异步</h3><p><a href="https://en.cppreference.com/w/cpp/header/future">cppreference future</a></p><p>有时候，起一个线程仅仅是为了一次返回值。thread不能提供返回值，条件变量又太重量级了，你需要使用<code>async</code>。</p><p><code>async</code>可以轻量级地开启一个带返回值的线程，通常短期内你用不到返回值。一段时间后，你需要返回值了，才阻塞自己，直到返回值就绪。需要花费一段时间才能就绪的返回值就是<code>future</code>。</p><p><code>async</code>也允许你推迟执行，这意味着没有新线程，而是同步地执行。</p><ul><li><code>async</code>函数<ul><li>可接受<code>std::launch policy</code>为第一个参数，允许的值有：<ul><li><code>std::launch::async</code> 开启新线程，异步执行。</li><li><code>std::launch::deferred</code> 没有新线程，懒惰同步执行。</li><li><code>launch::async|launch::deferred</code> 默认值，由实现选择策略。</li><li>C++标准允许实现采用不同的默认策略，甚至允许新增策略。</li></ul></li><li><code>async</code>返回一个<code>future</code></li></ul></li><li><code>future&lt;&gt;</code>类<ul><li>表示一个值，这个值可能正在计算中，可能就绪，也可能是抛出的异常。</li><li><code>get()</code>成员函数。 保证返回就绪的值或者抛出异常。（若未就绪，则当前线程阻塞）。此函数只能调用一次，然后将<code>valid()</code>设置为false。</li><li><code>valid()</code>成员函数。 检查下一次<code>get()</code>的合法性，即有没有共享状态。</li><li><code>wait()</code>成员函数。 保证值就绪或者抛出异常。（若未就绪，则阻塞）</li><li><code>wait_for</code>, <code>wait_until</code>成员函数。有限等待。</li><li><code>share()</code>成员函数。移动自己，构造一个<code>shared_future&lt;&gt;</code>。</li><li>可移动，不可复制。</li></ul></li><li><code>shared_future&lt;&gt;</code>类<ul><li>与<code>future&lt;&gt;</code>类似，但可以<code>get()</code>多次。</li><li>可移动也可以复制。</li><li>正确的用法就是每个线程持有一份复制。</li></ul></li><li><code>packaged_task&lt;Callable&gt;</code>类<ul><li>将future绑定到函数（或可调用对象），方便自定义调度。</li><li>构造器仅接受函数（可以是lambda！），不绑定参数。只有在<code>operator ()</code>时才传入参数。</li><li>packaged_task本身也是一个可调用对象！可以用它起一个新线程。<code>thread(move(task), args...)</code></li><li>可移动，不可复制。</li><li><code>get_future()</code> 获取绑定的future。</li><li><code>operator(args...)</code> 立即在当前线程执行，然后future就绪，意味着唤醒等待此future的线程。</li><li><code>make_ready_at_thread_exit(args...)</code> 立即在当前线程执行，但是future不就绪。当线程退出且所有thread_local对象销毁后，future才就绪。</li><li><code>reset()</code> 重新构造自己。旧版的future作废。</li></ul></li><li><code>promise&lt;&gt;</code>类<ul><li>比async提供更强的自由度，可以手动设置future！如此可以在设置future后继续清理工作。</li><li>可移动，不可复制。</li><li>一般先<code>get_future()</code>留下接口，然后move<code>promise</code>到别的线程，在别的线程<code>set_value</code>。</li><li><code>set_value(value)</code> 设置关联的future的值，唤醒在等待的线程。</li><li><code>set_value_at_thread_exit(value)</code> 类似<code>set_value</code>，但当前线程退出后，才唤醒在等待的线程。</li><li><code>void set_exception( std::exception_ptr p )</code> 令future的<code>get()</code>抛出异常。<ul><li>在try-catch块中，配合<code>std::current_exception()</code>使用</li><li>不用try-catch，性能更高，配合<code>make_exception_ptr(E e)</code>用。</li></ul></li><li><code>set_exception_at_thread_exit</code> 同理。</li></ul></li></ul><h2 id="内存模型和原子操作"><a href="#内存模型和原子操作" class="headerlink" title="内存模型和原子操作"></a>内存模型和原子操作</h2><h2 id="设计无锁数据结构"><a href="#设计无锁数据结构" class="headerlink" title="设计无锁数据结构"></a>设计无锁数据结构</h2><ul><li>无锁数据结构应如何设计？</li><li>无锁数据结构的内存管理有何难题？</li><li>更多的建议？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同语言&amp;#x2F;操作系统&amp;#x2F;硬件的线程实现还不一样，因此学一个比较主流的多线程库还是挺重要的。&lt;br&gt;C++ STL的线程支持库就是一个好例子。在这之前，最好先复习一下基础知识。&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不变量(invariants)&lt;/strong&gt; 是指对数据结构的断言&lt;ul&gt;
&lt;li&gt;例：某种帐本，任意前缀和不为负数。&lt;/li&gt;
&lt;li&gt;例：链表某个节点的后继的前驱是自己。&lt;/li&gt;
&lt;li&gt;众所周知，不良的并发编程会破坏不变量！&lt;/li&gt;
&lt;li&gt;破坏不变量的根源是写操作。</summary>
    
    
    
    
    <category term="C++" scheme="https://codesire-deng.github.io/tags/C/"/>
    
    <category term="Concurrency" scheme="https://codesire-deng.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Hexo &amp; NexT 更新方式</title>
    <link href="https://codesire-deng.github.io/2021/04/01/Hexo-NexT-%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://codesire-deng.github.io/2021/04/01/Hexo-NexT-%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2021-04-01T02:36:50.000Z</published>
    <updated>2021-04-01T02:43:59.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g cnpm                 <span class="comment"># 升级 npm</span></span><br><span class="line">cnpm cache clean -f                 <span class="comment"># 清除 npm 缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 package.json 中的 hexo 及个插件版本</span></span><br><span class="line">cnpm install -g npm-check           <span class="comment"># 检查之前安装的插件，都有哪些是可以升级的 </span></span><br><span class="line">cnpm install -g npm-upgrade         <span class="comment"># 升级系统中的插件</span></span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">cnpm update</span><br><span class="line"></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h3 id="更新NexT"><a href="#更新NexT" class="headerlink" title="更新NexT"></a>更新NexT</h3><ol><li>重命名原有的主题文件（夹）</li><li><code>npm install hexo-theme-next@latest</code></li><li>diff配合肉眼更新配置</li><li>参考<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">官方文档</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;更新Hexo&quot;&gt;&lt;a href=&quot;#更新Hexo&quot; class=&quot;headerlink&quot; title=&quot;更新Hexo&quot;&gt;&lt;/a&gt;更新Hexo&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    
    <category term="减少脱发指南" scheme="https://codesire-deng.github.io/tags/%E5%87%8F%E5%B0%91%E8%84%B1%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>SAM实战剖析</title>
    <link href="https://codesire-deng.github.io/2020/10/11/SAM%E5%AE%9E%E6%88%98/"/>
    <id>https://codesire-deng.github.io/2020/10/11/SAM%E5%AE%9E%E6%88%98/</id>
    <published>2020-10-11T09:04:59.000Z</published>
    <updated>2022-10-13T07:17:10.984Z</updated>
    
    <content type="html"><![CDATA[<ul><li><em>实战不会SAM？导致比赛打铁？快 点 学 ！</em></li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机 Suffix Automaton">后缀自动机(Suffix-Automaton)</a><span id="more"></span><h1 id="在自动机上游走"><a href="#在自动机上游走" class="headerlink" title="在自动机上游走"></a>在自动机上游走</h1><p>从$root$开始，沿目标字符串逐个字符走。若路径存在，即当前子串存在；反之，若出边不存在，即目标子串不存在。</p><h2 id="求最小表示"><a href="#求最小表示" class="headerlink" title="求最小表示"></a>求最小表示</h2><p>求字符串$S$的最小表示。</p><p><em>度娘有$O(n)$的特殊做法，此处不赘述。</em></p><p>构造字符串$SS$的后缀自动机，从$root$开始，每次沿最小的出边走，走n步就得到了$SS$中长度为n的最小子串，即$S$的最小表示。</p><h2 id="求本质不同的第k小子串"><a href="#求本质不同的第k小子串" class="headerlink" title="求本质不同的第k小子串"></a>求本质不同的第k小子串</h2><p><a href="https://www.spoj.com/problems/SUBLEX/">SPOJ SUBLEX</a> 题意：求字符串$S$的所有本质不同子串中的第$k$小。$length(S)\le 9e4, 询问数量\le 500$。</p><p>SAM构造完成后得到一个DAG，利用拓扑序求从每个点出发可能的路径数目。见<a href="#SAM%E4%B8%8A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序的方法</a>。最后用类似二分法求第k小即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存池+计数排序的SAM，相对优秀</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">9e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    State *pa;</span><br><span class="line">    State *go[MAXW];</span><br><span class="line">    <span class="type">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt;    </span><br><span class="line">&#125;sam[MAXN&lt;&lt;<span class="number">1</span>], *last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(<span class="type">int</span> Max)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref.Max = Max;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(State* src)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref = *src;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = <span class="built_in">alloc</span>(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;Max == p-&gt;Max+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* nq = <span class="built_in">alloc</span>(q);</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> State::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"><span class="type">int</span> Q, len;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line">State* b[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似二分法求当前第lef小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> State* now, <span class="type">int</span> dep, <span class="type">int</span> lef)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ans[MAXN];</span><br><span class="line">    <span class="keyword">if</span> (lef == <span class="number">0</span>) &#123;</span><br><span class="line">        ans[dep] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAXW; ++i) <span class="keyword">if</span> (now-&gt;go[i]) &#123;</span><br><span class="line">        <span class="type">const</span> State* g = now-&gt;go[i];</span><br><span class="line">        <span class="keyword">if</span> (lef &lt;= g-&gt;siz) &#123;</span><br><span class="line">            ans[dep] = i+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(g, dep+<span class="number">1</span>, lef<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lef -= g-&gt;siz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    last = root = <span class="built_in">alloc</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=len; st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="built_in">extend</span>(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) ++num[sam[i].Max];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line">    <span class="comment">// 沿拓扑序DP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (b[i]-&gt;go[j])</span><br><span class="line">                 b[i]-&gt;siz += b[i]-&gt;go[j]-&gt;siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="type">int</span> aim;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aim);</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, aim);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="离线计算-Right"><a href="#离线计算-Right" class="headerlink" title="离线计算|Right|"></a>离线计算|Right|</h1><p>构造好的后缀自动机隐含了一颗分裂树，只需访问所有节点和$Pa$指针，就能还原这颗分裂树。显然，叶子节点的$|Right| &#x3D; 1$，但仅有这些信息还不足推出其他节点的$|Right|$，这是因为节点在往下分裂时可能丢失元素<br><br/><img src="/2020/10/11/SAM%E5%AE%9E%E6%88%98/abaTree.png" alt="&quot;aba&quot;的分裂树。“1”没有出现在叶节点中"></p><p>如上图所示，“1”在分裂的过程中消失了，不存在叶子节点中。</p><p>为什么$Right$集合的元素无法往下分裂？这是因为它表示的子串无法向左端扩展，换句话说，它是前缀。注意到叶子节点也是前缀。综上所述，只要对前缀所在节点的$|Right|$预置为$1$（其他节点预置为$0$），然后自底向上更新分裂树即可得到所有$|Right|$</p><h2 id="分裂树上拓扑排序"><a href="#分裂树上拓扑排序" class="headerlink" title="分裂树上拓扑排序"></a>分裂树上拓扑排序</h2><p>上文引出了一个新问题，如何自底向上地访问分裂树？一种直观的办法是bfs收集SAM所有节点再做拓扑排序，这逻辑复杂而代码繁琐。一种更好的办法是，在构造SAM时采用内存池技术，之后对内存池按照$Max$降序排序即可。原因是<br>$$ Max(fa)+1&#x3D;Min(s) \Rightarrow Max(s) &gt; Max(fa)$$<br>有趣的是，分裂树的拓扑序也是自动机的拓扑序！原因是<br>$$ trans(s, *)&#x3D;t \Rightarrow Max(t) &gt; Max(s) $$<br>如果你忘记了，请复习<a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机 Suffix Automaton">后缀自动机的更多性质</a>。</p><div class="note primary"><h4 id="拓扑排序要点"><a href="#拓扑排序要点" class="headerlink" title="拓扑排序要点"></a>拓扑排序要点</h4><ol><li>指针板构造采用内存池技术</li><li>$Max$可能的取值仅有$[1,n]$，所以要采用计数排序</li><li>不要真的修改内存池，而是新开指针做排序</li><li>如果不得不写常规拓扑排序，bfs时请注意DAG的重复访问</li></ol></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) ++num[sam[i].Max];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line"><span class="comment">// sam[] has been top sorted by b[].</span></span><br></pre></td></tr></table></figure><p>剩余细节在<a href="#%E6%B1%82%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AC%ACk%E5%B0%8F%E5%AD%90%E4%B8%B2">例题1</a>、<a href="#%E6%B1%82%E9%95%BF%E5%BA%A6%E4%B8%BA-i-%E7%9A%84%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">例题2</a>中体现</p><h2 id="求长度为i的子串的最大出现次数"><a href="#求长度为i的子串的最大出现次数" class="headerlink" title="求长度为i的子串的最大出现次数"></a>求长度为i的子串的最大出现次数</h2><p><a href="https://www.spoj.com/problems/NSUBSTR/">SPOJ NSUBSTR</a> 题意：给出字符串S（长度&lt;&#x3D;2.5e5），设f(x)为S中长度为x的子串的最大出现次数，求f(1...length(s))。</p><p>分析：后缀自动机中每个状态$s$蕴含的字符串长度为$[Min(s), Max(s)]$，每个出现了$Right(s)$次，只需用$|Right(s)|$更新$ans[Max(s)]$就行了，在最后输出前依次用$ans[i+1]$更新$ans[i]$即可。原因是长度更长的子串出现的次数一定不超过长度短的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素的拓扑排序版本，推荐改用计数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">50</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">250000</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    State* pa;</span><br><span class="line">    State* go[MAXW];</span><br><span class="line">    <span class="type">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> RSiz = <span class="number">0</span>, inD = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> Max) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="built_in">sizeof</span>(go));</span><br><span class="line">        pa = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Max = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">State</span>(<span class="type">const</span> State* o) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(go, o-&gt;go, <span class="built_in">sizeof</span>(go));</span><br><span class="line">        pa = o-&gt;pa;</span><br><span class="line">        Max = o-&gt;Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root, *last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = <span class="keyword">new</span> <span class="built_in">State</span>(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State *q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Max+<span class="number">1</span> == q-&gt;Max)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line">        </span><br><span class="line">    State *nq = <span class="keyword">new</span> <span class="built_in">State</span>(q);</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c]=nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">State* q[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        State* <span class="type">const</span> now = q[i];</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;pa) ++now-&gt;pa-&gt;inD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;go[j] &amp;&amp; !now-&gt;go[j]-&gt;vis) &#123;</span><br><span class="line">                q[cnt++] = now-&gt;go[j];</span><br><span class="line">                now-&gt;go[j]-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="built_in">partition</span>(q, q+cnt, [](<span class="type">const</span> State* o) &#123;</span><br><span class="line">        <span class="keyword">return</span> o-&gt;inD == <span class="number">0</span>;</span><br><span class="line">    &#125;) - q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        State* now = q[head++];</span><br><span class="line">        <span class="keyword">if</span> (!now-&gt;pa) <span class="keyword">continue</span>;</span><br><span class="line">        now-&gt;pa-&gt;RSiz += now-&gt;RSiz;</span><br><span class="line">        <span class="keyword">if</span> (--now-&gt;pa-&gt;inD == <span class="number">0</span>)</span><br><span class="line">            q[tail++] = now-&gt;pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    root = last = <span class="keyword">new</span> <span class="built_in">State</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=(len=<span class="number">0</span>); st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="built_in">extend</span>(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs取出SAM中的所有节点，注意判重</span></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对SAM中所有蕴含前缀的状态 |Right| = 1（其它置为0）</span></span><br><span class="line">    State* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        p = p-&gt;go[st[i]];</span><br><span class="line">        ++p-&gt;RSiz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序，顺便自底向上更新|Right|</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        ans[q[i]-&gt;Max] = <span class="built_in">max</span>(ans[q[i]-&gt;Max], q[i]-&gt;RSiz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; --i)</span><br><span class="line">        ans[i<span class="number">-1</span>] = <span class="built_in">max</span>(ans[i<span class="number">-1</span>], ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="跳向父亲，舍弃左端，寻求匹配"><a href="#跳向父亲，舍弃左端，寻求匹配" class="headerlink" title="跳向父亲，舍弃左端，寻求匹配"></a>跳向父亲，舍弃左端，寻求匹配</h1><p><code>now = now-&gt;pa</code>的本质是抛弃左端一部分字符，带来的效果是$Right$集合的扩张。这个特性在求最长公共子串的时候尤为好用，与KMP舍弃右端部分字符以寻求匹配的原理有异曲同工之妙。</p><h2 id="求两字符串的最长公共子串"><a href="#求两字符串的最长公共子串" class="headerlink" title="求两字符串的最长公共子串"></a>求两字符串的最长公共子串</h2><p><a href="https://www.spoj.com/problems/LCS/">SPOJ LCS</a> 题意：求字符串$S1,S2$的最长公共子串(要求连续)</p><p>分析：后缀自动机很擅长处理连续串的匹配。试想我们做出$S1$的SAM，然后直接跑$S2$，势必出现出边不存在的问题——无法继续匹配了。不妨设无法继续匹配时，导致无法匹配的字符是$S2[i]$，当前状态为$s$，即$trans(s, S2[i])$不存在，即不存在$S1[r_j]&#x3D;S2[i], r_j\in Right(s)$。想要寻求匹配，只能抛弃已匹配的子串左端，而<code>s=s-&gt;pa</code>恰好带来了最少的抛弃量，使得$Right(s)$能扩张，从而带来匹配的可能性。</p><p>换句话说，当<code>s-&gt;go[S2[i]] == nullptr</code>时，重复<code>s = s-&gt;pa</code>，直到获得匹配<code>s-&gt;go[S2[i]] != nullptr</code>或不可能匹配<code>s == nullptr</code>。</p><p>假如直接能匹配呢？那太简单了，匹配长度加一，下一位。</p><p>于是最终解为：记当前已匹配长度$match$，当前答案$ans$，当前自动机状态$s$，接下来尝试匹配$S2[i]$，若$trans(s,S2[i])$存在，就转移，并且$match$加一；否则尝试不断跳分裂树的$fa$，直到转移存在，由于$Max(fa) &lt; Min(s) \le match$，$match$必能取到$Max(fa)$，所以$s$跳到$trans(fa, S2[i])$， $match$取为$Max(fa)+1$即可。每走一步都用$match$更新$ans$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略SAM的构造和其他乱七八糟的东西</span></span><br><span class="line">    State* now = root;</span><br><span class="line">    <span class="type">int</span> match = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; sb[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> c = (sb[i]-=<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now-&gt;go[c]) &#123;</span><br><span class="line">            now = now-&gt;go[c];</span><br><span class="line">            ++match;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (now &amp;&amp; !now-&gt;go[c])</span><br><span class="line">                now = now-&gt;pa;</span><br><span class="line">            <span class="keyword">if</span> (now) &#123;</span><br><span class="line">                match = now-&gt;Max+<span class="number">1</span>;</span><br><span class="line">                now = now-&gt;go[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now = root;</span><br><span class="line">                match = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, match);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;em&gt;实战不会SAM？导致比赛打铁？快 点 学 ！&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;a href=&quot;/2020/10/01/Suffix-Automaton/&quot; title=&quot;后缀自动机 Suffix Automaton&quot;&gt;后缀自动机(Suffix-Automaton)&lt;/a&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://codesire-deng.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机 Suffix Automaton</title>
    <link href="https://codesire-deng.github.io/2020/10/01/Suffix-Automaton/"/>
    <id>https://codesire-deng.github.io/2020/10/01/Suffix-Automaton/</id>
    <published>2020-10-01T15:03:46.000Z</published>
    <updated>2022-10-13T07:21:16.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="自动机的五个部分"><a href="#自动机的五个部分" class="headerlink" title="自动机的五个部分"></a>自动机的五个部分</h2><ol><li><strong>alpha</strong> 字符集</li><li><strong>state</strong> 状态集合。另让$null$表示不存在的状态或转移</li><li><strong>init</strong> 初始状态</li><li><strong>end</strong> 结束状态集合</li><li><strong>trans</strong> 状态转移函数：令$trans(s, str)$表示在状态$s$时读入字符串$str$后，所达到的状态。$trans$应具有传递性。</li></ol><span id="more"></span><h2 id="设"><a href="#设" class="headerlink" title="设"></a>设</h2><ol><li>自动机能识别的所有字符串集合<strong>Reg(A)</strong> ，其中的字符串$x$满足$trans(init, x)\in end$</li><li>从状态$s$开始能识别的字符串 <strong>Reg(s)</strong></li><li>后缀自动机<strong>SAM</strong>，一个能识别母串$S$的所有后缀的自动机。$SAM(x)&#x3D;true$当且仅当$x$是$S$的后缀。</li><li>$trans(init, str)$即从初始状态读入$str$后到达的状态<strong>ST(str)</strong> <em>（ST是state的缩写)</em></li><li>母串$S$的所有后缀的集合<strong>Suf</strong>，从$a$位置开始的后缀<strong>Suffix(a)</strong></li><li>母串$S$的所有连续子串的集合<strong>Fac</strong>，位置为$[l,r)$的子串<strong>S[l,r)</strong></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="SAM的可行性分析"><a href="#SAM的可行性分析" class="headerlink" title="SAM的可行性分析"></a>SAM的可行性分析</h2><ol><li><p>对于字符串$s$，若$s\in Fac$，则$ST(s)$应存在，这是因为可以在$s$后面加上一些字符使其变成$S$的后缀。<em>反之$s\notin Fac$，则应有$ST(s)&#x3D;null$以节省空间</em></p></li><li><p>考虑$ST(a)$能识别哪些字符串，即$Reg(ST(a))$。若$x\in Reg(ST(a))$，则$ax\in Suf$，故$ax$是后缀，$x$也是后缀。$Reg(ST(a))$是每次$a$出现后接下来的后缀。设<strong>Right(a)</strong> 为a每次出现的开区间末位置，则$Reg(ST(a))$完全由$Right(a)$决定。</p></li><li><p>对于状态$s$（不是单个字符串），我们关心$Reg(s)$。如果对于$a,b\in Fac$有$Right(a)&#x3D;Right(b)$，那么可令$ST(a)&#x3D; ST(b)$。所以一个状态$s$由所有$Right$集合是<strong>Right(s)</strong> 的字符串组成。</p></li><li><p>考虑状态$s$包括的字符串长度，易证若$s$包含长度为$l$,$r$的字符串，那么一定包含长度为$m(l \leq m \leq r)$的字符串。所以这些字符串长度一定可以组成一个区间，设为 <strong>[Min(s), Max(s)]</strong></p></li><li><p>状态数是线性的。<br/>　　状态由$Right$集合决定，考虑两个状态$a,b$的$Right$集合$R_a,R_b$。假设$R_a,R_b$有交集，设$r \in R_a \cap R_b$。由于一个子串只能属于一个状态，所以$a$，$b$所表示的子串不会有交集，即由$r$往前不能有长度相同的子串，故$[Min(a), Max(a)]$和$[Min(b), Max(b)]$没有交集，不妨设$Max(a) &lt; Min(b)$，由于$a$，$b$包含的所有串都可以视为$r$往前的子串，故$a$的所有串都是$b$的任意串的后缀。因$b$的任意串都能找到后缀属于$a$，两者$Right$集合又不相等，故$R_b \subset R_a$。那么任意两个状态的$Right$集合要么不相交，要么一个是另一个的真子集。<br/>　　疾风将以状态为节点，以$Right$包含关系为父子关系构成的树叫 <strong>“分裂树”</strong> <br/>　　不考虑字符串这个主题，“分裂树”易证是线性的；实际上，$SAM$的结点个数最多为$2n$。<br><br/><img src="/2020/10/01/Suffix-Automaton/%E5%88%86%E8%A3%82%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="分裂树举例"></p></li><li><p>更严谨的分裂树定义：令满足$Right(s) \subset Right(fa)$的最小$|Right(fa)|$的$fa$为状态$s$的父亲。<br/>　　直观地看，一定是$fa$中最长的字符串向前扩展一位导致了$Right$集合分裂，所以$Max(fa)+1&#x3D;Min(s)$。</p></li><li><p>自动机的边数是线性的。<br/>　　直观地看，自动机是一个DAG（否则可以无限地在自动机上走，即识别无限长的字符串，显然这是不可能的），而能从$init$走到某个$end$点的肯定是字符串的某一个后缀。字符串只有$n$个后缀，意味着从$init$到$end$只能有$n$种路径；另一方面，节点数只有$O(n)$，所以猜测边数也是$O(n)$的。<br/>　　标出自动机任意一个生成树，则对于一条非树边$(a\rightarrow b)$，存在若干路径${init \rightarrowtail a \rightarrow b \rightarrowtail e(e\in end)}$对应着一个后缀。对每一个后缀，对应在自动机上走到的第一条非树边。如此每个后缀最多对应一个非树边，而非树边至少被一个后缀对应，所以后缀数量$\geq$非树边数量。所以边数是$O(n)$的。</p></li></ol><h2 id="归纳法构造SAM"><a href="#归纳法构造SAM" class="headerlink" title="归纳法构造SAM"></a>归纳法构造SAM</h2><h3 id="SAM的更多性质"><a href="#SAM的更多性质" class="headerlink" title="SAM的更多性质"></a>SAM的更多性质</h3><p><em>这一部分是SAM构造算法的重要依据。<br/>请确认上文所有加粗内容都已理解。</em></p><ol><li><p>后缀自动机是一个有向无环图<br>$$<br>SAM &#x3D; {分裂树的点，自动机的有向边}<br>$$ </p></li><li><p>SAM的构造算法是在线的，即从左到右逐个添加字符。根据数学归纳法，<strong>下文假设已有字符串$T$的后缀自动机</strong>。</p></li><li><p>考虑一个状态$s$，它的$Right(s)&#x3D;{r_1, r_2, \cdots, r_n}$，假如有状态转移$trans(s,c) &#x3D; t$（即状态$s$后添加一个字符$c$得到状态$t$），由于向右扩展了一位字符，$Right(s)$中只有$T[r_i]&#x3D;c$的满足要求。所以$Right(t)&#x3D;{r_i+1 | T[r_i]&#x3D;c}$。<br/>　　如果$trans(s,c)$存在，那么$trans(Pa(s), c)$必定存在，其中$Pa(s)$表示分裂树上状态$s$的父亲。并且$Right(trans(s,c)) \subseteq Right(trans(Pa(s),c))$。<br/>　　另一个显然的结论是$Max(s)&lt;Max(t)$。</p></li><li><p>后缀自动机没有显式地储存$Right$集合。因此可以认为修改$Right$的时间复杂度为$O(0)$。</p></li><li><p>初始状态时母串$T$为空字符串，自动机只有一个节点$root$。</p></li></ol><h3 id="添加一位字符更新自动机"><a href="#添加一位字符更新自动机" class="headerlink" title="添加一位字符更新自动机"></a>添加一位字符更新自动机</h3><p>　　令当前字符串为$T$，长度为$L$；末尾添加一个字符$x$，要将$SAM(T)$更新为$SAM(Tx)$。<br><br/>　　那么新增的子串是$Tx$的所有后缀，可看作$T$的所有后缀后添加了$x$。令$SAM(T)$中表示$T$的后缀的节点为${v_1, v_2, \cdots, v_k&#x3D;root}$。因为后缀在字符串的末尾出现，所以$L\in Right(v_i)$，可知$v_i$在分裂树上恰好构成一条从叶子到$root$的链，不妨设${v_1, v_2, \cdots, v_k&#x3D;root}$已经按从叶子到祖先排序。<br><br/>　　添加字符$x$后，首先新建状态$np$表示$ST(Tx)$，这是一个已确定的状态（因为没有出边），可知$Right(np)&#x3D;{L+1}$。<br><br/>　　回头考虑旧自动机的$v_i$，设$Right(v_i)&#x3D;{r_1, r_2, \cdots, r_n&#x3D;L}$。如果能在后面添加字符$x$（注意现在仍是字符串$T$的自动机），即$nv&#x3D;trans(v_i, x)$存在，我们已经知道$Right(nv)&#x3D;{r_i+1|T[r_i]&#x3D;x}$；反之如果$v_i$没有$x$的出边，意味着没有$r_i$满足$T[r_i]&#x3D;x$。由于分裂树上父亲的$Right$扩大，如果$trans(v_i,x)$存在，那么$trans(v_{i+1}, x)$也存在。<br><br/>　　对于所有$trans(v,x)&#x3D;null$的$v$，而只有$Tx[r_n&#x3D;L]&#x3D;x$满足转移条件，于是添加一条边$trans(v,x)&#x3D;np$。<br><br/>　　令$v_p$是$v_1, v_2, \cdots, v_k$中第一个有$x$出边（即$trans(v_p, x)$存在）的状态。令$q&#x3D;trans(v_p, x)$，注意，现在仍是旧的自动机。我们能不能直接在$Right(q)$中直接插入$L+1$呢？答案是不能。这是因为有可能$Max(q) &gt; Max(v_p)+1$，隐含意思是$q$在”$v_p$末尾添加$x$”的基础上，由于$Right$集合的缩减，纳入了左端更多字符；如果强行在$Right(q)$中插入$L+1$，会导致$Max(q)$减小而丢失了原来的状态，破坏了自动机的正确性。</p><p><img src="/2020/10/01/Suffix-Automaton/%E5%BC%BA%E8%A1%8C%E6%8F%92%E5%85%A5%E7%9A%84%E5%8F%8D%E4%BE%8B.png" alt="强行插入的反例"><br><br/>　　如图所示，$v_p$含有的最长字符串是红色5个“A”，但$trans(v_p,x)&#x3D;q$含有的最长字符串是蓝色7位字符串，如果在$Right(q)$中强行插入$L+1$即变为绿色部分，会使$Max(q)$从7减少到6从而丢失信息。<br><br/>　　如果足够幸运，$Max(q) &#x3D; Max(v_p)+1$，就没有上面的问题，我们可以在$Right(q)$中插入$L+1$，然后只要令$Pa(np)&#x3D;q$即可完成自动机更新。<em>注：理论上$Right(trans(v_p\dots v_k,x))$都要插入$L+1$，但这些状态的出边都没有发生改变，而后缀自动机实际上不记录$Right$，所以更新完成。</em><br><br/>　　如果没那么幸运，从图上可知，原状态$q$在插入末尾字符$x$后应转换两个状态，设蓝色对应的状态为$q&#39;$（沿用$q$)，绿色状态为$nq$（新建节点）。显然<br>$$<br>trans(q&#39;, *) &#x3D; trans(q, *), \<br>Pa(q&#39;)&#x3D;nq，\<br>Right(nq)&#x3D;Right(q&#39;)\cup {L+1}，\<br>Max(nq) &#x3D; Max(v_p)+1<br>$$<br>显然$Right(nq)$是真包含${L+1}$的最小集合，所以<br>$$ Pa(np)&#x3D;nq $$<br><br/>　　截至目前我们新添了$np$，将$q$转化为$q&#39;,nq$，其中$np,q&#39;$都正确处理了出边和分裂树父亲。<br>那么$nq$的分裂树父亲又是谁呢？结合上图易证<br>$$ Pa(nq)&#x3D;Pa(q) $$</p><p>$nq$的出边是哪一些？由于新添的最后一个字符不能带来更多的状态转移（最后一个字符后面再没有字符了），所以<br>$$ trans(nq, *) &#x3D; trans(q, *) $$<br><br/>　　最后，我们还要考虑原自动机中指向$q$的状态，和新自动机中应当指向$q&#39;$和$nq$的状态。在$v_p,\cdots,v_k$中，由于$Right$的扩大，$Right(trans(v_i,x))$也逐渐扩大（不缩小），所以只有一段连续的$v_p,\cdots,v_e(e\le k)$是指向$q$的，由于要配合在$Right$集合中插入$L+1$，这些出边要修改为<br>$$ trans(v_i,x) &#x3D; nq $$<br>其余指向$q$的状态必然由于左端有过多字符而无法指向$nq$，于是改为指向$q&#39;$，等效于不做任何修改。<br><br/>　　最后的最后，对于$v_{e+1},\cdots,v_k$，对于$nv&#x3D;trans(v_i, x)$，必然可以粗暴地令$Right(nv)$插入$L+1$，所以转移关系可以保持不变，等效于不做任何修改。</p><h1 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">State* go[MAXW];</span><br><span class="line">State* pa;</span><br><span class="line"><span class="type">int</span> mx;</span><br><span class="line"></span><br><span class="line"><span class="built_in">State</span>(<span class="type">int</span> MX):<span class="built_in">pa</span>(<span class="number">0</span>), <span class="built_in">mx</span>(MX) &#123;</span><br><span class="line"><span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">State</span>(<span class="type">const</span> State* o) &#123;</span><br><span class="line">pa = o-&gt;pa;</span><br><span class="line"><span class="built_in">memcpy</span>(go, o-&gt;go, <span class="built_in">sizeof</span>(o-&gt;go));</span><br><span class="line">mx = o-&gt;mx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">State* p = last;</span><br><span class="line">State* np = <span class="keyword">new</span> <span class="built_in">State</span>(p-&gt;mx+<span class="number">1</span>);</span><br><span class="line">last = np;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==<span class="number">0</span>)</span><br><span class="line">p-&gt;go[x] = np, p = p-&gt;pa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">State* q = p-&gt;go[x];</span><br><span class="line"><span class="keyword">if</span> (p-&gt;mx+<span class="number">1</span> == q-&gt;mx)</span><br><span class="line"><span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">State* nq = <span class="keyword">new</span> <span class="built_in">State</span>(q);</span><br><span class="line">nq-&gt;mx = p-&gt;mx+<span class="number">1</span>;</span><br><span class="line">q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==q)</span><br><span class="line">p-&gt;go[x] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line"></span><br><span class="line">last = root = <span class="keyword">new</span> <span class="built_in">State</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line"><span class="built_in">extend</span>(st[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>　　SAM思路真的异常精妙，环环相扣，巧夺天工。不幸的是优美的结论是以复杂而庞大的论证为代价的。<br><br/>　　被奉为圣经的<code>2012年noi冬令营陈立杰讲稿(SAM后缀自动机)</code>在描述构造过程的时候没有解释可以省略的操作为什么被省略，导致思路有很大残缺和跳跃。即使是本文也用了不少“显然”字眼，但比较原文已有较大改进。另外，原讲稿没有交代构造算法为什么是$O(n)$的。<del>疾风理解这ppt花了整整三天</del>如果本文对你有帮助，不妨赏疾风一支冰阔乐喝（馋.jpg）<br><br/>　　有人说SAM完全可以当做黑盒来用，我认为不然。黑盒SAM的唯一功能是判定子串是否存在，局限性很大。而SAM的实战应用代码相对裸构造有很大增改，例如要结合dfs序，平衡树，动态树等等技巧，且都是建立在完全理解后缀自动机的基础上，难度依然很大。这部分日后再填补。</p><p><em>转载请注明原作者和网址</em></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;h2 id=&quot;自动机的五个部分&quot;&gt;&lt;a href=&quot;#自动机的五个部分&quot; class=&quot;headerlink&quot; title=&quot;自动机的五个部分&quot;&gt;&lt;/a&gt;自动机的五个部分&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt; 字符集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt; 状态集合。另让$null$表示不存在的状态或转移&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt; 初始状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end&lt;/strong&gt; 结束状态集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trans&lt;/strong&gt; 状态转移函数：令$trans(s, str)$表示在状态$s$时读入字符串$str$后，所达到的状态。$trans$应具有传递性。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://codesire-deng.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="数据结构" scheme="https://codesire-deng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CG with OpenGL</title>
    <link href="https://codesire-deng.github.io/2020/09/19/CG-with-OpenGL/"/>
    <id>https://codesire-deng.github.io/2020/09/19/CG-with-OpenGL/</id>
    <published>2020-09-19T07:22:34.000Z</published>
    <updated>2021-08-05T15:51:38.388Z</updated>
    
    <content type="html"><![CDATA[<p>更新：现在都用核心模式了，推荐<a href="https://learnopengl-cn.github.io/">LearnOpenGL</a>，不推荐往下看啦。</p><hr><h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>OpenGL系统由独立于设备的函数集（核心库）、实用库（GLU）和实用工具包（GLUT）三部分组成。</p><span id="more"></span><h2 id="二维几何变换"><a href="#二维几何变换" class="headerlink" title="二维几何变换"></a>二维几何变换</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="搬砖"><a href="#搬砖" class="headerlink" title="搬砖"></a>搬砖</h2><blockquote class="blockquote-center"><p>码农之路不可长远</p></blockquote><h3 id="glut模板"><a href="#glut模板" class="headerlink" title="glut模板"></a>glut模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someDrawing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); <span class="comment">// 显示背景色</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.4</span>, <span class="number">0.2</span>); <span class="comment">// 设置颜色为绿色</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 画线</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">        <span class="built_in">glVertex2i</span>(<span class="number">180</span>, <span class="number">15</span>); <span class="comment">// (180, 15) --- (10, 145)</span></span><br><span class="line">        <span class="built_in">glVertex2i</span>(<span class="number">10</span>, <span class="number">145</span>);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glFlush</span>(); <span class="comment">// 立即处理OpenGL常规事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用单缓存，且使用RGB模式</span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 距离左边界50像素，距离上边界100像素</span></span><br><span class="line">    <span class="built_in">glutInitWindowPosition</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 宽度400像素，高度300像素</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Window Title&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 背景缓存色为白色，Alpha值（调和参数）为0</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置正投影模式,将世界坐标系二维矩形区域内的内容映射到屏幕上</span></span><br><span class="line">    <span class="comment">// x坐标为[0, 200]，y坐标为[0, 150]。此范围外的内容不予显示</span></span><br><span class="line">    <span class="comment">// 纵横比与窗口保持一致，使图形不变形</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>(); <span class="comment">// 排除之前投影矩阵的影响</span></span><br><span class="line">    <span class="built_in">gluOrtho2D</span>(<span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">0.0</span>, <span class="number">150.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(someDrawing); <span class="comment">// 注册绘图函数</span></span><br><span class="line">    <span class="built_in">glutMainLoop</span>(); <span class="comment">// 进入主循环：显示所有东西然后等待</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主动错误检查"><a href="#主动错误检查" class="headerlink" title="主动错误检查"></a>主动错误检查</h3><p>OpenGL记录一个全局错误标志，表示最近一个未被程序员抓取的错误信息。推荐在每一个显示回调子程序中至少检查一次出错情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLenum <span class="title">errorCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> GLenum code = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">if</span> (code != GL_NO_ERROR) &#123;</span><br><span class="line">        <span class="type">const</span> GLubyte* what = <span class="built_in">gluErrorString</span>(code); <span class="comment">// 静态常量内存</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;OpenGL error: %s\n&quot;</span>, what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画点与画线"><a href="#画点与画线" class="headerlink" title="画点与画线"></a>画点与画线</h3><p>函数后缀：int-&gt;<code>i</code>，short-&gt;<code>s</code>，float-&gt;<code>f</code>，double-&gt;<code>d</code>，vector-&gt;<code>v</code>，2D-&gt;<code>2</code>，3D-&gt;<code>3</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p1[] = &#123;<span class="number">75</span>, <span class="number">150</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POINTS); <span class="comment">// 点</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINES); <span class="comment">// 两个点构成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);<span class="comment">// 成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);    <span class="comment">// 成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);    <span class="comment">// 被忽略</span></span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINE_STRIP); <span class="comment">// 普通折线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);    </span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINE_LOOP); <span class="comment">// 封闭折线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);   <span class="comment">// p1与p5成线</span></span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);    </span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure><p>有关OpenGL的出错编码请自行查找资料。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新：现在都用核心模式了，推荐&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;LearnOpenGL&lt;/a&gt;，不推荐往下看啦。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;OpenGL&quot;&gt;&lt;a href=&quot;#OpenGL&quot; class=&quot;headerlink&quot; title=&quot;OpenGL&quot;&gt;&lt;/a&gt;OpenGL&lt;/h1&gt;&lt;p&gt;OpenGL系统由独立于设备的函数集（核心库）、实用库（GLU）和实用工具包（GLUT）三部分组成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游戏" scheme="https://codesire-deng.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>跟我一起写Makefile</title>
    <link href="https://codesire-deng.github.io/2020/02/01/Makefile/"/>
    <id>https://codesire-deng.github.io/2020/02/01/Makefile/</id>
    <published>2020-02-01T08:08:00.000Z</published>
    <updated>2020-09-18T17:04:51.940Z</updated>
    
    <content type="html"><![CDATA[<p>路过一篇写得很到位的Makefile介绍文章，转载一下：</p><p><a href="https://seisman.github.io/how-to-write-makefile/overview.html">seisman.github.io&#x2F;how-to-write-makefile</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;路过一篇写得很到位的Makefile介绍文章，转载一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://seisman.github.io/how-to-write-makefile/overview.html&quot;&gt;seisman.github.io&amp;#x2F;how-to</summary>
      
    
    
    
    
    <category term="杂项" scheme="https://codesire-deng.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
