<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>生命科学课程资料</title>
    <url>/2019/10/18/%E7%94%9F%E5%91%BD%E7%A7%91%E5%AD%A6%E8%AE%A8%E8%AE%BA%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="讨论课资料"><a href="#讨论课资料" class="headerlink" title="讨论课资料"></a>讨论课资料</h1><h2 id="演示文稿"><a href="#演示文稿" class="headerlink" title="演示文稿"></a>演示文稿</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">主题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第六周</td>
<td style="text-align:center"><a href="https://codesire-deng.github.io/bio_BSE/index.html" target="_blank" rel="noopener">生物伦理与物种平等</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM实战剖析</title>
    <url>/2019/10/11/SAM%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<ul>
<li><em>实战不会SAM？导致比赛打铁？快 点 学 ！</em></li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><a href="/2019/10/01/Suffix-Automaton/" title="后缀自动机(Suffix-Automaton)">后缀自动机(Suffix-Automaton)</a>
<a id="more"></a>
<h1 id="在自动机上游走"><a href="#在自动机上游走" class="headerlink" title="在自动机上游走"></a>在自动机上游走</h1><p>&emsp;&emsp;从$root$开始，沿目标字符串逐个字符走。若路径存在，即当前子串存在；反之，若出边不存在，即目标子串不存在。</p>
<h2 id="求最小表示"><a href="#求最小表示" class="headerlink" title="求最小表示"></a>求最小表示</h2><p>&emsp;&emsp;求字符串$S$的最小表示。<br><br>　　<em>度娘有$O(n)$的特殊做法，此处不赘述。</em><br><br>　　构造字符串$SS$的后缀自动机，从$root$开始，每次沿最小的出边走，走n步就得到了$SS$中长度为n的最小子串，即$S$的最小表示。</p>
<h2 id="求本质不同的第k小子串"><a href="#求本质不同的第k小子串" class="headerlink" title="求本质不同的第k小子串"></a>求本质不同的第k小子串</h2><p><a href="https://www.spoj.com/problems/SUBLEX/" target="_blank" rel="noopener">SPOJ SUBLEX</a> 题意：求字符串$S$的所有本质不同子串中的第$k$小。$length(S)\le 9e4, 询问数量\le 500$。<br><br>　　SAM构造完成后得到一个DAG，利用拓扑序求从每个点出发可能的路径数目。见<a href="#SAM%e4%b8%8a%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f">拓扑排序的方法</a>。最后用类似二分法求第k小即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存池+计数排序的SAM，相对优秀</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">9e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    State *pa;</span><br><span class="line">    State *go[MAXW];</span><br><span class="line">    <span class="keyword">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;    </span><br><span class="line">&#125;sam[MAXN&lt;&lt;<span class="number">1</span>], *last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(<span class="keyword">int</span> Max)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref.Max = Max;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(State* src)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref = *src;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = alloc(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="keyword">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;Max == p-&gt;Max+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="keyword">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* nq = alloc(q);</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> State::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> st[MAXN];</span><br><span class="line"><span class="keyword">int</span> Q, len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line">State* b[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似二分法求当前第lef小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> State* now, <span class="keyword">int</span> dep, <span class="keyword">int</span> lef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ans[MAXN];</span><br><span class="line">    <span class="keyword">if</span> (lef == <span class="number">0</span>) &#123;</span><br><span class="line">        ans[dep] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">puts</span>(ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXW; ++i) <span class="keyword">if</span> (now-&gt;go[i]) &#123;</span><br><span class="line">        <span class="keyword">const</span> State* g = now-&gt;go[i];</span><br><span class="line">        <span class="keyword">if</span> (lef &lt;= g-&gt;siz) &#123;</span><br><span class="line">            ans[dep] = i+<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">return</span> dfs(g, dep+<span class="number">1</span>, lef<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lef -= g-&gt;siz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    last = root = alloc(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i=len; st[i]!=<span class="string">'\0'</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">'a'</span>;</span><br><span class="line">        extend(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) ++num[sam[i].Max];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line">    <span class="comment">// 沿拓扑序DP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (b[i]-&gt;go[j])</span><br><span class="line">                 b[i]-&gt;siz += b[i]-&gt;go[j]-&gt;siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> aim;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;aim);</span><br><span class="line">        dfs(root, <span class="number">0</span>, aim);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="离线计算-Right"><a href="#离线计算-Right" class="headerlink" title="离线计算|Right|"></a>离线计算|Right|</h1><p>&emsp;&emsp;构造好的后缀自动机隐含了一颗分裂树，只需访问所有节点和$Pa$指针，就能还原这颗分裂树。显然，叶子节点的$|Right| = 1$，但仅有这些信息还不足推出其他节点的$|Right|$，这是因为节点在往下分裂时可能丢失元素<br><br><img src="/2019/10/11/SAM实战/abaTree.png" alt="&quot;aba&quot;的分裂树。“1”没有出现在叶节点中"><br><br>　　如上图所示，“1”在分裂的过程中消失了，不存在叶子节点中。<br><br>　　为什么$Right$集合的元素无法往下分裂？这是因为它表示的子串无法向左端扩展，换句话说，它是前缀。注意到叶子节点也是前缀。综上所述，只要对前缀所在节点的$|Right|$预置为$1$（其他节点预置为$0$），然后自底向上更新分裂树即可得到所有$|Right|$</p>
<h2 id="分裂树上拓扑排序"><a href="#分裂树上拓扑排序" class="headerlink" title="分裂树上拓扑排序"></a>分裂树上拓扑排序</h2><p>&emsp;&emsp;上文引出了一个新问题，如何自底向上地访问分裂树？一种直观的办法是bfs收集SAM所有节点再做拓扑排序，这逻辑复杂而代码繁琐。一种更好的办法是，在构造SAM时采用内存池技术，之后对内存池按照$Max$降序排序即可。原因是</p>
<script type="math/tex; mode=display">Max(fa)+1=Min(s) \Rightarrow Max(s) > Max(fa)</script><p>有趣的是，分裂树的拓扑序也是自动机的拓扑序！原因是</p>
<script type="math/tex; mode=display">trans(s, *)=t \Rightarrow Max(t) > Max(s)</script><p>如果你忘记了，请复习<a href="/2019/10/01/Suffix-Automaton/" title="后缀自动机的更多性质">后缀自动机的更多性质</a>。</p>
<div class="note primary">
            <h4 id="拓扑排序要点"><a href="#拓扑排序要点" class="headerlink" title="拓扑排序要点"></a>拓扑排序要点</h4><ol><li>指针板构造采用内存池技术</li><li>$Max$可能的取值仅有$[1,n]$，所以要采用计数排序</li><li>不要真的修改内存池，而是新开指针做排序</li><li>如果不得不写常规拓扑排序，bfs时请注意DAG的重复访问</li></ol>
          </div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) ++num[sam[i].Max];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line"><span class="comment">// sam[] has been top sorted by b[].</span></span><br></pre></td></tr></table></figure>
<p>剩余细节在<a href="#%e6%b1%82%e6%9c%ac%e8%b4%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e7%ac%ack%e5%b0%8f%e5%ad%90%e4%b8%b2">例题1</a>、<a href="#%e6%b1%82%e9%95%bf%e5%ba%a6%e4%b8%ba-i-%e7%9a%84%e5%ad%90%e4%b8%b2%e7%9a%84%e6%9c%80%e5%a4%a7%e5%87%ba%e7%8e%b0%e6%ac%a1%e6%95%b0">例题2</a>中体现</p>
<h2 id="求长度为i的子串的最大出现次数"><a href="#求长度为i的子串的最大出现次数" class="headerlink" title="求长度为i的子串的最大出现次数"></a>求长度为i的子串的最大出现次数</h2><p><a href="https://www.spoj.com/problems/NSUBSTR/" target="_blank" rel="noopener">SPOJ NSUBSTR</a> 题意：给出字符串S（长度&lt;=2.5e5），设f(x)为S中长度为x的子串的最大出现次数，求f(1…length(s))。</p>
<p>&emsp;&emsp;分析：后缀自动机中每个状态$s$蕴含的字符串长度为$[Min(s), Max(s)]$，每个出现了$Right(s)$次，只需用$|Right(s)|$更新$ans[Max(s)]$就行了，在最后输出前依次用$ans[i+1]$更新$ans[i]$即可。原因是长度更长的子串出现的次数一定不超过长度短的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 朴素的拓扑排序版本，推荐改用计数排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">50</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">250000</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    State* pa;</span><br><span class="line">    State* go[MAXW];</span><br><span class="line">    <span class="keyword">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> RSiz = <span class="number">0</span>, inD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    State(<span class="keyword">int</span> Max) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="keyword">sizeof</span>(go));</span><br><span class="line">        pa = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Max = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    State(<span class="keyword">const</span> State* o) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(go, o-&gt;go, <span class="keyword">sizeof</span>(go));</span><br><span class="line">        pa = o-&gt;pa;</span><br><span class="line">        Max = o-&gt;Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root, *last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = <span class="keyword">new</span> State(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="keyword">void</span>();</span><br><span class="line">    </span><br><span class="line">    State *q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Max+<span class="number">1</span> == q-&gt;Max)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="keyword">void</span>();</span><br><span class="line">        </span><br><span class="line">    State *nq = <span class="keyword">new</span> State(q);</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c]=nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> st[MAXN];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">State* q[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        State* <span class="keyword">const</span> now = q[i];</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;pa) ++now-&gt;pa-&gt;inD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;go[j] &amp;&amp; !now-&gt;go[j]-&gt;vis) &#123;</span><br><span class="line">                q[cnt++] = now-&gt;go[j];</span><br><span class="line">                now-&gt;go[j]-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = partition(q, q+cnt, [](<span class="keyword">const</span> State* o) &#123;</span><br><span class="line">        <span class="keyword">return</span> o-&gt;inD == <span class="number">0</span>;</span><br><span class="line">    &#125;) - q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        State* now = q[head++];</span><br><span class="line">        <span class="keyword">if</span> (!now-&gt;pa) <span class="keyword">continue</span>;</span><br><span class="line">        now-&gt;pa-&gt;RSiz += now-&gt;RSiz;</span><br><span class="line">        <span class="keyword">if</span> (--now-&gt;pa-&gt;inD == <span class="number">0</span>)</span><br><span class="line">            q[tail++] = now-&gt;pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    root = last = <span class="keyword">new</span> State(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i=(len=<span class="number">0</span>); st[i]!=<span class="string">'\0'</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">'a'</span>;</span><br><span class="line">        extend(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs取出SAM中的所有节点，注意判重</span></span><br><span class="line">    bfs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对SAM中所有蕴含前缀的状态 |Right| = 1（其它置为0）</span></span><br><span class="line">    State* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        p = p-&gt;go[st[i]];</span><br><span class="line">        ++p-&gt;RSiz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序，顺便自底向上更新|Right|</span></span><br><span class="line">    topsort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        ans[q[i]-&gt;Max] = max(ans[q[i]-&gt;Max], q[i]-&gt;RSiz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=len; i&gt;<span class="number">1</span>; --i)</span><br><span class="line">        ans[i<span class="number">-1</span>] = max(ans[i<span class="number">-1</span>], ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="跳向父亲，舍弃左端，寻求匹配"><a href="#跳向父亲，舍弃左端，寻求匹配" class="headerlink" title="跳向父亲，舍弃左端，寻求匹配"></a>跳向父亲，舍弃左端，寻求匹配</h1><p>&emsp;&emsp;<code>now = now-&gt;pa</code>的本质是抛弃左端一部分字符，带来的效果是$Right$集合的扩张。这个特性在求最长公共子串的时候尤为好用，与KMP舍弃右端部分字符以寻求匹配的原理有异曲同工之妙。</p>
<h2 id="求两字符串的最长公共子串"><a href="#求两字符串的最长公共子串" class="headerlink" title="求两字符串的最长公共子串"></a>求两字符串的最长公共子串</h2><p><a href="https://www.spoj.com/problems/LCS/" target="_blank" rel="noopener">SPOJ LCS</a> 题意：求字符串$S1,S2$的最长公共子串(要求连续)</p>
<p>&emsp;&emsp;分析：后缀自动机很擅长处理连续串的匹配。试想我们做出$S1$的SAM，然后直接跑$S2$，势必出现出边不存在的问题——无法继续匹配了。不妨设无法继续匹配时，导致无法匹配的字符是$S2[i]$，当前状态为$s$，即$trans(s, S2[i])$不存在，即不存在$S1[r_j]=S2[i], r_j\in Right(s)$。想要寻求匹配，只能抛弃已匹配的子串左端，而<code>s=s-&gt;pa</code>恰好带来了最少的抛弃量，使得$Right(s)$能扩张，从而带来匹配的可能性。<br><br>　　换句话说，当<code>s-&gt;go[S2[i]] == nullptr</code>时，重复<code>s = s-&gt;pa</code>，直到获得匹配<code>s-&gt;go[S2[i]] != nullptr</code>或不可能匹配<code>s == nullptr</code>。<br><br>　　假如直接能匹配呢？那太简单了，匹配长度加一，下一位。<br><br>　　于是最终解为：记当前已匹配长度$match$，当前答案$ans$，当前自动机状态$s$，接下来尝试匹配$S2[i]$，若$trans(s,S2[i])$存在，就转移，并且$match$加一；否则尝试不断跳分裂树的$fa$，直到转移存在，由于$Max(fa) &lt; Min(s) \le match$，$match$必能取到$Max(fa)$，所以$s$跳到$trans(fa, S2[i])$， $match$取为$Max(fa)+1$即可。每走一步都用$match$更新$ans$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略SAM的构造和其他乱七八糟的东西</span></span><br><span class="line">    State* now = root;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; sb[i]!=<span class="string">'\0'</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> c = (sb[i]-=<span class="string">'a'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now-&gt;go[c]) &#123;</span><br><span class="line">            now = now-&gt;go[c];</span><br><span class="line">            ++match;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (now &amp;&amp; !now-&gt;go[c])</span><br><span class="line">                now = now-&gt;pa;</span><br><span class="line">            <span class="keyword">if</span> (now) &#123;</span><br><span class="line">                match = now-&gt;Max+<span class="number">1</span>;</span><br><span class="line">                now = now-&gt;go[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now = root;</span><br><span class="line">                match = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = max(ans, match);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机 Suffix Automaton</title>
    <url>/2019/10/01/Suffix-Automaton/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="自动机的五个部分"><a href="#自动机的五个部分" class="headerlink" title="自动机的五个部分"></a>自动机的五个部分</h2><ol>
<li><strong>alpha</strong> 字符集</li>
<li><strong>state</strong> 状态集合。另让$null$表示不存在的状态或转移</li>
<li><strong>init</strong> 初始状态</li>
<li><strong>end</strong> 结束状态集合</li>
<li><strong>trans</strong> 状态转移函数：令$trans(s, str)$表示在状态$s$时读入字符串$str$后，所达到的状态。$trans$应具有传递性。</li>
</ol>
<a id="more"></a>
<h2 id="设"><a href="#设" class="headerlink" title="设"></a>设</h2><ol>
<li>自动机能识别的所有字符串集合 <strong>Reg(A)</strong>，其中的字符串$x$满足$trans(init, x)\in end$</li>
<li>从状态$s$开始能识别的字符串 <strong>Reg(s)</strong></li>
<li>后缀自动机<strong>SAM</strong>，一个能识别母串$S$的所有后缀的自动机。$SAM(x)=true$当且仅当$x$是$S$的后缀。</li>
<li>$trans(init, str)$即从初始状态读入$str$后到达的状态<strong>ST(str)</strong> <em>（ST是state的缩写)</em></li>
<li>母串$S$的所有后缀的集合<strong>Suf</strong>，从$a$位置开始的后缀<strong>Suffix(a)</strong></li>
<li>母串$S$的所有连续子串的集合<strong>Fac</strong>，位置为$[l,r)$的子串<strong>S[l,r)</strong></li>
</ol>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="SAM的可行性分析"><a href="#SAM的可行性分析" class="headerlink" title="SAM的可行性分析"></a>SAM的可行性分析</h2><ol>
<li><p>对于字符串$s$，若$s\in Fac$，则$ST(s)$应存在，这是因为可以在$s$后面加上一些字符使其变成$S$的后缀。<em>反之$s\notin Fac$，则应有$ST(s)=null$以节省空间</em></p>
</li>
<li><p>考虑$ST(a)$能识别哪些字符串，即$Reg(ST(a))$。若$x\in Reg(ST(a))$，则$ax\in Suf$，故$ax$是后缀，$x$也是后缀。$Reg(ST(a))$是每次$a$出现后接下来的后缀。设<strong>Right(a)</strong> 为a每次出现的开区间末位置，则$Reg(ST(a))$完全由$Right(a)$决定。</p>
</li>
<li><p>对于状态$s$（不是单个字符串），我们关心$Reg(s)$。如果对于$a,b\in Fac$有$Right(a)=Right(b)$，那么可令$ST(a)= ST(b)$。所以一个状态$s$由所有$Right$集合是<strong>Right(s)</strong> 的字符串组成。</p>
</li>
<li><p>考虑状态$s$包括的字符串长度，易证若$s$包含长度为$l$,$r$的字符串，那么一定包含长度为$m(l \leq m \leq r)$的字符串。所以这些字符串长度一定可以组成一个区间，设为 <strong>[Min(s), Max(s)]</strong></p>
</li>
<li><p>状态数是线性的。<br>　　状态由$Right$集合决定，考虑两个状态$a,b$的$Right$集合$R_a,R_b$。假设$R_a,R_b$有交集，设$r \in R_a \cap R_b$。由于一个子串只能属于一个状态，所以$a$，$b$所表示的子串不会有交集，即由$r$往前不能有长度相同的子串，故$[Min(a), Max(a)]$和$[Min(b), Max(b)]$没有交集，不妨设$Max(a) &lt; Min(b)$，由于$a$，$b$包含的所有串都可以视为$r$往前的子串，故$a$的所有串都是$b$的任意串的后缀。因$b$的任意串都能找到后缀属于$a$，两者$Right$集合又不相等，故$R_b \subset R_a$。那么任意两个状态的$Right$集合要么不相交，要么一个是另一个的真子集。<br>　　疾风将以状态为节点，以$Right$包含关系为父子关系构成的树叫 <strong>“分裂树”</strong> <br>　　不考虑字符串这个主题，“分裂树”易证是线性的；实际上，$SAM$的结点个数最多为$2n$。<br><br><img src="/2019/10/01/Suffix-Automaton/分裂树举例.png" alt="分裂树举例"></p>
</li>
<li><p>更严谨的分裂树定义：令满足$Right(s) \subset Right(fa)$的最小$|Right(fa)|$的$fa$为状态$s$的父亲。<br>　　直观地看，一定是$fa$中最长的字符串向前扩展一位导致了$Right$集合分裂，所以<strong>Max(fa)+1=Min(s)</strong>。</p>
</li>
<li><p>自动机的边数是线性的。<br>　　直观地看，自动机是一个DAG（否则可以无限地在自动机上走，即识别无限长的字符串，显然这是不可能的），而能从$init$走到某个$end$点的肯定是字符串的某一个后缀。字符串只有$n$个后缀，意味着从$init$到$end$只能有$n$种路径；另一方面，节点数只有$O(n)$，所以猜测边数也是$O(n)$的。<br>　　标出自动机任意一个生成树，则对于一条非树边$(a\rightarrow b)$，存在若干路径$\{init \rightarrowtail a \rightarrow b \rightarrowtail e(e\in end)\}$对应着一个后缀。对每一个后缀，对应在自动机上走到的第一条非树边。如此每个后缀最多对应一个非树边，而非树边至少被一个后缀对应，所以后缀数量$\geq$非树边数量。所以边数是$O(n)$的。</p>
</li>
</ol>
<h2 id="归纳法构造SAM"><a href="#归纳法构造SAM" class="headerlink" title="归纳法构造SAM"></a>归纳法构造SAM</h2><h3 id="SAM的更多性质"><a href="#SAM的更多性质" class="headerlink" title="SAM的更多性质"></a>SAM的更多性质</h3><p><em>这一部分是SAM构造算法的重要依据。<br>请确认上文所有加粗内容都已理解。</em></p>
<ol>
<li><p>后缀自动机是一个有向无环图</p>
<script type="math/tex; mode=display">
SAM = \{分裂树的点，自动机的有向边\}</script></li>
<li><p>SAM的构造算法是在线的，即从左到右逐个添加字符。根据数学归纳法，<strong>下文假设已有字符串$T$的后缀自动机</strong>。</p>
</li>
<li><p>考虑一个状态$s$，它的$Right(s)=\{r_1, r_2, \cdots, r_n\}$，假如有状态转移$trans(s,c) = t$（即状态$s$后添加一个字符$c$得到状态$t$），由于向右扩展了一位字符，$Right(s)$中只有$T[r_i]=c$的满足要求。所以$Right(t)=\{r_i+1 | T[r_i]=c\}$。<br>　　如果$trans(s,c)$存在，那么$trans(Pa(s), c)$必定存在，其中$Pa(s)$表示分裂树上状态$s$的父亲。并且$Right(trans(s,c)) \subseteq Right(trans(Pa(s),c))$。<br>　　另一个显然的结论是$Max(s)&lt;Max(t)$。</p>
</li>
<li><p>后缀自动机没有显式地储存$Right$集合。因此可以认为修改$Right$的时间复杂度为$O(0)$。</p>
</li>
<li><p>初始状态时母串$T$为空字符串，自动机只有一个节点$root$。</p>
</li>
</ol>
<h3 id="添加一位字符更新自动机"><a href="#添加一位字符更新自动机" class="headerlink" title="添加一位字符更新自动机"></a>添加一位字符更新自动机</h3><p>&emsp;&emsp;令当前字符串为$T$，长度为$L$；末尾添加一个字符$x$，要将$SAM(T)$更新为$SAM(Tx)$。<br><br>　　那么新增的子串是$Tx$的所有后缀，可看作$T$的所有后缀后添加了$x$。令$SAM(T)$中表示$T$的后缀的节点为$\{v_1, v_2, \cdots, v_k=root\}$。因为后缀在字符串的末尾出现，所以$L\in Right(v_i)$，可知$v_i$在分裂树上恰好构成一条从叶子到$root$的链，不妨设$\{v_1, v_2, \cdots, v_k=root\}$已经按从叶子到祖先排序。<br><br>　　添加字符$x$后，首先新建状态$np$表示$ST(Tx)$，这是一个已确定的状态（因为没有出边），可知$Right(np)=\{L+1\}$。<br><br>　　回头考虑旧自动机的$v_i$，设$Right(v_i)=\{r_1, r_2, \cdots, r_n=L\}$。如果能在后面添加字符$x$（注意现在仍是字符串$T$的自动机），即$nv=trans(v_i, x)$存在，我们已经知道$Right(nv)=\{r_i+1|T[r_i]=x\}$；反之如果$v_i$没有$x$的出边，意味着没有$r_i$满足$T[r_i]=x$。由于分裂树上父亲的$Right$扩大，如果$trans(v_i,x)$存在，那么$trans(v_{i+1}, x)$也存在。<br><br>　　对于所有$trans(v,x)=null$的$v$，而只有$Tx[r_n=L]=x$满足转移条件，于是添加一条边$trans(v,x)=np$。<br><br>　　令$v_p$是$v_1, v_2, \cdots, v_k$中第一个有$x$出边（即$trans(v_p, x)$存在）的状态。令$q=trans(v_p, x)$，注意，现在仍是旧的自动机。我们能不能直接在$Right(q)$中直接插入$L+1$呢？答案是不能。这是因为有可能$Max(q) &gt; Max(v_p)+1$，隐含意思是$q$在”$v_p$末尾添加$x$”的基础上，由于$Right$集合的缩减，纳入了左端更多字符；如果强行在$Right(q)$中插入$L+1$，会导致$Max(q)$减小而丢失了原来的状态，破坏了自动机的正确性。</p>
<p><img src="/2019/10/01/Suffix-Automaton/强行插入的反例.png" alt="强行插入的反例"><br><br>　　如图所示，$v_p$含有的最长字符串是红色5个“A”，但$trans(v_p,x)=q$含有的最长字符串是蓝色7位字符串，如果在$Right(q)$中强行插入$L+1$即变为绿色部分，会使$Max(q)$从7减少到6从而丢失信息。<br><br>　　如果足够幸运，$Max(q) = Max(v_p)+1$，就没有上面的问题，我们可以在$Right(q)$中插入$L+1$，然后只要令$Pa(np)=q$即可完成自动机更新。<em>注：理论上$Right(trans(v_p\dots v_k,x))$都要插入$L+1$，但这些状态的出边都没有发生改变，而后缀自动机实际上不记录$Right$，所以更新完成。</em><br><br>　　如果没那么幸运，从图上可知，原状态$q$在插入末尾字符$x$后应转换两个状态，设蓝色对应的状态为$q’$（沿用$q$)，绿色状态为$nq$（新建节点）。显然</p>
<script type="math/tex; mode=display">
trans(q', *) = trans(q, *), \\
Pa(q')=nq，\\
Right(nq)=Right(q')\cup \{L+1\}，\\
Max(nq) = Max(v_p)+1</script><p>显然$Right(nq)$是真包含$\{L+1\}$的最小集合，所以</p>
<script type="math/tex; mode=display">Pa(np)=nq</script><p>&emsp;&emsp;截至目前我们新添了$np$，将$q$转化为$q’,nq$，其中$np,q’$都正确处理了出边和分裂树父亲。<br>那么$nq$的分裂树父亲又是谁呢？结合上图易证</p>
<script type="math/tex; mode=display">Pa(nq)=Pa(q)</script><p>$nq$的出边是哪一些？由于新添的最后一个字符不能带来更多的状态转移（最后一个字符后面再没有字符了），所以</p>
<script type="math/tex; mode=display">trans(nq, *) = trans(q, *)</script><p><br>　　最后，我们还要考虑原自动机中指向$q$的状态，和新自动机中应当指向$q’$和$nq$的状态。在$v_p,\cdots,v_k$中，由于$Right$的扩大，$Right(trans(v_i,x))$也逐渐扩大（不缩小），所以只有一段连续的$v_p,\cdots,v_e(e\le k)$是指向$q$的，由于要配合在$Right$集合中插入$L+1$，这些出边要修改为</p>
<script type="math/tex; mode=display">trans(v_i,x) = nq</script><p>其余指向$q$的状态必然由于左端有过多字符而无法指向$nq$，于是改为指向$q’$，等效于不做任何修改。<br><br>　　最后的最后，对于$v_{e+1},\cdots,v_k$，对于$nv=trans(v_i, x)$，必然可以粗暴地令$Right(nv)$插入$L+1$，所以转移关系可以保持不变，等效于不做任何修改。</p>
<h1 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">	State* go[MAXW];</span><br><span class="line">	State* pa;</span><br><span class="line">	<span class="keyword">int</span> mx;</span><br><span class="line"></span><br><span class="line">	State(<span class="keyword">int</span> MX):pa(<span class="number">0</span>), mx(MX) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	State(<span class="keyword">const</span> State* o) &#123;</span><br><span class="line">		pa = o-&gt;pa;</span><br><span class="line">		<span class="built_in">memcpy</span>(go, o-&gt;go, <span class="keyword">sizeof</span>(o-&gt;go));</span><br><span class="line">		mx = o-&gt;mx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;*last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	State* p = last;</span><br><span class="line">	State* np = <span class="keyword">new</span> State(p-&gt;mx+<span class="number">1</span>);</span><br><span class="line">	last = np;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==<span class="number">0</span>)</span><br><span class="line">		p-&gt;go[x] = np, p = p-&gt;pa;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> np-&gt;pa = root, <span class="keyword">void</span>();</span><br><span class="line"></span><br><span class="line">	State* q = p-&gt;go[x];</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;mx+<span class="number">1</span> == q-&gt;mx)</span><br><span class="line">		<span class="keyword">return</span> np-&gt;pa = q, <span class="keyword">void</span>();</span><br><span class="line"></span><br><span class="line">	State* nq = <span class="keyword">new</span> State(q);</span><br><span class="line">	nq-&gt;mx = p-&gt;mx+<span class="number">1</span>;</span><br><span class="line">	q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==q)</span><br><span class="line">		p-&gt;go[x] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, st);</span><br><span class="line"></span><br><span class="line">	last = root = <span class="keyword">new</span> State(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; st[i]!=<span class="string">'\0'</span>; ++i)</span><br><span class="line">		extend(st[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>&emsp;&emsp;SAM思路真的异常精妙，环环相扣，巧夺天工。不幸的是优美的结论是以复杂而庞大的论证为代价的。<br><br>　　被奉为圣经的<code>2012年noi冬令营陈立杰讲稿(SAM后缀自动机)</code>在描述构造过程的时候没有解释可以省略的操作为什么被省略，导致思路有很大残缺和跳跃。即使是本文也用了不少“显然”字眼，但比较原文已有较大改进。另外，原讲稿没有交代构造算法为什么是$O(n)$的。<del>疾风理解这ppt花了整整三天</del>如果本文对你有帮助，不妨赏疾风一支冰阔乐喝（馋.jpg）<br><br>　　有人说SAM完全可以当做黑盒来用，我认为不然。黑盒SAM的唯一功能是判定子串是否存在，局限性很大。而SAM的实战应用代码相对裸构造有很大增改，例如要结合dfs序，平衡树，动态树等等技巧，且都是建立在完全理解后缀自动机的基础上，难度依然很大。这部分日后再填补。</p>
<p><em>转载请注明原作者和网址</em></p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2019/09/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>不会汇编，强行刚软保，<del>瑟瑟发抖</del>稳得一匹</p>
<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="C语法"><a href="#C语法" class="headerlink" title="C语法"></a>C语法</h2><ol>
<li>指针作差得到区间元素个数。<strong>指针的类型参与计算！</strong></li>
<li>要动态改变函数体，需要在编译期赋予权限。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/section:test,RWE"</span>)</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li><code>__asm int 3</code>加入汇编断点（OD）。要在OD中启用StrongOD，禁用跳过int3；并设置测试选项</li>
<li></li>
<li></li>
</ol>
<h2 id="Windows-exe结构"><a href="#Windows-exe结构" class="headerlink" title="Windows exe结构"></a>Windows exe结构</h2><ol>
<li>401000H这个内存地址对应的文件地址是1000H</li>
</ol>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Quickview：更改EXE数据"><a href="#Quickview：更改EXE数据" class="headerlink" title="Quickview：更改EXE数据"></a>Quickview：更改EXE数据</h2><ol>
<li>按<code>F5</code>可以按地址定位</li>
<li>提供三种模式：16进制格式，汇编格式，纯文本格式；按<code>F2</code>切换到32位模式</li>
<li>按<code>Alt+F9</code>保存</li>
<li>按<code>ins</code>选择块（开始和结束各按一次），选择后按<code>shift</code>底部出现块工具</li>
<li></li>
</ol>
<h2 id="OD：单步跟踪EXE"><a href="#OD：单步跟踪EXE" class="headerlink" title="OD：单步跟踪EXE"></a>OD：单步跟踪EXE</h2><ol>
<li>可以用来追踪去壳代码</li>
<li>可以dump数据块到文件</li>
<li>可以设置硬件断点，当某储存位置发生更改时中断</li>
<li><code>Alt+B</code>管理断点，<code>空格</code>切换</li>
<li></li>
</ol>
<h2 id="IDA：静态分析EXE"><a href="#IDA：静态分析EXE" class="headerlink" title="IDA：静态分析EXE"></a>IDA：静态分析EXE</h2><ol>
<li>按<code>G</code>定位</li>
<li>可通过加壳反抗静态分析。</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="面对加壳"><a href="#面对加壳" class="headerlink" title="面对加壳"></a>面对加壳</h2><ol>
<li>用OD动态追踪，尝试还原被加壳代码（等待去壳），再用QV还原EXE（用块复制的办法加快速度）</li>
</ol>
<h2 id="面对序列号"><a href="#面对序列号" class="headerlink" title="面对序列号"></a>面对序列号</h2><ol>
<li>观察到现象：弹框并消失。可行办法：跟踪CreateWindow/ShowWindow/DestoryWindow（推荐）</li>
<li>用OD动态追踪，尝试中断DestoryWindow，观察堆栈顶端找到出栈后的程序运行位置（或直接跑retn)</li>
<li><p>对不当场判断的场合（没有明显现象） 怀疑有文件/注册表读写 <code>FileMon + RegMon = ProcMon</code></p>
<p> RegCreateKey()<br> RegQueryValue()<br> RegSetValue()</p>
<p> CreateFile<br> CreateFileEx<br> ReadFile<br> WriteFile</p>
</li>
<li><p>软件断点：当前断点指令的首字节改为<code>0xCC</code>（对应的汇编指令为int 3）。 可能被程序自检。</p>
</li>
<li><p>硬件断点：选中某条指令-&gt;断点-&gt;硬件执行。  检查已设置的断点：调试-&gt;硬件断点… 原理：CPU调试寄存器保存了断点地址和断点条件，每个周期都会检查条件。触发条件有<code>execute</code>，<code>read</code>, <code>write</code>。  要设置读/写断点，选中变量的首字节-&gt;右键-&gt;断点-&gt;硬件写入-&gt;DWORD（对应的类型）。要设置DWORD断点对变量首字节有要求。读/写完成后到达断点。<br>可以用<code>printf(&quot;%p&quot;,...)</code>知道要跟踪的变量的地址。</p>
</li>
<li><p>利用读/写硬件断点，当操作序列号时就能断住。<code>Ctrl+B</code>搜索已输入的序列号找到内存地址。跳跃几次看到<code>rep movs</code>（字符串拷贝），此时取消断点，回到用户代码，跳出几次，看到getText</p>
</li>
<li>如果进入系统代码，则应跳出到用户代码<code>Alt+F9</code>，再按<code>Ctrl+F9</code>跳出一些函数。</li>
<li><code>CallWindowProcA</code>的作用是由系统内核来回调用户事先写的消息处理函数</li>
</ol>
<h1 id="汇编规则"><a href="#汇编规则" class="headerlink" title="汇编规则"></a>汇编规则</h1><ol>
<li>cdq edx:eax, idiv, edx = edx:eax %n</li>
</ol>
<h1 id="逆向工程历史"><a href="#逆向工程历史" class="headerlink" title="逆向工程历史"></a>逆向工程历史</h1><ol>
<li>微软开发<code>debug</code>，<code>codeview</code>, 宝蓝开发<code>TurboDebug</code>;</li>
</ol>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ol>
<li><code>debug</code> 编程：a(assemble) 地址+汇编语言，偏移地址固定从100开始   (OD中改指令相当于a，若下一条语句实效，会有安全措施，改90NULL)。</li>
<li>u(unassemble) 反汇编，指定开始地址和末地址（l+长度亦可)，反汇编对应地址内的机器语言。</li>
<li>r(register) 查看寄存器 SF+PL-NG UP上DN下.  r + 寄存器名字, 修改内存</li>
<li>p (optional 地址) 单步前进，目标地址是执行完毕的</li>
<li>g (optional =首地址 (optional) 末地址) (从csip)跳跃直到int 3(末地址是未执行的);</li>
<li>d(dump) 查看内存 可以指定(d cs:100 120 || d cs:100 l20)</li>
<li>e(edit) 修改内存 地址 + “string” || hex</li>
<li>t(track in)</li>
</ol>
<h2 id="加密软件"><a href="#加密软件" class="headerlink" title="加密软件"></a>加密软件</h2><ol>
<li><code>lock89</code>, <code>lockup</code>, 作者：杨道沅, 硬盘指纹加密技术</li>
<li><code>lock93</code>, <code>lock93NT</code>, 周辉</li>
<li><code>BitLock</code>, 雷军</li>
</ol>
<h1 id="驻留内存程序"><a href="#驻留内存程序" class="headerlink" title="驻留内存程序"></a>驻留内存程序</h1><h2 id="需要技术"><a href="#需要技术" class="headerlink" title="需要技术"></a>需要技术</h2><ol>
<li>驻留内存</li>
<li>中断</li>
</ol>
<p><code>es:[bx]</code> 0:32是一个中断向量的地址</p>
<p>0:0 ~ 0:3FF 是中断向量表，每个中断向量占用4字节。 例如<code>int 00h</code>的中断向量储存在0:0 ~ 0:3之间; <code>int 01h</code>的中断向量储存在0:4 ~ 0:7之间。</p>
<p>当cpu执行<code>int 00h</code>时：<br>pushf 保护当前标志位（flag）的状态<br>push cs 当前短地址<br>push 下条指令的偏移地址<br>cli<br>jmp 8756h:3412h</p>
<p>8756h:3412h 是中断服务程序的入口地址<br>    ……<br>    iret; 中断返回</p>
<p>当cpu执行<code>iret</code>时：<br>pop ip;<br>pop cs;<br>popf;       从而实现恢复现场。</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>在ACM中使用C++</title>
    <url>/2019/08/28/%E5%9C%A8ACM%E4%B8%AD%E4%BD%BF%E7%94%A8C/</url>
    <content><![CDATA[<p>今天又双叒叕来水博客了……（不务正业）</p>
<h1 id="令人尖叫的STL"><a href="#令人尖叫的STL" class="headerlink" title="令人尖叫的STL"></a>令人尖叫的STL</h1><h2 id="algorithm-系列"><a href="#algorithm-系列" class="headerlink" title="algorithm 系列"></a><strong>algorithm</strong> 系列</h2><h3 id="fill-fill-n-填充数组"><a href="#fill-fill-n-填充数组" class="headerlink" title="fill, fill_n 填充数组"></a><strong>fill</strong>, <strong>fill_n</strong> 填充数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fill(a, a+n, INF);</span><br><span class="line">fill_n(a, n, INF);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="unique-unique-copy-对排序后数组去重"><a href="#unique-unique-copy-对排序后数组去重" class="headerlink" title="unique, unique_copy 对排序后数组去重"></a><strong>unique</strong>, <strong>unique_copy</strong> 对排序后数组去重</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a, a+n);</span><br><span class="line">unique_copy(a, a+n, b, 重载==);</span><br><span class="line">unique(a, a+n, 重载==);</span><br></pre></td></tr></table></figure>
<h3 id="reverse-reverse-copy-镜像翻转数组"><a href="#reverse-reverse-copy-镜像翻转数组" class="headerlink" title="reverse, reverse_copy 镜像翻转数组"></a><strong>reverse</strong>, <strong>reverse_copy</strong> 镜像翻转数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reverse_copy(a, a+n, b);</span><br><span class="line">reverse(a, a+n);</span><br></pre></td></tr></table></figure>
<h3 id="rotate-rotate-copy-数组轮换"><a href="#rotate-rotate-copy-数组轮换" class="headerlink" title="rotate, rotate_copy 数组轮换"></a><strong>rotate</strong>, <strong>rotate_copy</strong> 数组轮换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">rotate_copy(a, a+<span class="number">2</span>, a+<span class="number">6</span>, b); <span class="comment">// b == &#123;3, 4, 5, 6, 1, 2&#125;</span></span><br><span class="line">rotate(a, a+<span class="number">5</span>, a+<span class="number">6</span>); <span class="comment">// a == &#123;6, 1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle-随机打乱数组"><a href="#random-shuffle-随机打乱数组" class="headerlink" title="random_shuffle 随机打乱数组"></a><strong>random_shuffle</strong> 随机打乱数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">random_shuffle(a, a+n);</span><br></pre></td></tr></table></figure>
<h3 id="partial-sort-数组一次性取前k小"><a href="#partial-sort-数组一次性取前k小" class="headerlink" title="partial_sort 数组一次性取前k小"></a><strong>partial_sort</strong> 数组一次性取前k小</h3><p>时间复杂度$n \log m$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">partial_sort(a, a+k, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure></p>
<h3 id="partition-partition-copy-元素分成两组"><a href="#partition-partition-copy-元素分成两组" class="headerlink" title="partition, partition_copy 元素分成两组"></a><strong>partition</strong>, <strong>partition_copy</strong> 元素分成两组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point* mid = partition(p, p+n, [o1, o2](<span class="keyword">const</span> Point&amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> (o2-o1).det(a-o1) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 以直线(o1, o2)为界将平面上的点划分成两组</span></span><br></pre></td></tr></table></figure>
<p>还有<code>stable_partition</code>版本</p>
<h3 id="merge-inplace-merge-归并数组"><a href="#merge-inplace-merge-归并数组" class="headerlink" title="merge, inplace_merge 归并数组"></a><strong>merge</strong>, <strong>inplace_merge</strong> 归并数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求分别有序</span></span><br><span class="line">merge(a, a+aLen, b, b+bLen, c, 重载&lt;); <span class="comment">// 非原地合并</span></span><br><span class="line">inplace_merge(a, a+mid+<span class="number">1</span>, a+aLen, 重载&lt;); <span class="comment">// 原地合并</span></span><br></pre></td></tr></table></figure>
<h3 id="equal-range-找到存在区间"><a href="#equal-range-找到存在区间" class="headerlink" title="equal_range 找到存在区间"></a><strong>equal_range</strong> 找到存在区间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a, a+n);</span><br><span class="line"><span class="comment">// 等价于使用lower_bound和upper_bound</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>*, <span class="keyword">int</span>*&gt; bounds = equal_range(a, a+n, <span class="number">10</span>, 重载&lt;);</span><br></pre></td></tr></table></figure>
<h3 id="make-heap-O-n-建堆"><a href="#make-heap-O-n-建堆" class="headerlink" title="make_heap O(n)建堆"></a><strong>make_heap</strong> O(n)建堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make_heap(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>
<h3 id="sort-heap-对堆排序"><a href="#sort-heap-对堆排序" class="headerlink" title="sort_heap 对堆排序"></a><strong>sort_heap</strong> 对堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make_heap(a, a+n, 重载&lt;);</span><br><span class="line">sort_heap(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>
<h3 id="push-heap-堆加入一个元素"><a href="#push-heap-堆加入一个元素" class="headerlink" title="push_heap 堆加入一个元素"></a><strong>push_heap</strong> 堆加入一个元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[n++] = <span class="number">666</span>;</span><br><span class="line">push_heap(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>
<h3 id="pop-heap-堆删除顶端元素"><a href="#pop-heap-堆删除顶端元素" class="headerlink" title="pop_heap 堆删除顶端元素"></a><strong>pop_heap</strong> 堆删除顶端元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pop_heap(a, a+n--, 重载&lt;);</span><br></pre></td></tr></table></figure>
<h3 id="lexicographical-compare-字典序小于"><a href="#lexicographical-compare-字典序小于" class="headerlink" title="lexicographical_compare 字典序小于"></a><strong>lexicographical_compare</strong> 字典序小于</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lexicographical_compare(s1, s1+len1, s2, s2+len2))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1 &lt; s2\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="next-permutation-prev-permutation-求下一排列"><a href="#next-permutation-prev-permutation-求下一排列" class="headerlink" title="next_permutation, prev_permutation 求下一排列"></a><strong>next_permutation</strong>, <strong>prev_permutation</strong> 求下一排列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">prev_permutation(a, a+<span class="number">5</span>);</span><br><span class="line">next_permutation(a, a+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Containers-系列"><a href="#Containers-系列" class="headerlink" title="Containers 系列"></a><strong>Containers</strong> 系列</h2><p><em>用到烂的知识点就不多提了。这里只写容易忘的。</em></p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a><strong>bitset</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>bitset&lt;size_t N&gt; foo(int);</code></li>
<li><code>bitset&lt;size_t N&gt; foo(std::string);</code></li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>长度在编译期确定</li>
<li>高位在左，低位在右</li>
<li>重载的方括号可以直接读取、操作位</li>
</ol>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li><code>size_t count()</code> 返回1的个数</li>
<li><code>bool test(size_t pos)</code> 返回非引用的<code>foo[pos]</code></li>
<li><code>bool any()</code> 是否有1</li>
<li><code>bool none()</code> 是否全0</li>
<li><code>bool all()</code> 是否全1</li>
<li><code>bitset&amp; set()</code>  全部位设置为1</li>
<li><code>bitset&amp; set(size_t pos, bool val=true)</code> 设置某个位</li>
<li><code>bitset&amp; reset()</code> 全部设置为0  （也可有参数pos）</li>
<li><code>bitset&amp; flip()</code> 反转全部位  （也可有参数pos）</li>
<li><code>string to_string(char zero, char one)</code> 按要求转化为string</li>
<li><code>unsigned long to_ulong()</code> 转化为UL</li>
<li><code>ULL to_ullong</code> 转化为ULL （C++11）</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>map&lt;type1, type2&gt; mymap;</code></li>
<li><code>map&lt;type1, type2&gt; mymap({})</code></li>
</ol>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部用平衡树实现</li>
<li>不允许重复的Key</li>
<li>访问必须用迭代器 <code>map&lt;type1, type2&gt;::iterator it;</code></li>
<li><code>it-&gt;first</code> 是Key，不可更变，<code>it-&gt;second</code> 是Value，可以修改。</li>
<li>查找元素必须用<code>it = mymap.find(Key)</code>，失败则返回<code>mymap.end();</code></li>
</ol>
<h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>重载方括号，若Key不存在则建立Key对应的默认构造Value。返回Value的引用。</li>
<li><code>insert()</code> 比较复杂，常用例子：<code>mp.insert(pair&lt;char, int&gt;(&#39;a&#39;, 1));</code></li>
<li><code>iterator begin()</code> 指向头元素的迭代器 （rbegin()指向最后一个元素）</li>
<li><code>iterator end()</code> 指向尾元素的后一个迭代器（rend()指向头元素的前一个迭代器）</li>
<li><code>iterator find(Key)</code> 返回Key对应的迭代器，失败则返回end()。</li>
<li><code>clear()</code> 清空所有键值对，size归零。</li>
<li><code>size_type erase (const key_type&amp; k);</code> 删除Key对应的键值对，返回删除个数</li>
<li><code>iterator erase (const_iterator position);</code> 删除迭代器指向的键值对，返回紧接下一个键值对的迭代器。</li>
<li><code>iterator erase (const_iterator first, const_iterator last);</code> 删除迭代器指向的左闭右开区间的键值对，返回紧接着下一个键值对的迭代器（或<code>end()</code>）。</li>
<li>注意，C++98中<code>erase()</code>不会返回迭代器，而是返回void</li>
<li><code>iterator lower_bound (const key_type&amp; k);</code> 所在上界迭代器</li>
<li><code>iterator upper_bound (const key_type&amp; k);</code> 所在下界迭代器</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><p>结点只有一个元素，不允许重复的红黑树。</p>
<h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>迭代器begin(), end(), rbegin(), rend().</li>
<li>容量empty(), size();</li>
<li>插入<ul>
<li><code>pair&lt;iterator, bool&gt; insert(const value_type&amp; val);</code> 同时有非const的右值引用版本。</li>
<li>返回的pair包括一个指向被插入值的迭代器，bool指明是否真的发生了插入操作。（如果元素被来就存在，就为false）</li>
</ul>
</li>
<li>删除<ul>
<li><code>iterator erase(const_iterator position);</code> 删除指定迭代器位置的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>iterator erase(const_iterator first, cosnt_iterator last);</code> 删除指定迭代器的左闭右开区间的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>size_type erase(const value_type&amp; val);</code> 删除指定的值。 返回被删除的元素个数（0或1）。</li>
</ul>
</li>
<li>交换 <code>swap(set&amp; x);</code> 交换两个类型相同的set。</li>
<li>清空 <code>clear();</code></li>
<li>查找 <code>iterator find(const value_type&amp; val);</code></li>
<li>计数 <code>size_type count(const value_type&amp; val) const;</code></li>
<li>上下界（左闭右开）<ul>
<li><code>iterator lower_bound (const value_type&amp; val);</code></li>
<li><code>iterator upper_bound (const value_type&amp; val);</code></li>
<li><code>pair&lt;iterator,iterator&gt; equal_range (const value_type&amp; val);</code> 包括了下界和上界。</li>
</ul>
</li>
</ol>
<h2 id="C标准库-系列"><a href="#C标准库-系列" class="headerlink" title="C标准库 系列"></a><strong>C标准库</strong> 系列</h2><h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a><strong>assert</strong> 断言</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert(<span class="keyword">this</span>-&gt;ch[<span class="number">0</span>]-&gt;fa == <span class="keyword">this</span>);</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;ch[<span class="number">1</span>]-&gt;fa == <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="comment">// NDEBUG 标记可删除assert</span></span><br></pre></td></tr></table></figure>
<h3 id="isdigit-判断字符是否十进制数"><a href="#isdigit-判断字符是否十进制数" class="headerlink" title="isdigit 判断字符是否十进制数"></a><strong>isdigit</strong> 判断字符是否十进制数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar()))</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="string">'-'</span>) minus = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="泯灭人性的数据类型"><a href="#泯灭人性的数据类型" class="headerlink" title="泯灭人性的数据类型"></a>泯灭人性的数据类型</h1><h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">估计范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">±2e9</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">±3e4</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
<td style="text-align:center">保有127</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">37数量级，7位</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">307数量级，15位</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">16</td>
<td style="text-align:center">4931数量级，20位</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9e18</td>
</tr>
<tr>
<td style="text-align:center">__int128_t</td>
<td style="text-align:center">16</td>
<td style="text-align:center">8.5e37</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>计算struct内存时要小心！最好使用<code>sizeof</code>的方式计算内存。</p>
</blockquote>
<h2 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf"></a>scanf和printf</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">%u %o(8进制) %x(16进制)</td>
</tr>
<tr>
<td style="text-align:center">unsigned long long</td>
<td style="text-align:center">%llu</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">入%lf，出%f</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">%Lf</td>
</tr>
<tr>
<td style="text-align:center">__int128_t</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
</div>
<h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><p>gets()已经被删除。</p>
<p>读入int之类的操作不会吃掉行末，这会导致下一个<code>getline(st, size)</code>得到空串。</p>
<p>保险起见，应当自定义读入行。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>.vimrc</title>
    <url>/2019/08/25/vimrc/</url>
    <content><![CDATA[<h2 id="vimrc-amp-Font"><a href="#vimrc-amp-Font" class="headerlink" title=".vimrc &amp; Font"></a>.vimrc &amp; Font</h2><p><a href="vimrc/null.vimrc">.vimrc</a></p>
<p><a href="vimrc/FiraCode-Retina.ttf">Fira Code Retina</a><br><a id="more"></a></p>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>For 8+ version.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span></span><br><span class="line"><span class="comment">" the call to :runtime you can find below.  If you wish to change any of those</span></span><br><span class="line"><span class="comment">" settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span></span><br><span class="line"><span class="comment">" will be overwritten everytime an upgrade of the vim packages is performed.</span></span><br><span class="line"><span class="comment">" It is recommended to make changes after sourcing debian.vim since it alters</span></span><br><span class="line"><span class="comment">" the value of the 'compatible' option.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" This line should not be removed as it ensures that various options are</span></span><br><span class="line"><span class="comment">" properly set to work with the Vim-related packages available in Debian.</span></span><br><span class="line">runtime! debian.<span class="keyword">vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span></span><br><span class="line"><span class="comment">" This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span></span><br><span class="line"><span class="comment">" any settings in these files.</span></span><br><span class="line"><span class="comment">" If you don't want that to happen, uncomment the below line to prevent</span></span><br><span class="line"><span class="comment">" defaults.vim from being loaded.</span></span><br><span class="line"><span class="comment">" let g:skip_defaults_vim = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Uncomment the next line to make Vim more Vi-compatible</span></span><br><span class="line"><span class="comment">" <span class="doctag">NOTE:</span> debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous</span></span><br><span class="line"><span class="comment">" options, so any other options should be set AFTER setting 'compatible'.</span></span><br><span class="line"><span class="comment">"set compatible</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Vim5 and later versions support syntax highlighting. Uncommenting the next</span></span><br><span class="line"><span class="comment">" line enables syntax highlighting by default.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">"syntax"</span>)</span><br><span class="line">  <span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" If using a dark background within the editing area and syntax highlighting</span></span><br><span class="line"><span class="comment">" turn on this option as well</span></span><br><span class="line"><span class="keyword">set</span> background=dark</span><br><span class="line"></span><br><span class="line"><span class="comment">" Uncomment the following to have Vim jump to the last position when</span></span><br><span class="line"><span class="comment">" reopening a file</span></span><br><span class="line"><span class="string">"if has("</span><span class="keyword">autocmd</span><span class="comment">")</span></span><br><span class="line"><span class="string">"  au BufReadPost * if line("</span><span class="string">'\"") &gt; 1 &amp;&amp; line("'</span>\<span class="string">""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>) | <span class="keyword">exe</span> <span class="string">"normal! g'\""</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="comment">"endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Uncomment the following to have Vim load indentation rules and plugins</span></span><br><span class="line"><span class="comment">" according to the detected filetype.</span></span><br><span class="line"><span class="string">"if has("</span><span class="keyword">autocmd</span><span class="comment">")</span></span><br><span class="line"><span class="comment">"  filetype plugin indent on</span></span><br><span class="line"><span class="comment">"endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" The following are commented out as they cause vim to behave a lot</span></span><br><span class="line"><span class="comment">" differently from regular Vi. They are highly recommended though.</span></span><br><span class="line"><span class="keyword">set</span> showcmd		<span class="comment">" Show (partial) command in status line.</span></span><br><span class="line"><span class="keyword">set</span> showmatch		<span class="comment">" Show matching brackets.</span></span><br><span class="line"><span class="keyword">set</span> ignorecase		<span class="comment">" Do case insensitive matching</span></span><br><span class="line"><span class="keyword">set</span> smartcase		<span class="comment">" Do smart case matching</span></span><br><span class="line"><span class="string">"set incsearch		"</span> Incremental <span class="built_in">search</span></span><br><span class="line"><span class="keyword">set</span> autowrite		<span class="comment">" Automatically save before commands like :next and :make</span></span><br><span class="line"><span class="keyword">set</span> hidden		<span class="comment">" Hide buffers when they are abandoned</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span>		<span class="comment">" Enable mouse usage (all modes)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> autoread</span><br><span class="line"></span><br><span class="line"><span class="comment">" Source a global configuration file if available</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">"/etc/vim/vimrc.local"</span>)</span><br><span class="line">  <span class="keyword">source</span> /etc/<span class="keyword">vim</span>/vimrc.local</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">call</span> CompileCPP()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! CompileCPP()</span><br><span class="line">	exec <span class="string">"w"</span></span><br><span class="line">	<span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">'cpp'</span></span><br><span class="line">		exec <span class="string">'!g++ -Wall -DDEBUG % -o %&lt;'</span></span><br><span class="line">	<span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> RunOUT()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! RunOUT()</span><br><span class="line">	exec <span class="string">'!./%&lt;'</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>
<h2 id="ps-bashrc"><a href="#ps-bashrc" class="headerlink" title="ps. bashrc"></a>ps. bashrc</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">TEXT::</span><br><span class="line">terminal size : <span class="number">90</span> * <span class="number">34</span></span><br><span class="line"></span><br><span class="line">custom font Fira Code Retina <span class="number">14</span></span><br><span class="line">Cell spaceing <span class="number">1.00</span> <span class="number">1.00</span></span><br><span class="line"></span><br><span class="line">Cursor : Block, Default</span><br><span class="line"></span><br><span class="line">COLORS::</span><br><span class="line">Custom::</span><br><span class="line">	Default: <span class="meta">#D3D7CF, #020F20</span></span><br><span class="line">	Bold: disabled</span><br><span class="line">	Cursor: <span class="meta">#FFFFFF, #0350C9</span></span><br><span class="line">	Hightlight: disabled</span><br><span class="line">	palette: (Tango), blue: <span class="meta">#4A7DBE #7EA9D6</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化DP</title>
    <url>/2019/08/25/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="单状态的斜率优化"><a href="#单状态的斜率优化" class="headerlink" title="单状态的斜率优化"></a>单状态的斜率优化</h2><p>写出状态转移方程，形如：</p>
<script type="math/tex; mode=display">f[j]=\max_{i=1}^{j-1} \{ F_1(j)+F_2(i)+F_3(i,j)\}</script><p>由于$F_3$涉及i和j，若枚举两个变量会超时。</p>
<p>化简方程，得到<br><a id="more"></a></p>
<script type="math/tex; mode=display">f[j]=\max_{i=1}^{j-1} \{F_2(i)+F_4(j)*F_5(i) \} + const(j)</script><p>这里涉及的每个函数都能事先算出。于是求最大值转化为线性规划：将$f[j]$看作b，$F_2(i)$看作y，$-F_4(j)$看作k，$F_5(i)$看作x，则形式可转化为$b=y-kx$，求b的最大值。维护可能的点队列，则这是一条上凸线，用二分找到最相近斜率的线段的对应点即可。</p>
<p>某些题目的$F_4(j)$具有单调性，即目标直线的斜率有单调性，则可用朴素单调队列代替二分。</p>
<p>也可以将max改成min，这时求最小的b，维护下凸线即可。</p>
<h2 id="双状态的斜率优化"><a href="#双状态的斜率优化" class="headerlink" title="双状态的斜率优化"></a>双状态的斜率优化</h2><p>拓展单状态下的方程，形如：</p>
<script type="math/tex; mode=display">f(j,k]=\max_{i=1}^{j} \{ F_1(j,k]+F_2(i,j]+F_3(i,j,k)\}</script><p>同样化简方程，得到</p>
<script type="math/tex; mode=display">f(j,k]=\max_{i=1}^{j} \{ F_2(i,j]+F_4(i)*F_5(j,k]\} + const(j,k]</script><p>类似地令$F_4(i)$为横坐标x，待求的$f(j,k]$看作截距b，$F_2(i,j]$看作纵坐标y构建线性规划。之后的步骤同上。</p>
<p>斜率优化的目的是减少枚举前驱状态的时间，用O(1)或O(log n)完成状态转移。这将要求在完成状态计算后，将新获得的点加入凸线中。加点后，视情况选择是否维护凸性。<br>对于双状态的题目，不同的j对应不同的凸线（这是因为$F_2(i,j]$会随j变化，即点的坐标会变化）。应当判断对于同一个j、不同的k，能否从同一条凸线得到答案。</p>
<p>如果加点操作的横坐标具有非单调性，可能需要数据结构支持二分查找、中间加点、中间删点的操作。如果不需要即时维护，可以用排序完成维护。</p>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2019/08/20/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="求-L-R-中满足-y-geq-x-且y-x-x-oplus-y-的数对-x-y-的个数"><a href="#求-L-R-中满足-y-geq-x-且y-x-x-oplus-y-的数对-x-y-的个数" class="headerlink" title="求$[L,R]$中满足$y\geq x,且y\%x=x\oplus y$的数对$(x,y)$的个数"></a>求$[L,R]$中满足$y\geq x,且y\%x=x\oplus y$的数对$(x,y)$的个数</h2><a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>题目涉及位操作，对所有数以二进制看待。x和y的最高位应相同，这是因为$y\%x&lt;x$，其二进制最高位有限制。</li>
<li>两数最高位相同，则y不超过x的两倍。$y\%x = y-x = y\oplus x$。</li>
<li>$y-x$不可能退位。由$y\geq x$找到两者不同的最高位（y一定是1，x一定是0），这一位异或和为1，若低位退位，则差为0，矛盾，故低位不能退位。由低位不能退位，分类讨论$1-0, 1-1, 0-0$三种情况，发现更低位也不能退位，由归纳法可知$y-x$不可能退位。</li>
<li>综上，以bitset看待，$x\subseteq y$。</li>
<li>考虑记忆化搜索。$x,y$都受到上下界限制，且$y\geq x$，故分别dp枚举$x,y$的合法取值。另外要记录状态保证$x,y$的最高位相同。</li>
</ol>
<script type="math/tex; mode=display">
设f[pos][xDown][xUp][yUp][lead]\\
表示第pos位之后，x是否压下界，x是否压上界，y是否压上界，xy是否取过最高位时的合法方案数</script><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ULL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">bool</span> xDown, <span class="keyword">bool</span> xUp, <span class="keyword">bool</span> yUp, <span class="keyword">bool</span> lead)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ULL &amp;res = ans[pos][xDown][xUp][yUp][lead];</span><br><span class="line">	<span class="keyword">if</span> (res != <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> xLow = xDown ? L[pos] : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> xHigh = xUp ? R[pos] : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> yHigh = yUp ? R[pos] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=xLow; i&lt;=xHigh; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;=yHigh; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lead &amp;&amp; i!=j) <span class="keyword">continue</span>;</span><br><span class="line">			res += dfs(pos<span class="number">-1</span>, xDown&amp;&amp;i==xLow, xUp&amp;&amp;i==xHigh, yUp&amp;&amp;j==yHigh, lead&amp;&amp;i==<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res %= MOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>初等数论</title>
    <url>/2019/08/02/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="模方程"><a href="#模方程" class="headerlink" title="模方程"></a>模方程</h1><h2 id="基础性质"><a href="#基础性质" class="headerlink" title="基础性质"></a>基础性质</h2><h3 id="模的等价关系"><a href="#模的等价关系" class="headerlink" title="模的等价关系"></a>模的等价关系</h3><p><strong>自反性</strong></p>
<script type="math/tex; mode=display">a\equiv a \mod m</script><p><strong>对称性</strong></p>
<script type="math/tex; mode=display">a\equiv b \mod m\Leftrightarrow b\equiv a \mod m</script><a id="more"></a>
<p><strong>传递性</strong></p>
<script type="math/tex; mode=display">
a\equiv c \mod m, c\equiv b\mod m \Rightarrow a\equiv b \mod m</script><h3 id="等式的性质"><a href="#等式的性质" class="headerlink" title="等式的性质"></a>等式的性质</h3><p><strong>可加减性</strong></p>
<script type="math/tex; mode=display">
模m意义下\\
a\equiv b, c\equiv d \Rightarrow a+c\equiv b+d</script><p><strong>可乘性</strong></p>
<script type="math/tex; mode=display">
模m意义下\\
a\equiv b, c\equiv d \Rightarrow ac\equiv bd</script><blockquote>
<p>证明：设$a-b=km$, $c-d=lm$. 则$a=b+km$, $c=d+lm$, $ac=klm^2+(bl+ck)m+bd$, 显然$m|(ac-bd)$</p>
<p>推论：模$m$意义下,$a\equiv b \Rightarrow an\equiv bn$, $n$是自然数</p>
</blockquote>
<p><strong>消去律</strong>（乘法逆元的充要条件）</p>
<script type="math/tex; mode=display">
模m意义下\\
ac\equiv bc, gcd(c,m)=1 \Rightarrow a\equiv b</script><blockquote>
<p>证明：m|c(a-b), 因为c,m公因子为1，所以m|(a-b).</p>
</blockquote>
<p><strong>幂保持恒等</strong></p>
<script type="math/tex; mode=display">
模m意义下\\
a\equiv b \Rightarrow a^n\equiv b^n</script><p><strong>恒等的最大空间</strong></p>
<script type="math/tex; mode=display">
a\equiv b \mod m_1\\
a\equiv b \mod m_2\\
\dotsm \\
a\equiv b \mod m_n \\
\Downarrow \\
a\equiv b \mod lcm(m_1, m_2,\dotsm, m_n);</script><blockquote>
<p>证明：(a-b)是$m_1,m_2,\dotsm,m_n$的倍数，而lcm包含了所有质因子的最大次幂。</p>
<p>推论：若$m_1,m_2,\dotsm,m_n$互质，则$a\equiv b \mod m_1m_2\dotsm m_n;$</p>
</blockquote>
<p><strong>换模的另一种途径</strong></p>
<script type="math/tex; mode=display">
a\equiv b \mod c \\
\Downarrow \\
ad \equiv bd \mod cd</script><blockquote>
<p>证明：$c|(a-b)\Rightarrow cd|d(a-b)$。</p>
</blockquote>
<h2 id="高级定理"><a href="#高级定理" class="headerlink" title="高级定理"></a>高级定理</h2><h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><script type="math/tex; mode=display">
gcd(a,b)是a,b的线性组合。即存在整数x,y,使得xa+yb=gcd(a,b).</script><blockquote>
<p>证明：</p>
<p>当$a=b$时结论显然成立。</p>
<p>当$a\neq b$时，不妨设$a\neq0$，取$d$为$a,b$的所有线性组合中最小的正整数。作带余除法$a=qd+r$，则$0\leq r&lt;d$. 若$r\neq 0$,则$r=a-qd$是比d更小的线性组合，与假设矛盾,所以$r=0$,$d$是$a$的因子;同理可得$d$是$b$的因子,故$d$是$a,b$的公因子.取$c$为$a,b$的任意公因子,对$d=(xa+yb)$提取$c$得$d=c(xa’+yb’)$,可知$c$是$d$的因子,所以$|c|\leq d$,故$d=gcd(a,b)$.</p>
</blockquote>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><script type="math/tex; mode=display">
有线性同余方程组\\
x\equiv a_1 \mod m_1\\
x\equiv a_2 \mod m_2\\
\dotsm \\
x\equiv a_3 \mod m_n \\
其中m_i两两互质，则在模M=m_1m_2\dotsm m_n意义下解有且只有一个。\\
构造方法如下：
设M_i为\frac{M}{m_i}，在模m_i意义下M_i的逆为t_i。则\\
x=\sum_{i=1}^{n} a_it_iM_i</script><blockquote>
<p>证明：</p>
<p>构造解$x$的正确性。对于方程$i$,$\quad t_iM_i\equiv 1 \mod m_i, M_j\equiv 0 \mod m_i$。所以解满足每一条方程式。</p>
<p>在模$M$意义下解的唯一性。令$x_1,x_2$为方程组的两个不同的解,则$(x_1-x_2)$分别是$m_1,m_2\dotsm m_n$的倍数，则$|(x_1-x_2)|\geq M$，则在模$M$意义下解是唯一的。</p>
</blockquote>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>m的化简剩余系（又称既约剩余系，缩系），<strong>本文记为$Z_m$</strong></p>
<script type="math/tex; mode=display">
m的剩余系中与m互质的数构成的子集</script><p>欧拉函数$\phi(n)$</p>
<script type="math/tex; mode=display">
m的化简剩余系的元素个数，即|Z_m|</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p>对于质数$p$，$\phi(p)=p-1$ </p>
</li>
<li><p>对于质数$p$，$\phi(p^k)=p^{k-1}(p-1)$</p>
<blockquote>
<p>证明：在$[1,p^k]$中，不与$p^k$互质的有$\{p,2p,3p,\dotsc,p^k\}$共$\frac{p^k}{p}=p^{k-1}$个数，则互质的有$p^k-p^{k-1}=p^{k-1}(p-1)$个数。</p>
</blockquote>
</li>
<li><p><strong>欧拉函数是积性函数</strong>，即对于互质的两数$m_1,m_2$，有$\phi(m_1m_2)=\phi(m_1)\phi(m_2)$</p>
</li>
</ol>
<blockquote>
<p>证明：设$a\in Z_{m_1}, b\in Z_{m_2}$，则有同余方程组</p>
<script type="math/tex; mode=display">N \equiv a \mod m_1\\
N \equiv b \mod m_2\\</script><p>其中$a,m_1$互质，$b,m_2$互质，$m_1,m_2$互质。则N在模$m_1m_2$下有且仅有唯一解$N=am_2^{-1}m_2+bm_1^{-1}m_1$，显然$N$与$m_1,m_2$都互质，故与$m_1m_2$互质，$N\in Z_{m_1m_2}$。对任意的$N\in Z_{m_1m_2}$，其对应的$(a,b)$也是唯一的。综上，映射$Z_{m_1m_2}\rightarrow Z_{m_1}\times Z_{m_2}$是满射也是单射，则此映射是双射，故$|Z_{m_1m_2}|=|Z_{m_1}||Z_{m_2}|$，即$\phi(m_1m_2)=\phi(m_1)\phi(m_2)$。</p>
</blockquote>
<ol>
<li>对于质数$p$，且$p|a$，则$\phi(ap)=\phi(a)p$</li>
</ol>
<blockquote>
<p>证明：提取$a$的所有p因子得$ap=a’p^xp=a’p^{x+1}$，由积性函数得</p>
<script type="math/tex; mode=display">\begin{aligned}
  \phi(ap)=&\phi(a')\phi(p^{x+1}) \\
  =&\phi(a')p^x(p-1)\\
  =&\phi(a')p^{x-1}(p-1)p\\
  =&\phi(a')\phi(p^x)p\\
  =&\phi(a'p^x)p\\
  =&\phi(a)p
\end{aligned}</script></blockquote>
<ol>
<li>欧拉函数通项<script type="math/tex; mode=display">
令\{p_1,p_2,\dotsc,p_m\}为n的所有质因子\\
\phi(n)=n\prod_{i=1}^m(1-\frac{1}{p_i})</script></li>
</ol>
<blockquote>
<p>证明：</p>
<script type="math/tex; mode=display">\begin{aligned}
  设n=&\prod_{i=1}^mp_i^{x_i}\\
  由积性&函数得\\
  \phi(n)=&\prod_{i=1}^{m}\phi(p_i^{x_i})\\
  =&\prod_{i=1}^{m}p_i^{x_i}(1-\frac{1}{p_i})\\
  =&n\prod_{i=1}^m(1-\frac{1}{p_i})
  \end{aligned}</script></blockquote>
<ol>
<li>$\phi(n)(n&gt;2)$是偶数</li>
</ol>
<blockquote>
<p>证明：由欧几里得算法可知$\forall i \in [1,n]$且$i$与n互质，则$(n-i)$也与$n$互质。并且$i \neq (n-i)$，这是因为若相等，有$2i=n$，此时$i(i&gt;1)$不与$n$互质。所以与$n$互质的数成对出现，$\phi(n)(n&gt;2)$是偶数。</p>
</blockquote>
<ol>
<li><strong>质因子的次数不超过欧拉函数值</strong><script type="math/tex; mode=display">
设n=p^xs，其中gcd(p,s)=1，则x\leq \phi(n)</script></li>
</ol>
<blockquote>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi(n)=&\phi(p^x)\phi(s) \\
\geq& \phi(p^x) = p^{x-1}(p-1)
\end{aligned}\\
下面证明x\leq p^{x-1}(p-1)</script><p>取$p=2$，验证得当$x=1,2,3$时不等式都成立。由归纳法可知$p=2$时不等式成立。取$p&gt;2$，等式左边不变，右边变大，不等式仍成立。</p>
</blockquote>
<ol>
<li>$\sum\limits_{d|n}\phi(d) = n$</li>
</ol>
<blockquote>
<p>证明：$\forall k \in [1,n]$，对应有一个$d=gcd(k,n)$。所有可能的$d$取遍了$n$的所有因子。对$d|n$，考虑其对应的$k$，不妨设$k=k_1d,n=k_2d，且gcd(k_1,k_2)=1,那么k_1\leq k_2$。显然$k_2=\frac{n}{d}$是固定的，那么可能的$k_1$的取值有$\phi(k_2)=\phi(\frac{n}{d})$种。所以</p>
<script type="math/tex; mode=display">
n=\sum\limits_{d|n}\phi(\frac{n}{d})=\sum\limits_{d|n}\phi(d)</script></blockquote>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><script type="math/tex; mode=display">
对于互质的两个数a,n有\\
a^{\phi(n)} \equiv 1 \mod n</script><blockquote>
<p>证明：设$Z_n=\{x_1,x_2,\dotsc,x_{\phi(n)}\}$，因$a,n互质$，则$ax_i \mod n \in Z_n$；而对$x_i\neq x_j$，由消去律有$ax_i\neq ax_j \mod n$。故模n意义下$Z_n=\{ax_1,ax_2,\dotsc,ax_{\phi(n)}\}$。</p>
<p>故</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{\phi(n)}x_i \equiv \prod_{i=1}^{\phi(n)}ax_i \mod n\\</script><p>由消去律得</p>
<script type="math/tex; mode=display">
a^{\phi(n)} \equiv 1 \mod n</script><p>推论：<strong>费马小定理</strong>。</p>
</blockquote>
<h3 id="扩展欧拉定理（欧拉降幂）"><a href="#扩展欧拉定理（欧拉降幂）" class="headerlink" title="扩展欧拉定理（欧拉降幂）"></a>扩展欧拉定理（欧拉降幂）</h3><script type="math/tex; mode=display">
模m意义下\\
a^c\equiv
\begin{cases}
    a^{c \mod \phi(m)}, \qquad &a,m互质\\
    a^c, \qquad &a,m不互质，c<\phi(m)\\
    a^{c \mod \phi(m)+\phi(m)}, \qquad &a,m不互质，c\geq \phi(m)
\end{cases}</script><blockquote>
<p>证明：$当a,m互质时$，由欧拉定理知$a^{\phi(m)}\equiv 1 \mod m$，定理显然成立。</p>
<p>$当a,m不互质，c&lt;\phi(m)时$，定理显然成立。</p>
<p>$当 a,m不互质，c\geq \phi(m)时$，取$a$的任意质因子$p$，即$a=p^xs且gcd(p,s)=1$，由欧拉定理知</p>
<script type="math/tex; mode=display">p^{\phi(s)}\equiv 1 \mod s</script><p>由积性函数知$\phi(s)|\phi(m)$，故</p>
<script type="math/tex; mode=display">p^{\phi(m)}\equiv 1 \mod s</script><p>同余方程同乘$p^x$(<strong>换模的另一种途径</strong>)得</p>
<script type="math/tex; mode=display">
p^{\phi(m)+x} \equiv p^x \mod m</script><p>由<strong>欧拉函数的性质7</strong>知$x\leq \phi(m)$，已知$\phi(m)\leq c$，所以</p>
<script type="math/tex; mode=display">
x \leq \phi(m) \leq c\\
p^c\equiv p^{x+(c-x)}\equiv p^{\phi(m)+x+(c-x)}\equiv p^{\phi(m)+c} \mod m</script><p>由$c(c\geq \phi(m))$的任意性和数学归纳法得</p>
<script type="math/tex; mode=display">
p^c\equiv p^{c \mod \phi(m) + \phi(m)} \mod m \\</script><p>对$p$的幂$p^k$，易得</p>
<script type="math/tex; mode=display">
(p^k)^c\equiv p^{kc}\equiv p^{kc \mod \phi(m)+\phi(m)}\\
\equiv p^{kc\mod \phi(m)+k\phi(m)}\equiv (p^k)^{c \mod \phi(m)+\phi(m)} \mod m</script><p>对$a=\prod\limits_{i=1}^np_i^{x_i}$，得</p>
<script type="math/tex; mode=display">\begin{aligned}
  a^c\equiv & \prod\limits_{i=1}^n(p_i^{x_i})^c \\
  \equiv & \prod\limits_{i=1}^n(p_i^{x_i})^{c \mod \phi(m)+\phi(m)} \\
  \equiv & a^{c \mod \phi(m) + \phi(m)} \mod m
\end{aligned}</script></blockquote>
<hr>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="线性筛质数"><a href="#线性筛质数" class="headerlink" title="线性筛质数"></a>线性筛质数</h2><p>求$[1,n]$内的所有素数。</p>
<ol>
<li>算法核心是<strong>每个合数只被其最小质因子筛到</strong>。</li>
<li>当前判断完$i$是否质数。接下来筛去i的倍数。枚举已知质数$p_j$，筛去$p_j*i$。若$p_j$是$i$的最小质因子则break。这是因为i以后筛的数都以$p_j$为最小质因子，这些数肯定能被其他的$i$枚举$p_j$筛去，不必重复筛。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// memset(vis, 0, sizeof(vis));</span></span><br><span class="line">    pcnt = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[pcnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pcnt &amp;&amp; prime[j]*i&lt;=n; ++j) &#123;</span><br><span class="line">            vis[prime[j]*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h2><p>求$[1,n]$内所有欧拉函数值</p>
<ol>
<li>算法核心是<strong>积性函数</strong>和<strong>欧拉函数性质4</strong></li>
<li>在线性筛的同时完成欧拉函数计算。当前判断完$i$是否质数，若是合数，则函数值在前面计算过了；若是质数，直接赋值$\phi(i)=i-1$。枚举已知质数$p_j$时，若$p_j$不是$i$的因子，由积性函数可知$\phi(i\cdot p_j)=\phi(i)\cdot \phi(p_j)=\phi(i)\cdot (p_j-1)$ ; 若$p_j$是$i$的因子，由<strong>性质4</strong>得$\phi(i\cdot p_j)=\phi(i)\cdot p_j$，然后break。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// memset(phi, 0, sizeof(phi));</span></span><br><span class="line">    pcnt = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            prime[pcnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pcnt &amp;&amp; i*prime[j]&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a><strong>欧几里得算法</strong>（辗转相除法）</h2><p>求$gcd(a,b)$。</p>
<ol>
<li>$gcd(a, 0)$的结果显然等于$a$。</li>
<li>当$a，b$全不为零，则$gcd(a,b) = gcd(b, a \mod b )$使问题规模减小。<blockquote>
<p>证明：令$c=a\mod b$,则$a=kb+c$.设$r$是$a,b$的公约数，则$r|a-kb$即$r|c$.设$r$是$b,c$的公约数,则$r|kb+c$即$r|a$.可见$a,b$的公约数和$b,a\mod b$的公约数完全相同，则最大公约数也必然相同。</p>
<p>应用：从$1$到$n(n&gt;2)$中与$n$互质的数成对出现，每一对和为$n$</p>
</blockquote>
</li>
</ol>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a><strong>扩展欧几里得算法</strong></h2><p>求$ax+by=gcd(a,b)$的一组整数解$x,y$。</p>
<ol>
<li>直接由<strong>贝祖定理</strong>可知整数解一定存在。（贝祖定理：存在整数$s，t$使得$sa+tb=gcd(a,b)$）</li>
<li>由辗转相除法知$bx’+(a\%b)y’=gcd(b,a\%b)=gcd(a,b)$的解也存在。由整数除法得<script type="math/tex; mode=display">\begin{aligned}
 bx'+(a\%b)y'=&bx'+(a-\frac{a}{b}b)y'\\
 =&b(x'-\frac{a}{b}y')+ay'=gcd(a,b)
\end{aligned}</script></li>
<li>递归进行求解，直到$b=0$，显然有解$1a+0b=gcd(a,b)$，令$x=1, y=0$，回溯，得解$x=y’, y=x’-\frac{a}{b}y’$</li>
<li>实际写代码时用引用，减少临时变量。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        d = a;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a%b, d, y, x); <span class="comment">// x和y完成了交换</span></span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a><strong>类欧几里得算法</strong></h2><p>求等差数列对每一项做整数除法的和，即</p>
<script type="math/tex; mode=display">
lgcd(a, b, c, n) = \sum_{i=0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor</script><ol>
<li>首先标准化$a,b$，使满足$a\geq 0, b\geq 0$，在答案中预先减去补上的$c$即可。</li>
<li><p>把$a,b$中含$c$的贡献拆出来，使问题规模变小。答案加上$n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor$。即</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor = \sum_{i=0}^{n-1}\lfloor \frac{(a\%c)i+(b\%c)}{c}\rfloor + n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor</script><p>现在可以令$a’=a\%c,\quad b’=b\%c$。</p>
</li>
<li><p>计算$\sum\limits_{i=0}^{n-1}\lfloor \frac{a’i+b’}{c}\rfloor$，得到的商肯定介于$[0,\lfloor\frac{a’(n-1)+b’}{c}\rfloor]$，设某次除法得到的商是$x$，可以认为$[1,x]$中每一个数对答案贡献了$1$，考虑每个数的总贡献，则</p>
<script type="math/tex; mode=display">
\sum\limits_{i=0}^{n-1}\lfloor \frac{a'i+b'}{c}\rfloor = \sum_{j=1}^{\lfloor\frac{a'(n-1)+b'}{c}\rfloor} \sum_{i=0}^{n-1} [\lfloor \frac{a'i+b'}{c}\rfloor \geq j]</script></li>
<li><p>接下来变换不等式$\lfloor \frac{a’i+b’}{c}\rfloor \geq j$。 取整符号不影响大于等于号的判断，可直接去掉；可直接通分；移项得$a’i\geq jc-b’$。整数除法的同除会影响大于等于号的判断，但不影响大于号，于是右边减一，两边同除$a’$得$i&gt;\frac{jc-b’-1}{a’}$。</p>
</li>
<li><p>为了方便统计合法的$i$，也为了转化形式满足递归，利用补集统计数量。对于固定的$j$，</p>
<script type="math/tex; mode=display">\begin{aligned}
 \sum\limits_{i=0}^{n-1} [i>\frac{jc-b'-1}{a'}] =& n-\sum\limits_{i=0}^{n-1} [i\leq\frac{jc-b'-1}{a'}] \\
 =& n-(\lfloor\frac{jc-b'-1}{a'}\rfloor+1)
\end{aligned}</script></li>
<li><p>套上前一层Sigma，得到递归形式（<strong>注意j变成从0开始</strong>）</p>
<script type="math/tex; mode=display">
令m={\lfloor\frac{a'(n-1)+b'}{c}\rfloor} \\
\sum_{j=0}^{m-1}[n-(\lfloor\frac{(j+1)c-b'-1}{a'}\rfloor+1)] = (n-1)m-lgcd(c, c-b'-1,a',m)</script></li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum&#123;(ai+b)/c&#125; for i=0..n-1</span></span><br><span class="line"><span class="function">LL <span class="title">lgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL res = n*(b/c) + (n<span class="number">-1</span>)*n/<span class="number">2</span>*(a/c);</span><br><span class="line">	a = a % c; b = b % c;</span><br><span class="line">	LL m = (a*(n<span class="number">-1</span>)+b)/c;</span><br><span class="line">	<span class="keyword">return</span> (n<span class="number">-1</span>)*m - lgcd(c, c-b<span class="number">-1</span>, a, m) + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>质因数分解时，质因数要么小于等于$\sqrt{n}$，要么等于$n$。不要漏掉等于$n$的情况。</li>
<li>1e8+7以内的质数<br>有5761456个，约为6e6，约为范围的1/15。<br><strong>范围越大，质数的占比越小</strong></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈</title>
    <url>/2019/07/08/%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h1 id="组合游戏"><a href="#组合游戏" class="headerlink" title="组合游戏"></a>组合游戏</h1><ol>
<li>两个游戏者轮流操作</li>
<li>游戏的状态集有限，每种状态最多出现一次（游戏可以结束）</li>
<li>无法操作的输，另一个获胜（游戏必有胜负）</li>
<li>公平游戏。两个游戏者面对相同的状态允许有相同的操作。</li>
</ol>
<a id="more"></a>
<h3 id="状态判定"><a href="#状态判定" class="headerlink" title="状态判定"></a>状态判定</h3><ol>
<li>一个状态是必胜状态(N)当且仅当它至少有一个后继是必败状态。</li>
<li>一个状态是必败状态(P)当且仅当它的所有后继都是必胜状态。</li>
<li>特别地，没有后继的状态是必败状态。</li>
</ol>
<h3 id="后手必胜的必要条件"><a href="#后手必胜的必要条件" class="headerlink" title="后手必胜的必要条件"></a>后手必胜的必要条件</h3><p>如果后手有必胜策略，则无论先手怎么取，都会存在后继可导致必败状态（即先手的所有后继都是必胜）。若先手能直接到达必败状态，则后手必输。</p>
<p>如Chomp!游戏（m*n棋盘，每次取某个点的所有右上格子，取到最后一个输）中，只要格子大于1，先手取最右上的一个格子，若后手能导致必败状态，则开局先手模仿后手的策略即可。故格子大于1时后手必败。</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>设有状态x，令SG(x) = mex(S), S为x的所有后继状态的SG值的集合，mex(S)为不在集合中的最小非负整数。对于没有后继的状态，SG=0，因为S是空集。其余的SG值可由递推得到。<br>当且仅当SG(x) == 0, x是必败状态。</p>
<h2 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h2><p>一个总游戏的SG值等于子游戏的SG值的Nim和（异或和）</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol>
<li>证明P状态的所有后继都是N状态<ol>
<li>异或和为零，对转移任意一状态，则异或和必不为零（新状态异或旧状态不为零），即后继必为N</li>
</ol>
</li>
<li>证明N状态的后继存在P状态<ol>
<li>异或和不为零，</li>
</ol>
</li>
</ol>
<h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>有n堆火柴，每堆有ai根火柴。每次选择一堆取走任意根，不能取的游戏者输。</p>
<p>考虑只有一堆的情况，设剩余火柴数为x。若x==0，没有后继状态，SG(0) = 0; 若x==1，所有后继状态的SG集合{0}，则SG(1) = 1; 若x==2，对应的S=={0，1}，SG(2) = 2; 归纳法证明SG(x) = x;</p>
<p>应用SG定理，对于多堆游戏，总游戏SG值为所有子游戏的SG值的Nim和，即所有堆火柴数的异或和。当且仅当异或和为0，先手必败。</p>
<h2 id="组合游戏题解法"><a href="#组合游戏题解法" class="headerlink" title="组合游戏题解法"></a>组合游戏题解法</h2><p>小范围内暴力计算子游戏SG值，找规律找到SG公式。</p>
<h1 id="博弈搜索"><a href="#博弈搜索" class="headerlink" title="博弈搜索"></a>博弈搜索</h1><p>CF ROUND 460 DIV2 F</p>
<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><ol>
<li>圆桌放圆盘<ol>
<li>对称性。先手占领圆心，后面被一步都模仿另一方。</li>
</ol>
</li>
<li>硬币环取1-K连续<ol>
<li>分类讨论K</li>
</ol>
</li>
<li>威佐夫博弈：两堆石子，取任意个时可对两堆同时操作<ol>
<li>记结论(x0=0, y0=0),(xk=mex{xi,yi}, yk=xk+k)必败</li>
<li>$a_k=\frac{\sqrt{5}+1}{2}k$</li>
<li>扩展：三堆，可同时操作两堆<ol>
<li>必败态少，跳过必胜态</li>
</ol>
</li>
</ol>
</li>
<li>每次一堆分别成异或加数两堆（每堆小于源堆）</li>
<li>反NIM游戏，先手必胜条件<ol>
<li>每堆石子只有一个，NIM和为零</li>
<li>有一堆石子多于一个，NIM和不为零</li>
</ol>
</li>
<li>SJ定理（泛化反NIM游戏）先手必胜条件<ol>
<li>每个子游戏SG值&lt;=1，SG异或和为零</li>
<li>存在一个子游戏SG&gt;1，SG异或和不为零</li>
</ol>
</li>
<li>Every-SG策略<ol>
<li>必胜态使步骤尽量长</li>
<li>必败态使步骤尽量短</li>
<li>先手获胜充要条件：所有单一游戏SG值最大值是奇数</li>
</ol>
</li>
<li>有根无向图删边游戏<ol>
<li>若无环，Colon定理</li>
<li>可能有环，Fushion等价缩环变树</li>
</ol>
</li>
<li>齐肯多夫定理：任何正整数可以唯一的表示为若干个不连续的斐波那契数之和</li>
<li>动态减法游戏（一倍，两倍，k倍）</li>
<li>翻硬币，最右必须由正变反<ol>
<li>多种扩展</li>
<li>打表吧</li>
<li>tartan定理<ol>
<li>二维硬币分解成一维硬币的积，logn2求nim积。这种积有结合律，可扩展到更高维</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学随笔</title>
    <url>/2019/06/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="1-6-Rules-of-Inference"><a href="#1-6-Rules-of-Inference" class="headerlink" title="1.6 Rules of Inference"></a>1.6 Rules of Inference</h1><ol>
<li>Modus ponens 假言推理 p &amp; p-&gt;q =&gt; q </li>
<li>Modus tollens 取拒式 !q &amp; p-&gt;q =&gt; !p</li>
<li>Hypothetical syllogism /,haɪpə’θɛtɪk, ‘sɪlə,dʒɪz(ə)m/ 假言三段论 p-&gt;q &amp; q-&gt;r =&gt; p-&gt;r </li>
<li>Disjunctive syllogism 析取三段论 pVq &amp; !p = p</li>
<li>Addtion 附加律 p =&gt; pVq  （附加在析取式中）</li>
<li>Simplification 化简律 p&amp;&amp;q =&gt; p （合取条件的拆分）</li>
<li>Resolution 消解律 pVq &amp; !pVr =&gt; qVr 条件相斥必有一T</li>
<li>? Logical equivalence<a id="more"></a>
</li>
</ol>
<script type="math/tex; mode=display">
\begin{matrix}
    Step & Reason \\
   1. xxx & Premise \\
   2. xxx & Contrapositive,of,(1) \\
   3. xxx & XXrule,using,(n),and,(m)
\end{matrix}</script><h2 id="Fallacies-谬误"><a href="#Fallacies-谬误" class="headerlink" title="Fallacies 谬误"></a>Fallacies 谬误</h2><ol>
<li>fallacy of affirming the conclusion 肯定结论的谬误 由结论推出条件</li>
<li>fallacy of denying the hypothesis  /haɪ’pɒθɪsɪs/ 否定假设的谬误 从否定条件推出否定结论</li>
</ol>
<h2 id="Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则"><a href="#Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则" class="headerlink" title="Rules of Inference for Quantified Statements 量化命题的推理规则"></a>Rules of Inference for Quantified Statements 量化命题的推理规则</h2><ol>
<li>Universal instantiation 全称实例 $\forall xP(x) \implies P(c)$</li>
<li>Universal generalization 全称引入 $P(c)$ for an arbitrary $c \implies \forall xP(x)$</li>
<li>Existential instantiaion 存在实例 $\exists xP(x) \implies P(c)$ for some element $c$</li>
<li>Existencial generalization 存在引入 $P(c)$ for some element $c \implies \exists xP(x)$</li>
</ol>
<h2 id="Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements"><a href="#Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements" class="headerlink" title="Combining Rules of Inference for Propositions and Quantified Statements"></a>Combining Rules of Inference for Propositions and Quantified Statements</h2><ol>
<li>Universal modus ponens 全称假言推理 对某个全称实例应用假言推理</li>
<li>Universal modus tollens 全称取拒式 对某个全称实例应用取拒式（否定结论推出否定条件）</li>
</ol>
<hr>
<h1 id="1-7-Introduction-to-Proofs"><a href="#1-7-Introduction-to-Proofs" class="headerlink" title="1.7 Introduction to Proofs"></a>1.7 Introduction to Proofs</h1><ol>
<li>theorem /‘θɪərəm/ 定理 （定理的证明有定义、其他定理、公理、推断规则）</li>
<li>lemma /‘lemə/ 引理 用于证明定理的其他定理</li>
<li>corollary /kə’rɒlərɪ/ 推论 定理下的直接结论</li>
<li>propositions 命题 偶尔用来称呼不重要的定理，或称事实、结论</li>
<li>conjecture /kən’dʒektʃə/ 猜想 一旦找到证明，猜想就变成定理；也有可能被证伪</li>
</ol>
<h2 id="To-Proof-p-gt-q-or-to-proof-p"><a href="#To-Proof-p-gt-q-or-to-proof-p" class="headerlink" title="To Proof p-&gt;q (or to proof p)"></a>To Proof p-&gt;q (or to proof p)</h2><ol>
<li>Trivial Proof : 平凡证明 if q is true then p-&gt;q is true.</li>
<li>Vacuous Proof : 空证明 if p is false then p-&gt;q is true.</li>
<li>Direct Proof : Assume p is true and show that q is true by using inferences, axioms, logical equivalences.</li>
<li>Indirect Proof : not begin with the premises and not end with the conclusion</li>
<li>Proof by contraposition 反证法 : Assume !q and show !p is true also. 直接证明法无效时尝试反证法</li>
<li>Proof by Contradiction 归谬证明法 : To proof p, first find a r such that !p -&gt; (r &amp;&amp; !r) is true, therefore !p is false and p is true. 假设结论的否定为真，引出一个矛盾</li>
<li>反例证明法 : 指明一个反例，从而证伪</li>
</ol>
<hr>
<h1 id="1-8-Proof-Methods-and-Strategy-证明的方法和策略"><a href="#1-8-Proof-Methods-and-Strategy-证明的方法和策略" class="headerlink" title="1.8 Proof Methods and Strategy 证明的方法和策略"></a>1.8 Proof Methods and Strategy 证明的方法和策略</h1><ol>
<li>Proof by cases 分情形证明法 tautology : (p1Vp2V…pn)-&gt;q &lt;-&gt; (p1-&gt;q)&amp;&amp;(p2-&gt;q)&amp;&amp;…(pn-&gt;q) 类似分类讨论</li>
<li>Exhaustive Proof 穷举证明法 当变量的取值比较少的时候，通过测试所有情形来证明。</li>
<li>Without loss of generality (WLOG) 不失一般性 省略非常类似的情形（证明过程几乎相同）的证明</li>
</ol>
<h2 id="Existence-Proof-存在性证明"><a href="#Existence-Proof-存在性证明" class="headerlink" title="Existence Proof 存在性证明"></a>Existence Proof 存在性证明</h2><p>To proof $\exists x P(x)$ :</p>
<ol>
<li>Constructive existence proof 构造性 : Find an explicit c, for which P(c) is true.</li>
<li>Nonconstructive existence proof 非构造性证明 ： 不直接构造例子，但说明多种情况之一必有符合的例子；或若不存在，就得到某些矛盾。</li>
</ol>
<h2 id="Uniqueness-Proof-唯一性证明"><a href="#Uniqueness-Proof-唯一性证明" class="headerlink" title="Uniqueness Proof 唯一性证明"></a>Uniqueness Proof 唯一性证明</h2><p>同时证明存在性和唯一性，即x符合某种期望，而若y!=x，则y不符合这种期望。也可以等价地证明若y符合这种期望，则y=x。</p>
<hr>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li>The cardinality of  a finite set A 集合的基数，|A|</li>
<li>finite 有限的 /faɪnaɪt/</li>
<li>infinite 无限的 /‘ɪnfɪnət/</li>
<li>Power Set 幂集 P(A) The set of all subsets of a set A. $|P(A)| = 2^{|A|}$</li>
<li>Cartesian Product 笛卡尔积 A x B x C的意义和(A x B) x C不一样！</li>
<li>coordinate</li>
</ol>
<h2 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h2><ol>
<li>Union /‘junɪən/</li>
<li>Intersection</li>
<li>Complementation : complement 补集，必须有universal set U。A上一横杠</li>
<li>Difference 不满足交换律，A-B</li>
<li>Symmetric Difference 对称差 异或</li>
</ol>
<h3 id="Set-Identities-集合恒等式"><a href="#Set-Identities-集合恒等式" class="headerlink" title="Set Identities 集合恒等式"></a>Set Identities 集合恒等式</h3><ol>
<li>注意一下分配率，德摩根律（否定去括号）</li>
<li>其他不管啊太简单了</li>
<li>Membership Tables 成员表，枚举任意元素属于各个集合情况，从而验证恒等式（和真值表类似）</li>
</ol>
<h2 id="Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B"><a href="#Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B" class="headerlink" title="Funtion (f maps A to B) (f is a mapping from A to B)"></a>Funtion (f maps A to B) (f is a mapping from A to B)</h2><ol>
<li>assignment 指派，分配。 指定f(a)=b。</li>
<li>domain 定义域 A</li>
<li>codomain 陪域 B</li>
<li>image 像 b is an image of a under f</li>
<li>preimage 原像 可能是单个元素，也可能是一个集合。</li>
<li>f(A) range 值域</li>
<li>等价的函数具有相同的domain &amp; codomain &amp; map each element to the same element of the codomain</li>
<li>$f(S) = \{f(s)|s\in S\}$</li>
<li>$(f_1+f_2)(x) = f_1(x)+f_2(x)$</li>
<li>$(f_1<em>f_2)(x) = f_1(x)</em>f_2(x)$</li>
<li>injection injective 单射 one-to-one 可在值域上定义反函数</li>
<li>surjection surjective (or onto) 满射 映上 陪域中每个元素都能找到原像</li>
<li>injective and surjective =&gt; bijection or one-to-one correspondence 双射 一一对应</li>
<li>invertible 可逆的 Inverse Function 反函数</li>
<li>Composition 复合函数 $f \circ g = f(g(x))$</li>
<li>Factorial/fæk’tɔrɪəl/ Function 阶乘函数</li>
<li>Partial Function 局部函数，对某个函数截取部分domain</li>
</ol>
<h2 id="Sequence-序列-a-n"><a href="#Sequence-序列-a-n" class="headerlink" title="Sequence 序列 $\{a_n\}$"></a>Sequence 序列 $\{a_n\}$</h2><p>A funtion from N or N+ to S</p>
<script type="math/tex; mode=display">a_n = f(n)</script><ol>
<li>term 项</li>
<li>Geometric Progression 几何级数 a*r^n, n=0,1…  (a and r are real numbers)</li>
<li>Arithmetic Progression 算术级数 （等差数列）</li>
<li>Recurrence relation 递推关系 </li>
<li>a solution of a recurrence relation 满足递推关系的序列称为这个递推关系的一个解</li>
<li>initial conditions 初始条件 递推关系生效前的所有terms</li>
<li>solving the recurrence relation 找到通项公式 这样的公式叫closed formula闭公式</li>
<li>iteration 迭代法，正向替换 working upward； 反向替换 working downward。 用于猜测formula，然后用the method of induction数学归纳法证明。</li>
<li>Summation （序列的部分）总和</li>
<li>in lexicographic order /,lɛksɪkə’græfɪk/ 字典序</li>
</ol>
<h2 id="Matrices-矩阵"><a href="#Matrices-矩阵" class="headerlink" title="Matrices 矩阵"></a>Matrices 矩阵</h2><ol>
<li>Boolean Product 布尔积 类似矩阵乘法，各项求交之后求并</li>
<li>Boolean Powers 多次布尔积。 写作$A^{[n]}$, 记$A^{[n]}=I$</li>
</ol>
<hr>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol>
<li>pseudocode /‘sju:doˌkod/ 伪代码</li>
<li>Halt Problem 停机问题，无解</li>
<li>Big-O f(x) of big-O of g(x)</li>
<li>|f(x)| &lt; |c*g(x)| (x &gt; k) : the constants c and k are called witnesses. Only one pair of witnesses is needed.</li>
<li>if f = O(g) &amp;&amp; g = O(f), then the two functions are of the same order.</li>
<li>polynomial /,pɒlɪ’nəʊmɪəl/ 多项式</li>
<li>if |f(x)| &gt; |C*g(x)| (x &gt; k) : Big-Omega</li>
<li>if f = O(g) &amp;&amp; g = O(f), then f = θ(g) : Big-Theta; f(x) is of order g(x).</li>
<li>brute-force 蛮力（算法）</li>
<li>Tractable Problem ：P类问题，多项式时间内解决</li>
<li>Intractable Problem</li>
<li>Unsolvable Problem 无解的问题，例如Halt Problem</li>
<li>Class NP: 可在多项式时间内验证一个解的问题</li>
<li>NP Complete Class: NPC问题，所有的NP问题都能约化为NPC问题。</li>
</ol>
<hr>
<h1 id="Number-Theory-and-Cryptography-数论和密码学"><a href="#Number-Theory-and-Cryptography-数论和密码学" class="headerlink" title="Number Theory and Cryptography 数论和密码学"></a>Number Theory and Cryptography 数论和密码学</h1><p>/krɪp’tɑgrəfi/</p>
<ol>
<li>divisibility /di,vizi’biləti/ 可除性</li>
<li>hexadecimal /,hɛksə’dɛsɪml/ 十六进制（的）</li>
<li>modular /‘mɑdjʊlɚ/ 模的</li>
<li>congruence 同余 /‘kɑŋgrʊəns/</li>
<li>a divides b  a除b， a is a factor or divisor of b, b is a multiple of a.</li>
<li>quotient /‘kwoʃnt/商; remainder /rɪ’mendɚ/余数</li>
<li>-11 / 3 = -4 … 1</li>
<li>The notation a  ≡  b (mod m)  says  that a is <strong>congruent</strong> to b modulo m.   a  ≡  b (mod m) is a congruence and that m is its modulus.</li>
<li>doing arithmatic modulo m: $a+_mb = (a+b) \mod m; a<em>_mb = (a</em>b) \mod m$</li>
</ol>
<h2 id="Zm-0…m-1"><a href="#Zm-0…m-1" class="headerlink" title="Zm = {0…m-1}"></a>Zm = {0…m-1}</h2><ol>
<li>Closure 封闭性</li>
<li>Associativity 结合律</li>
<li>Commutativity 交换律</li>
<li>Identity element 单位元 （加法0，乘法1）</li>
<li>Additive inverse 加法逆元</li>
<li>Distributivity 分配率</li>
<li>判定同余式，左边减右边是m的倍数。</li>
</ol>
<h2 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h2><ol>
<li>composite /kɑm’pɑzɪt/ 合数</li>
<li>divisible by 7 能被7整除</li>
<li>Mersenne Primes 梅森素数：满足2的素数次方减一的素数。检验2的素数次方减一是否素数是容易的，由此得到已知的最大素数。$2^{11}-1不是素数$</li>
<li>Prime Number Theorem: 不超过x的素数个数大约是(x / ln x)，任取一个不超过n的数，则这个数是素数的概率是1/lnx。</li>
<li>对两个互质的数a,b:ak+b可以生成无限个素数。</li>
<li>存在由任意个素数组成的等差数列（Arithmetic Progression）</li>
<li>现阶段没有发现高效生成素数的算法f(n)</li>
<li>不存在多项式函数f(n)使得其值一定是素数</li>
<li>Goldbach’s Conjecture 哥德巴赫猜想：所有大于2的偶数都能表示为两个素数的和。</li>
<li>Conjecture: There are infinitly many primes of the form $n^2+1$.</li>
<li>The Twin Prime Conjecture: 相差2的素数有无限多组</li>
</ol>
<h2 id="Great-Commom-Divisor-dɪ’vaɪzɚ"><a href="#Great-Commom-Divisor-dɪ’vaɪzɚ" class="headerlink" title="Great Commom Divisor /dɪ’vaɪzɚ/"></a>Great Commom Divisor /dɪ’vaɪzɚ/</h2><ol>
<li>relatively prime 互质数</li>
<li>pairwise relatively prime 两两互质</li>
<li>Prime Factorizations /,fæktərai’zeiʃən/ 质因数分解</li>
<li>Least Common Multiple 最小公倍数 lcm(a,b)</li>
<li>Euclidean /ju:’klidiən/ 欧几里得的</li>
<li>Bézout’s Theorem 贝祖定理 gcd(a,b) = sa+tb. （求s、t用扩展欧几里得）</li>
<li>if gcd(a,b)=1 &amp;&amp; a|bc, then a|c; Therefore, a ≡ b (mod m) if ac ≡ bc (mod m) &amp;&amp; gcd(c,m)=1.</li>
</ol>
<h2 id="Solving-Congruences"><a href="#Solving-Congruences" class="headerlink" title="Solving Congruences"></a>Solving Congruences</h2><ol>
<li>linear congruences 线性同余方程 ax≡b ( mod m)</li>
<li>an inverse of A modulo m 模m下a的乘法逆元</li>
<li>逆元存在的充要条件：若gcd(a,m)=1, 则存在a在模m下的乘法逆元。 Proof: Since gcd(a,m)=1, there are integers s and t such that sa+tm=1. Hence, sa+tm ≡ 1 ( mod m), and it follows that sa ≡ 1 ( mod m). 用扩展欧几里得求出s即逆元。</li>
<li>coefficient /koʊəˈfɪʃənt/ 系数</li>
<li>Chinese Remainder Theorem: 对于模数两两互质的同余方程组（一条方程的形式为$x≡a_i (\mod m_i), m&gt;1$）,在$模M=\prod\limits_{i=1}^n m_i系$中有且仅有唯一解。一个解的构造为$x = \sum\limits_{i=1}^n a_i M_i y_i$, 其中$M_i = M\div m_i, y_i<em>M_i≡1 (\mod m_i)$。如此构造后，对任意的i，都满足同余方程$x ≡ a_i M_i y_i ≡ a_i (\mod m_i)$。模系下的唯一性<em>*待证 练习30</em></em>。</li>
<li>Fermat’s Little Theorem： $有质数p，有整数a不是p的倍数，则a^{p-1}≡1(\mod p)$</li>
<li>利用费马小定理可以简化$a^q \mod p$的运算，其中q很大。可以将q替换为$(q \mod (p-1))$</li>
<li>满足$b^{n-1}≡1(\mod n)$的非质数n成为以b为基的伪质数 Pseudoprimes to the base b。（苏豆）</li>
<li>因为在一定范围内的对于某个基的pseudoprimes总是很少，所以可以进行质数近似判定测试。可惜，对于某些数n，对于所有基b满足gcd(b,n)=1，总是能通过伪素数测试，即$b^{n-1}≡1(\mod n)$，这些数称为Carmichael Numbers（卡麦抠 卡米切尔）。 Carmichael Numbers有无穷多个。</li>
<li>欧拉定理：费马小定理的推广。$有互质整数a,n.则a^{\phi(n)}≡1 (\mod n)$，而a在模n意义下存在逆元的充要条件就是a,n互质，从而得到推论：若a的逆元存在，则为$a^{\Phi(n)-1}$。</li>
<li>Discrete Logarithms (模p意义下的)离散对数 对已知质数p，在模p意义下存在唯一一个primitive root $r$ 原始根，使得$r^n$取遍所有模p意义下所有非零数。 对任意$a\in [1,p-1]$，若有$r^e≡a(\mod p), e \in [1, p-1]$ ，则即$\log_r a=e$</li>
<li>求discrete logarithms $\log_r a$(模质数p意义下)没有找到多项式时间的算法。这个问题是密码学的一部分。</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
