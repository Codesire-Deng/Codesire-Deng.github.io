<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Archlinux装机笔记</title>
    <url>/2022/10/24/Archlinux%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>重要数据·务必备份</strong>！固态硬盘报废，连带 Linux 无了，只能重装。恐将来也会频繁装机，故写一篇笔记，希望一劳永逸。</p>
<span id="more"></span>

<h2 id="进入桌面前"><a href="#进入桌面前" class="headerlink" title="进入桌面前"></a>进入桌面前</h2><h3 id="准备装机盘"><a href="#准备装机盘" class="headerlink" title="准备装机盘"></a>准备装机盘</h3><ol>
<li>在 <a href="https://archlinux.org/download/">archlinux</a> 找到镜像源，下载 ISO。</li>
<li>用 <a href="https://rufus.ie/zh/">Rufus</a> 之类的刷 U 盘。<ul>
<li>MBR 分区</li>
<li>ISO 模式</li>
</ul>
</li>
</ol>
<h3 id="引导进装机盘"><a href="#引导进装机盘" class="headerlink" title="引导进装机盘"></a>引导进装机盘</h3><p>华硕主板的快捷键是 <code>F11</code>。如果黑屏，将 DP 线换成 HDMI。</p>
<h3 id="archinstall"><a href="#archinstall" class="headerlink" title="archinstall"></a>archinstall</h3><ol>
<li>进临时操作系统之后，连网线，运行 <code>archinstall</code>。</li>
<li>选镜像源（mirror region）</li>
<li>选择格式化硬盘</li>
<li>创建 superuser。</li>
<li>其他选项都检查一下。archinstall 可能会有大幅的更新。</li>
<li>install! </li>
<li>最后提示 chroot，在里面 <code>systemctl enable sddm</code>。</li>
</ol>
<h3 id="卡-wayland"><a href="#卡-wayland" class="headerlink" title="卡 wayland"></a>卡 wayland</h3><p>N 卡 + nvidia 专有驱动 + wayland &#x3D; 黑屏</p>
<p>在 <code>~/.local/share/sddm/wayland-session.log</code> 可查看 log。</p>
<ol>
<li>先用 X11 登陆，把环境都配置好再回来。</li>
<li>添加内核参数：<code>nvidia-drm.modeset=1</code>。这是 wayland 要求的。<ul>
<li>适用于 systemd-boot：<code>kate /boot/loader/entries/xxxx.conf</code>。追加参数。</li>
</ul>
</li>
<li>已经能用了，但是 BUG 很多又卡顿，Fuck Nvidia。遂放弃，或者<a href="https://forum.manjaro.org/t/installing-video-nvidia-causes-kde-sddm-to-fail-to-load/110395/6">参考</a></li>
</ol>
<h2 id="进入桌面后"><a href="#进入桌面后" class="headerlink" title="进入桌面后"></a>进入桌面后</h2><h3 id="添加-sudo-免密"><a href="#添加-sudo-免密" class="headerlink" title="添加 sudo 免密"></a>添加 sudo 免密</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">vim /etc/sudoers.d/00_codesire</span><br><span class="line"><span class="comment"># 内容如下</span></span><br><span class="line">codesire ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>

<h3 id="调整快捷键"><a href="#调整快捷键" class="headerlink" title="调整快捷键"></a>调整快捷键</h3><ol>
<li>Konsole</li>
<li>System Settings</li>
<li>KRunner</li>
<li>（后面安装的）Flameshot: <code>/usr/bin/flameshot gui</code></li>
</ol>
<h3 id="安装-yay"><a href="#安装-yay" class="headerlink" title="安装 yay"></a>安装 yay</h3><p>利用 git 下载预编译版安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">mkdir</span> -p .<span class="built_in">local</span>/opt &amp;&amp; <span class="built_in">cd</span> .<span class="built_in">local</span>/opt</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay-bin.git</span><br><span class="line"><span class="built_in">cd</span> yay-bin &amp;&amp; makepkg -si</span><br></pre></td></tr></table></figure>

<h3 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">mkdir</span> -p .config/fontconfig</span><br><span class="line">kate .config/fontconfig/fonts.conf</span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;urn:fontconfig:fonts.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- $&#123;XDG_CONFIG_HOME&#125;/fontconfig/fonts.conf</span></span><br><span class="line"><span class="comment">        - vim:ft=xml:fenc=utf-8:noet:ts=3:sw=3:</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Color Emoji<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;antialias&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;autohint&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dpi&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">double</span>&gt;</span>96<span class="tag">&lt;/<span class="name">double</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hinting&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hintstyle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>hintslight<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lcdfilter&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>lcdlight<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rgba&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">const</span>&gt;</span>rgb<span class="tag">&lt;/<span class="name">const</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">edit</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">int</span>&gt;</span>15<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dir</span>&gt;</span>~/.fonts<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>刷新字体缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure>

<p>可能需要重启生效，但是先不重启。</p>
<h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><p>谜之 CPU 软件包，不要全装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S amd-ucode</span><br><span class="line">sudo pacman -S intel-ucode</span><br></pre></td></tr></table></figure>

<p>man，浏览器，输入法，vscode，openssh，firacode，flameshot：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S man-db man-pages google-chrome-stable fcitx5-im fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-pinyin-zhwiki visual-studio-code-bin openssh ttf-fira-code nerd-fonts-fira-code flameshot</span><br></pre></td></tr></table></figure>

<p>在 System Settings 添加 Pinyin 输入。修改切换输入法的快捷键。</p>
<p>如果需要开启启动 sshd：<code>systemctl enable --now sshd</code></p>
<p>网络自由，Fuck Timeout：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -Ls https://mirrors.v2raya.org/go.sh | sudo bash</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> v2ray --now</span><br><span class="line">yay -S v2raya-bin</span><br><span class="line">sudo systemctl start v2raya.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> v2raya.service</span><br></pre></td></tr></table></figure>

<p>进浏览器管理 <code>127.0.0.1:2017</code>。</p>
<h3 id="还原-zsh"><a href="#还原-zsh" class="headerlink" title="还原 zsh"></a>还原 zsh</h3><p>参考 <a href="https://github.com/Codesire-Deng/rc">Codesire-Deng&#x2F;rc</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S zsh</span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">yay -S zsh-syntax-highlighting-git</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖拷贝 <a href="https://github.com/Codesire-Deng/rc">Codesire-Deng&#x2F;rc</a> 的配置文件。</li>
<li>安装完后，调整 konsole 和 vscode 的默认终端。</li>
</ul>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h4 id="C-相关"><a href="#C-相关" class="headerlink" title="C++ 相关"></a>C++ 相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S linux-headers cmake clang mimalloc boost cloc </span><br></pre></td></tr></table></figure>

<h4 id="perf-相关"><a href="#perf-相关" class="headerlink" title="perf 相关"></a>perf 相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S perf</span><br><span class="line"><span class="built_in">cd</span> ~/Downloads &amp;&amp; git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">sudo <span class="built_in">ln</span> -s ~/Downloads/FlameGraph/stackcollapse-perf.pl /usr/bin/stackcollapse-perf.pl</span><br><span class="line">sudo <span class="built_in">ln</span> -s ~/Downloads/FlameGraph/flamegraph.pl /usr/bin/flamegraph.pl</span><br></pre></td></tr></table></figure>

<h4 id="Node-相关"><a href="#Node-相关" class="headerlink" title="Node 相关"></a>Node 相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/tj/n/master/bin/n -o n</span><br><span class="line">sudo bash n lts</span><br><span class="line">sudo npm install -g n</span><br><span class="line"><span class="built_in">rm</span> n</span><br><span class="line">sudo npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="编译-Clang-套件"><a href="#编译-Clang-套件" class="headerlink" title="编译 Clang 套件"></a>编译 Clang 套件</h3><p>参考 <a href="https://clang.llvm.org/get_started.html">Clang Docs</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/llvm/llvm-project.git</span><br><span class="line"><span class="built_in">cd</span> llvm-project</span><br><span class="line">cmake -B build -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G <span class="string">&quot;Unix Makefiles&quot;</span> ./llvm</span><br><span class="line">cmake --build build -j 14 <span class="comment"># 不要使用全部的核心！UI会崩溃</span></span><br><span class="line">sudo <span class="built_in">cp</span> ./build/bin/clang-format $(<span class="built_in">which</span> clang-format)</span><br><span class="line">clang-format --version</span><br></pre></td></tr></table></figure>

<h3 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h3><p>参考 <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Github Docs</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;oi_dzf@qq.com&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>将公钥添加到 <a href="https://github.com/settings/keys">Github SSH keys</a>。</p>
<h3 id="systemd-boot-追加-Windows"><a href="#systemd-boot-追加-Windows" class="headerlink" title="systemd-boot 追加 Windows"></a>systemd-boot 追加 Windows</h3><ol>
<li>找到 Windows EFI 分区：<ul>
<li><code>lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT</code></li>
</ul>
</li>
<li>挂载这个分区：<ul>
<li><code>sudo mkdir /mnt/win-efi</code></li>
<li><code>sudo mount /dev/sdb1xxx /mnt/win-efi</code></li>
</ul>
</li>
<li>拷贝 Windows EFI 到当前硬盘的 EFI（<code>/boot/EFI</code>在不同系统下可能不同，例如可能是<code>/boot/efi/EFI</code>）<ul>
<li><code>sudo cp -r /mnt/win-efi/EFI/Microsoft /boot/EFI</code></li>
</ul>
</li>
<li>修改 bootloader 的配置，例如倒计时<ul>
<li>参考 <a href="https://wiki.archlinux.org/title/Systemd-boot">Wiki: Systemd-boot</a></li>
<li><code>kate /boot/loader/loader.conf</code></li>
</ul>
</li>
<li>重启即可。在选择界面按 <code>d</code> 即可指定默认项。</li>
</ol>
<h3 id="附：Windows-改为-UTC-时间"><a href="#附：Windows-改为-UTC-时间" class="headerlink" title="附：Windows 改为 UTC 时间"></a>附：Windows 改为 UTC 时间</h3><p>新建<code>UTC.reg</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]</span><br><span class="line">&quot;RealTimeIsUniversal&quot;=dword:00000001</span><br></pre></td></tr></table></figure>

<p>用管理员运行之即可。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>珍爱生命，珍惜时间。</p>
]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>C++20 Coroutine</title>
    <url>/2021/11/18/C-20-Coroutine/</url>
    <content><![CDATA[<blockquote>
<p><strong>协程</strong>(coroutine)是能够暂停和恢复的函数。</p>
</blockquote>
<p>协程是<strong>线程阻塞造成性能下降</strong>的最佳解决方案，尤其是应用在静态线程池中。</p>
<span id="more"></span>

<small>

<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>GoLang 设计的 goroutine 简单好用，大名鼎鼎；虚拟机语言（例如 C#，Javascript，Java）的协程更是逆天改命，强势占领高性能并发的高地；机器队这边简直神速，而我们的人工队 C++ 在干什么呢，不会还没做完 STL network 吧，不会连 <code>format</code> 的编译器支持都没有吧，不会还没推广 <code>import &lt;module&gt;</code> 吧 🥵🥵🥵……</p>
</small>

<h2 id="C-的协程"><a href="#C-的协程" class="headerlink" title="C++的协程"></a>C++的协程</h2><p>C++的协程是：</p>
<ol>
<li>对称的。一个协程暂停后，可返回 caller 或恢复任意协程。</li>
<li>语言级特性。编译器知道你在使用协程。然而不比库强到哪里去。</li>
<li>无栈(Stackless) 的。没有独立运行时栈，无惧爆栈，调度成本低。</li>
</ol>
<p>一个协程在被命令「暂停」时，会保证将数据和当前运行位置保存在堆内存（以便恢复现场），然后转移运行权。</p>
<p>协程允许程序员更美观地编写异步代码，也使懒惰求值的算法成为可能。</p>
<p>当一个函数出现以下三种关键字之一，它就是协程：</p>
<ol>
<li><code>co_await</code> 暂停（直到被命令「恢复」）。</li>
<li><code>co_yield</code> 暂停同时返回一个值。</li>
<li><code>co_return</code> 结束整个协程并返回一个值。</li>
</ol>
<h2 id="使用协程的理由"><a href="#使用协程的理由" class="headerlink" title="使用协程的理由"></a>使用协程的理由</h2><ol>
<li>相比于回调和 sender&#x2F;receiver，协程的使用<strong>成本更低</strong>，<strong>性能下限更高</strong>。</li>
<li>降低使用者的心智负担和阅历要求，催化高质量工程，有望成为<strong>资本宠儿</strong>。<ul>
<li>例如可以摆脱 asio 里常见的 <code>std::shared_ptr</code>。</li>
</ul>
</li>
</ol>
<h2 id="C-协程的弱点"><a href="#C-协程的弱点" class="headerlink" title="C++协程的弱点"></a>C++协程的弱点</h2><ol>
<li>除非编译器优化，每个协程都需要通过 <code>operator new</code> 来分配 frame：<ul>
<li>动态内存分配可能引发性能问题；</li>
<li>在嵌入式或异构（例如 GPU）环境下，缺乏动态内存分配能力，难以工作。</li>
</ul>
</li>
<li>除非编译器优化，协程的可定制点太多，需要大量间接调用&#x2F;跳转（而不是内联），同样引起性能问题。<ul>
<li>目前，编译器通常难以内联协程；</li>
<li>HALO 优化理论：<a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2021/p2300r3.html#biblio-p0981r0">P0981R0</a>。</li>
</ul>
</li>
<li><strong>动态分配</strong>和<strong>间接调用</strong>的存在，导致协程暂时无法成为异步框架的最优方法。</li>
<li>Debug 的体验风评不佳。</li>
</ol>
<h2 id="协程的限制"><a href="#协程的限制" class="headerlink" title="协程的限制"></a>协程的限制</h2><ol>
<li>不能使用变参模板</li>
<li>不能使用 <code>return</code></li>
<li>不能使用占位符返回类型 （<code>auto</code> 或者 Concept）</li>
<li>不能是 constexpr 函数</li>
<li>不能是构造函数或者析构函数</li>
<li>不能是 <code>main</code> 函数</li>
</ol>
<h2 id="协程的运行过程"><a href="#协程的运行过程" class="headerlink" title="协程的运行过程"></a>协程的运行过程</h2><p>所有协程必须关联着几个对象：</p>
<ol>
<li><strong>promise object</strong>，在协程内部进行操作，协程向其写入结果或者异常。</li>
<li><strong>coroutine handle</strong>，在协程外部进行操作，用于恢复协程或者销毁协程帧(frame)。</li>
<li><strong>coroutine state</strong>，保存协程的信息，分配于堆内存上（除非被优化），对程序员不可见。具体保存着：<ol>
<li>promise object</li>
<li>所有协程参数（按值复制或移动）</li>
<li>记录暂停点的状态机</li>
<li>局部变量和临时变量</li>
</ol>
</li>
</ol>
<hr>
<p>当协程「开始」时，它会：</p>
<ol>
<li>使用 <code>operater new</code> 来构造 coroutine state。</li>
<li>将所有协程参数拷贝或移动到 coroutine state。<em>小心发生「垂悬引用」，尤其在协程恢复后。</em></li>
<li>构造 promise object。优先调用接受所有协程参数的构造函数，否则调用默认构造函数。</li>
<li>调用 <code>promise.get_return_object()</code>，其结果保存为本地变量。此结果在第一次暂停时会返回给 caller。包括这一步和以前的步骤，所有异常都会抛给 caller，而不是放入 promise object。</li>
<li>调用 <code>promise.initial_suspend()</code>，紧接着 <code>co_await</code> 它。<em>常见的返回值是 <code>suspend_always</code> 用于懒汉协程，或者 <code>suspend_never</code> 用于饿汉协程</em></li>
<li>当 <code>co_await promise.initial_suspend()</code> 恢复后，协程开始运行其函数体。</li>
</ol>
<hr>
<p>当协程到达暂停点，它会：</p>
<ol>
<li>将 return object 返回给执行权所有者，类型应为协程的返回类型，允许发生隐式转换。</li>
</ol>
<hr>
<p>当协程到达 <code>co_return [expr]</code> 语句，它会：</p>
<ol>
<li>调用 <code>promise.return_void()</code>，条件是：<ol>
<li><code>co_return;</code></li>
<li><code>co_return expr</code> 而 expr 的类型是 void</li>
<li>函数体结束</li>
</ol>
</li>
<li>或者调用 <code>promise.return_value(expr)</code>。</li>
<li>析构所有自动变量。</li>
<li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。</li>
</ol>
<hr>
<p>当协程因未捕获异常而结束，它会：</p>
<ol>
<li>捕获这个异常，并在 <code>catch</code> 块中调用 <code>promise.unhandled_exception()</code></li>
<li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。此时恢复另一个协程是 UB。</li>
</ol>
<hr>
<p>当 coroutine state 被析构（要么遇到 <code>co_return</code>，要么未捕获异常，在要么被 handle 销毁）时，它会：</p>
<ol>
<li>析构 promise object。</li>
<li>析构所有协程参数。</li>
<li>使用 <code>operator delete</code> 来释放coroutine state。</li>
<li>转移执行权。</li>
</ol>
<h2 id="关于堆分配"><a href="#关于堆分配" class="headerlink" title="关于堆分配"></a>关于堆分配</h2><p>动态内存分配可能成为<strong>严重性能瓶颈</strong>！</p>
<p>程序员可通过自定义 <code>operator new</code> 来控制 coroutine state 的分配。这部分暂时忽略不讲。</p>
<h2 id="Promise类型推导"><a href="#Promise类型推导" class="headerlink" title="Promise类型推导"></a>Promise类型推导</h2><p>这部分暂时忽略不讲。</p>
<h2 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h2><p>一元运算符 <code>co_await</code> 会暂停协程并将转移执行权。其操作数必须定义 <code>operator co_await</code>，或者能通过当前协程的 <code>Promise::await_transform</code> 转换成这种类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">co_await</span> expr</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/18/C-20-Coroutine/co_await.svg" alt="co_await"></p>
<p>首先，<code>expr</code> 要被转换为 awaitable，规则如下：</p>
<ol>
<li>如果 <code>expr</code> 是由 initial suspend point，final suspend point 或者 yield expression 生成的，那么 awaitable 就是 <code>expr</code> 本身。</li>
<li>否则，如果当前协程有定义 <code>Promise::await_transform</code>，那么 awaitable 就是 <code>promise.await_transform(expr)</code>。</li>
<li>否则，awaitable 就是 <code>expr</code> 本身。</li>
</ol>
<p>然后生成一个 awaiter object，规则如下：</p>
<ol>
<li>根据重载解析的结果调用 <code>opeartor co_await(awaitable)</code> 或者 <code>awaitable.operator co_await()</code></li>
<li>如果重载解析找不到函数，那么 awaiter 就是 awaitable 本身。</li>
<li>如果重载解析有歧义，那么程序是 ill-formed。</li>
</ol>
<p>然后，调用 <code>awaiter.await_ready()</code>并判断，决定是否暂停协程：</p>
<ul>
<li>若 <code>false</code>，协程暂停，必要的信息存放于 coroutine state。然后调用 <code>awaiter.await_suspend(handle)</code>。在这个函数中，通过 <code>handle</code> 可以访问 coroutine state，也是这个函数有责任安排协程在某个 executor 上恢复（甚至立即就地恢复），或者干脆销毁协程：<ul>
<li>若 <code>awaiter.await_suspend(handle)</code> 返回 void，执行权立即转移（给 caller&#x2F;resumer）。</li>
<li>否则若返回 bool，<ul>
<li>若 <code>true</code> 则转移执行权（给 caller&#x2F;resumer）。</li>
<li>若 <code>false</code> 则恢复当前协程。</li>
</ul>
</li>
<li>否则返回一个 coroutine handle（对应其他协程），调用这个 <code>other_handle.resume()</code>。注意链式调用可能最终恢复当前协程。</li>
<li>当前协程恢复后，返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li>
</ul>
</li>
<li>若 <code>true</code>，协程直接返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li>
</ul>
<p>注意在进入 <code>awaiter.await_suspend(handle)</code> 之前，当前协程已经完全暂停，此时当前 handle 可以在线程之间自由传递，并由其他调度者恢复。在这种情况下，协程可能已经被恢复，awaiter 随之已经被析构，所以 <code>await_suspend()</code> 不应再访问 <code>*this</code>。</p>
<h2 id="co-yield"><a href="#co-yield" class="headerlink" title="co_yield"></a>co_yield</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">co_yield</span> expr</span><br><span class="line"><span class="keyword">co_yield</span> braced-init-list</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">co_await</span> promise.<span class="built_in">yield_value</span>(expr)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>语法</tag>
        <tag>C++协程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Smart Pointer</title>
    <url>/2021/12/15/C-smart-pointer/</url>
    <content><![CDATA[<p>本文意在阐述 C++ 智能指针的实现原理，应用场景和潜在的坑。</p>
<span id="more"></span>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>基于引用计数的智能指针。在构造和析构时修改引用计数。当引用计数为 0 时，析构资源。</p>
<p>单个引用计数器是线程安全的。但是，shared_ptr 并非线程安全，至少因为两个原因：</p>
<ol>
<li>「改写资源指针」与「改写引用计数」，这两步并非原子化。</li>
<li>「改写共享引用计数」与「改写弱引用计数」，这两步也非原子化。</li>
</ol>
<p>陈硕的书和<a href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html">博客</a>给出了一个竞争条件的例子。如果要从多个线程读写同一个 shared_ptr 对象，是<strong>需要加锁</strong>的。</p>
<h3 id="shared-ptr-的实现原理"><a href="#shared-ptr-的实现原理" class="headerlink" title="shared_ptr 的实现原理"></a>shared_ptr 的实现原理</h3><ol>
<li>一个 <code>shared_ptr</code> 持有两个裸指针，分别指向资源和「控制块」 (control block)</li>
<li>控制块主要用于实现引用计数。具体的内容有：<ol>
<li>指向所管理资源的指针，或者是资源本身</li>
<li>deleter（已擦除类型）</li>
<li>allocator（已擦除类型）</li>
<li><code>shared_ptr</code> 共享引用计数器</li>
<li><code>weak_ptr</code> 弱引用计数器 （主流实现中 <code>shared_ptr</code> 亦计入弱引用计数）</li>
</ol>
</li>
<li>若使用 <code>make_shared</code> 或 <code>allocate_shared</code> 来构造指针，则资源和控制块一同参与内存申请。<em>这是潜在坑点。</em></li>
<li>若弱引用计数器不清零，则控制块占用的内存不会被回收。因此若控制块很大（直接存放了资源），则空间性能可能变差。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 别名构造函数（aliasing constructor）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( <span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r, element_type* ptr )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新智能指针共享与 r 的控制块，但是 this-&gt;get() 总是返回 ptr，这可以与 r.get() 不相同！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">场景：ptr 是 *r 的数据成员，若 r 存活，则 ptr 必定存活。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr-的潜在坑点"><a href="#shared-ptr-的潜在坑点" class="headerlink" title="shared_ptr 的潜在坑点"></a>shared_ptr 的潜在坑点</h3><ol>
<li>环形引用导致内存泄漏：使用一个 <code>weak_ptr</code> 来打破环形引用。</li>
<li>不支持 <code>shared_ptr&lt;T[]&gt;</code>：使用 <code>vector</code> 或 <code>array</code> 作容器。</li>
<li>容许基类析构函数不是虚函数（似乎是因为构造是泛型的）：小心。</li>
<li>退化成链状的数据结构在析构时<strong>栈溢出</strong>：反思数据结构的退化，以及是否滥用了 <code>shared_ptr</code>。</li>
<li>重复使用一个裸指针构造两个 <code>shared_ptr</code>，导致双重释放：<ol>
<li>裸指针用完就扔。</li>
<li>不要使用 <code>this</code> 来构造智能指针，而是使用 <code>shared_from_this</code>。<em>这是潜在坑点。</em></li>
</ol>
</li>
<li>若没有任何 <code>shared_ptr</code> 持有对象，此时调用 <code>shared_from_this</code> 就会出问题：<ol>
<li>C++17 之前，这是 UB。</li>
<li>C++17 以后，程序抛出 <code>std::bad_weak_ptr</code> 异常。</li>
<li>最佳实践是禁止访问构造函数，而提供工厂函数返回智能指针。</li>
</ol>
</li>
<li>将 <code>shared_ptr</code> 复制给未知的函数，可能导致环形引用。<ul>
<li>好比不要在上锁后执行为未知用户代码</li>
<li>GC 语言同样有回调地狱导致内存泄漏的问题</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enable_shared_from_this 最佳实践</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Best</span> : std::enable_shared_from_this&lt;Best&gt; <span class="comment">// 公有继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Best&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工厂函数返回智能指针</span></span><br><span class="line">    <span class="comment">// nodiscard 防止暴毙</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">static</span> std::shared_ptr&lt;Best&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能使用 make_shared 因为构造函数是私有的，不能转发</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Best&gt;(<span class="keyword">new</span> <span class="built_in">Best</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Best</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr-的应用场景-x2F-条件"><a href="#shared-ptr-的应用场景-x2F-条件" class="headerlink" title="shared_ptr 的应用场景&#x2F;条件"></a>shared_ptr 的应用场景&#x2F;条件</h3><ol>
<li>多线程&#x2F;异步协作，难以确定资源生命周期。</li>
<li>主从关系明确，不存在环形引用：树、链表、DAG</li>
<li>可以在构造函数参数中提供自定义析构器：<code>[](Y* rc) &#123; delect rc; &#125;</code>。</li>
<li>原本使用 <code>unique_ptr</code> 的数据结构，需要对外提供强引用，则可以改用 <code>shared_ptr</code>。</li>
</ol>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>独占所有权的智能指针。当持有资源且退出作用域时，会析构资源。所有权只能移动或引用，不能拷贝。</p>
<h3 id="unique-ptr-的潜在坑点"><a href="#unique-ptr-的潜在坑点" class="headerlink" title="unique_ptr 的潜在坑点"></a>unique_ptr 的潜在坑点</h3><ol>
<li>退化成链的数据结构在析构时<strong>栈溢出</strong>：反思数据结构；重写数据结构的析构函数。</li>
</ol>
<h3 id="unique-ptr-的应用场景"><a href="#unique-ptr-的应用场景" class="headerlink" title="unique_ptr 的应用场景"></a>unique_ptr 的应用场景</h3><ol>
<li>提供动态对象的 RAII，保证发生异常时对象仍被析构。</li>
<li>表示对堆对象的独占关系。适合用作类的数据成员，例如表示树的儿子。<ul>
<li>父亲指针永远只用裸指针，因为儿子存活时父亲一定存活</li>
<li>单&#x2F;双向链表是树的特例，也适用 <code>unique_ptr</code> + 裸指针。</li>
</ul>
</li>
<li>在接口中明确表达「传递所有权」的语义。</li>
<li>作为具有移动语义的单个容器使用。</li>
<li>管理运行时确定长度的定长数组（<code>unique_ptr&lt;T[]&gt;</code> 正确使用 <code>new []</code> <code>delete []</code>）</li>
<li>用于 Pimpl 编译隔离</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pimpl 抽象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Pimpl = <span class="type">const</span> unique_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>; <span class="comment">// 定义于 *.cpp</span></span><br><span class="line">    Pimpl&lt;Impl&gt; pimpl;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时定长数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">const</span> unique_ptr&lt;Data[]&gt; array;</span><br><span class="line">    <span class="type">size_t</span> arr_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">size_t</span> size): <span class="built_in">arr_size</span>(<span class="built_in">make_unique</span>&lt;Data[]&gt;(size)) &#123;&#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>从 <code>shared_ptr</code> 构造而来，但不参与引用计数。</p>
<h3 id="weak-ptr-的潜在坑点"><a href="#weak-ptr-的潜在坑点" class="headerlink" title="weak_ptr 的潜在坑点"></a>weak_ptr 的潜在坑点</h3><p>良好的设计使得 <code>weak_ptr</code> 坑点较少，只需记得弱引用的存在会使得控制块无法释放即可。</p>
<h3 id="weak-ptr-的应用场景"><a href="#weak-ptr-的应用场景" class="headerlink" title="weak_ptr 的应用场景"></a>weak_ptr 的应用场景</h3><ol>
<li>打破 <code>shared_ptr</code> 的循环引用。常用于环形链表、回调函数。</li>
<li>作为「可空资源的观察者」。根据资源是否为空表现不同的行为。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weak_ptr 做回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad</span><span class="params">(<span class="type">const</span> shared_ptr&lt;X&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">on_draw</span>([=]&#123; x-&gt;<span class="built_in">extra_work</span>(); &#125;); <span class="comment">// x 已经泄露</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good</span><span class="params">(<span class="type">const</span> shared_ptr&lt;X&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">on_draw</span>([w=<span class="built_in">weak_ptr</span>&lt;X&gt;(x)] &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> x = w.<span class="built_in">lock</span>()) x-&gt;<span class="built_in">extra_work</span>(); <span class="comment">// x 有机会析构</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// weak_ptr 做 cache</span></span><br><span class="line"><span class="function">shared_ptr&lt;Payload&gt; <span class="title">create</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> map&lt;<span class="type">int</span>, weak_ptr&lt;Payload&gt;&gt; cache;</span><br><span class="line">    <span class="type">static</span> mutex mut_cache;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">hold</span><span class="params">(mut_cache)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> sp = cache[id].<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!sp) cache[id] = sp = <span class="built_in">make_shared</span>&lt;Payload&gt;();</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://en.cppreference.com/w/cpp/memory">cppreference</a></li>
<li><a href="https://www.youtube.com/watch?v=JfmTagWcqoE">CppCon 2016: Herb Sutter “Leak-Freedom in C++... By Default.”</a></li>
<li><a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">Senlin《谈谈 shared_ptr 的那些坑》</a></li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 多态</title>
    <url>/2022/01/28/C-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<small>
病重躺家，药不能停。<br/>
何以解忧？唯有博客。<br/>
数据在校，不在我心。<br/>
宿舍断电，学校英明！<br/>
回滚旧版，泪眼嘤嘤。<br/>
&nbsp;H T M L ，手写还行！
</small>

<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>「多态」是一个很宽泛的理念，对应繁多实现。本文将记录我所看到的多态的各种形态。作者见识短浅，还请读者多多指教。</p>
<ul>
<li>本文已计划的内容：<ul>
<li><input checked="" disabled="" type="checkbox"> 基于 <code>std::visit</code><ul>
<li><input checked="" disabled="" type="checkbox"> 实现运行时多态的优化</li>
<li><input checked="" disabled="" type="checkbox"> 实现<em>重载模式</em></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> CRTP 实现静态多态<ul>
<li><input checked="" disabled="" type="checkbox"> 静态多态</li>
<li><input checked="" disabled="" type="checkbox"> 静态接口</li>
<li><input checked="" disabled="" type="checkbox"> CRTP 的一些分析和 trick</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> C++20 前基于 SFINAE 的模板偏特化</li>
<li><input disabled="" type="checkbox"> C++20 后基于 <code>concepts</code> 的模板特化</li>
<li><input disabled="" type="checkbox"> Hack 虚函数表，用于优化<span id="more"></span></li>
</ul>
</li>
<li>本文<strong>不会</strong>出现的内容：<ul>
<li><code>virtual</code> 虚函数的基础用法</li>
<li>函数指针模拟虚函数</li>
<li>运行时反射</li>
</ul>
</li>
</ul>
<h1 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h1><h2 id="Runtime-Branching"><a href="#Runtime-Branching" class="headerlink" title="Runtime Branching"></a>Runtime Branching</h2><p>假如你要对一个矢量做线性变换 $\vec{x} &#x3D; k \cdot \vec{x} + b$，又想针对 $k&#x3D;1$ 或 $b&#x3D;0$ 的情况做优化，应该怎么办？</p>
<p>这是最简单却很慢的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">1</span>)</span><br><span class="line">        x[i] *= k;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">        x[i] += b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码满足速度要求，但是太啰嗦：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想两全其美怎么办？可以利用 <code>variant</code> 搭配 <code>visit</code> 使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// since C++17</span></span><br><span class="line"><span class="keyword">using</span> bool_variant = std::variant&lt;std::true_type, std::false_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> bool_variant <span class="title">to_variant</span><span class="params">(<span class="type">bool</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">        <span class="keyword">return</span> std::true_type&#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> std::false_type&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linear</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;x, <span class="type">int</span> k, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    bool_variant has_k = <span class="built_in">to_variant</span>(k != <span class="number">1</span>);</span><br><span class="line">    bool_variant has_b = <span class="built_in">to_variant</span>(b != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> transform = [=, &amp;x](<span class="keyword">auto</span> has_k, <span class="keyword">auto</span> has_b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;xi : x) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">constexpr</span> (has_k)</span><br><span class="line">                xi *= k;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_b)</span></span></span><br><span class="line"><span class="function">                xi +</span>= b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>(transform, has_k, has_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器为 <code>transform</code> 生成四个特化版本，正是我们想要的东西。<code>std::visit()</code> 会在运行时判断 <code>variant</code> 内储存的是哪个 type，然后挑选正确的重载分支。</p>
<p><code>variant</code> + <code>constexpr if</code> 并不是唯一的玩法，我们来看看 <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">cppreference</a> 还有什么花活。</p>
<h2 id="The-Overload-Pattern"><a href="#The-Overload-Pattern" class="headerlink" title="The Overload Pattern"></a>The <em>Overload Pattern</em></h2><p>假设你要 log 一个 <code>variant&lt;int, float, string&gt;</code>，你刚刚学到了 <code>constexpr if</code>，于是你想到这一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> always_false_v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ifs_variant = std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = [](<span class="type">const</span> <span class="keyword">auto</span> &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">float</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">static_assert</span>(always_false_v&lt;T&gt;, <span class="string">&quot;non-exhaustive visitor!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三秒之后你觉得这段代码太丑，太多的 <code>if constexpr</code> 和 <code>is_same_v</code> 语句影响阅读，你也不想用 <code>always_false_v&lt;T&gt;</code> 这样的孤儿代码。于是你想到了重载 <code>opeartor()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; logger;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会在缺少某个重载时报错（模板巨型报错），长度也合理，你的血压下降了一些，但仍未到安全区，因为 <code>void operator()</code> 的重复依然很丑。你想用模板元编程自动化这些函数重载。你的目标是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="comment">// Import all function whatever the parameter is.</span></span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样当你用 lambda 的类型做模板参数，就能自动导入 lambda 的 <code>opeartor()</code>。问题来了，你怎么传入 lambda 的类型？你根本没有办法用尖括号 <code>&lt;&gt;</code> 来指定 lambda 类型！而自动类型推导至少需要一个函数调用，你想到了构造函数！可以在构造函数中传入 lambda，这样就能推导出 <code>Lambdas</code> 的具体类型！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Overloaded</span>(Lambdas&amp;&amp;...) &#123;&#125; <span class="comment">// Bang!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = Overloaded&#123;</span><br><span class="line">        [](<span class="type">int</span> i) &#123; std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">float</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">const</span> std::string &amp;s) &#123; std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">visit</span>(logger, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bang! 第五行编译报错，编译器说，你企图使用 Lambda 的默认构造函数，但这个函数是 <code>deleted</code>！</p>
<p>想了半天，你顿悟过来，Overloaded 的构造函数一定要显式调用 Lambdas 的构造函数才行，于是你写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Overloaded</span>(Lambdas &amp;&amp;...t) : Lambdas&#123;std::forward&lt;Lambdas&gt;(t)&#125;... &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译终于过了！你还擅长举一反三，联想到 <code>make_tuple()</code> 可以在没有尖括号 <code>&lt;&gt;</code> 的情况下工作，你可以模仿它，于是你写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Lambdas... &#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Lambdas::operator</span><span class="params">()</span>...</span>;</span><br><span class="line">    <span class="comment">// no more explicit ctor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Lambdas&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">make_Overloaded</span><span class="params">(Lambdas &amp;&amp;...t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Overloaded&lt;Lambdas...&gt;&#123;std::forward&lt;Lambdas&gt;(t)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很秀也很正确。可惜好景不长，一个保洁阿姨路过了你，说，小伙子你写的不行，来看我秀一手：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">Overloaded</span><span class="params">(Ts...)</span> -&gt; Overloaded&lt;Ts...&gt;</span>;</span><br></pre></td></tr></table></figure>

<p>编译通过！阿姨的第二行模板恰好替代了 <code>make_Overloaded</code>，正确推导出所有模板参数！这是 C++17 的新功能 *<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Custom Template Argument Deduction Rules</a>*。这一功能在 C++20 中更加智能，所以你可以删掉那行显式推导规则。</p>
<p>现在，你进化成了 <code>std::visit</code> 不用 <code>Overloaded&#123;&#125;</code> 就不舒服星人。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span> <span class="comment">// C++17</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ifs_variant = std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">Overloaded</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="title">Overloaded</span><span class="params">(Ts...)</span> -&gt; Overloaded&lt;Ts...&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> ifs_variant &amp;arg)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">visit</span>(Overloaded&#123;</span><br><span class="line">        [](<span class="type">int</span> i) &#123; std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">float</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">        [](<span class="type">const</span> std::string &amp;s) &#123; std::cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;,</span><br><span class="line">    &#125;, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ifs_variant i&#123;<span class="number">10</span>&#125;, <span class="built_in">f</span>(<span class="number">0.7f</span>), s&#123;<span class="string">&quot;string&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">log</span>(i);</span><br><span class="line">    <span class="built_in">log</span>(f);</span><br><span class="line">    <span class="built_in">log</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="The-CRTP"><a href="#The-CRTP" class="headerlink" title="The CRTP"></a>The <em>CRTP</em></h1><p>Curiously recurring template pattern (CRTP) 是指一个类的父类的模板参数含有自己。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : Counter&lt;Foo&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此一来，父类在编译期就知道自己的派生类型，可以利用这一点做很多事，比如模板化的对象计数器、编译期多态、非退化的链式调用、模板化接口实现等等。网上很多声音说 CRTP 主要是用来消除动态绑定，但我认为 CRTP 主要是用来约束和简化代码的。我们来看看 CRTP 到底有什么用。</p>
<h2 id="Static-Polymorphism"><a href="#Static-Polymorphism" class="headerlink" title="Static Polymorphism"></a>Static Polymorphism</h2><p>由于父类知道派生类型，我们可以用 <code>static_cast&lt;T*&gt;(this)</code> 一步到位，将自己向下转型。还可以调用 <code>T::static_func</code> 实现静态分发。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">member_func_impl</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_func_impl</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func_impl</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Obj::member_func_impl\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func_impl</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Obj::static_func_impl\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Obj a;</span><br><span class="line">    Base&lt;Obj&gt; &amp;ref = a;</span><br><span class="line">    ref.<span class="built_in">member_func</span>();</span><br><span class="line">    Base&lt;Obj&gt;::<span class="built_in">static_func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会不会觉得有点脱裤子放屁？这样写有什么优势？用了 CRTP 之后，就宣告丧失了动态分发的能力，那为什么不干脆把 <code>Base</code> 类删掉呢？</p>
<p>有人说，<code>Base</code> 类描述了子类应该实现的几个函数，而且没有运行时开销。我认为最好使用 C++20 concept 来实现这种编译期约束。用 CRTP 是可以的，但是请注意标识符命名，我们来看一些 Bugs。</p>
<h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// Notice the &quot;T::member_func()&quot;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">member_func</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)-&gt;T::<span class="built_in">member_func</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_func</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="comment">// empty!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译没有任何报错，而程序在运行时会因为无穷递归而陷入栈溢出。所以千万<strong>不要为了美观，让子类重复基类的函数名</strong>。</p>
<p>我们再看一个人为制造的错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj2&gt; &#123; <span class="comment">// a bug compiles</span></span><br><span class="line">    <span class="comment">// implementation which is unused</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不会给你任何提醒，而你，<code>Obj</code>，沦为 <code>Obj2</code> 的替身。所幸的是，这个 bug 是可以修复的！只要将 <code>Base</code> 的构造函数设为私有，再加一个友元即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Base&lt;Obj2&gt; &#123; <span class="comment">// Instantiating Obj does not compile</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，<code>Obj</code> 无权访问 <code>Base</code> 的构造函数，如果企图构造 <code>Obj</code> 对象，编译器会报错，然而你还是要检查半天才能发现，原来是 CRTP 写错了！更惨的是，如果你只调用静态成员，那么编译通过！天王老子来了都不报错！慢慢找 Bug 吧你就。</p>
<h2 id="Template-Interface-Implementation"><a href="#Template-Interface-Implementation" class="headerlink" title="Template Interface Implementation"></a>Template Interface Implementation</h2><p>目前为止 CRTP 被我批评得太多了，实际上 CRTP 还是有点用的，它可以模板化接口实现，而这一点在 C++20 concept 中我暂时没发现对应的东西。</p>
<p>假设你要设计一个 <code>Scaleable</code> 接口，对于每一个具体类，它的逻辑都是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable &#123;</span><br><span class="line">    <span class="comment">// getter, setter ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">double</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">setValue</span>(<span class="built_in">getValue</span>() * k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你立即想到  </p>
<ol>
<li>你不需要 <code>Scaleable</code> 的动态绑定  </li>
<li>每个类都复制粘贴一样的代码十分愚蠢  </li>
<li>C++20 concept 不能提供默认成员实现（作者以为的。如果可以请告诉我）</li>
</ol>
<p>你知道可以用 CRTP！于是你设计出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line">    <span class="function">T &amp;<span class="title">scale</span><span class="params">(K &amp;&amp;multiplicator)</span> </span>&#123;</span><br><span class="line">        T &amp;self = <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        self.<span class="built_in">setValue</span>(self.<span class="built_in">getValue</span>() * multiplicator);</span><br><span class="line">        <span class="keyword">return</span> self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable&lt;Obj&gt; &#123;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">double</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很漂亮，还支持非退化的链式调用。最重要的是，它在 <code>Obj</code> 定义时就表明了 Scaleable 的语义。如果使用 C++20 concept 或者其他非成员函数去实现，<code>scale</code> 的实现就可能藏在某个 header 里，你不能一眼看出 <code>Obj</code> 是否 Scaleable，语义的表达就会被割裂。</p>
<p>聪明的你又想到了接口方法还可以是类外的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T &amp;<span class="title">scale</span><span class="params">(Scaleable&lt;T&gt; &amp;x, <span class="type">double</span> k)</span> </span>&#123;</span><br><span class="line">    T &amp;self = <span class="built_in">static_cast</span>&lt;T &amp;&gt;(x);</span><br><span class="line">    self.<span class="built_in">setValue</span>(self.<span class="built_in">getValue</span>() * k);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很像 C++20 concept？我觉得很像！</p>
<h2 id="A-CRTP-Helper"><a href="#A-CRTP-Helper" class="headerlink" title="A CRTP Helper"></a>A CRTP Helper</h2><p>每次实现 CRTP 接口的时候，有很多重复工作要做，比如千篇一律的 <code>static_cast</code> 要写，还有 private ctor + friend class 定式，太繁琐。<br>本来使用 CRTP 的初衷就是简化代码，如今岂不是南辕北辙？</p>
<p>你想到可以抽象出所有的 CRTP 接口的公共部分，做成一个基类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> : CRTP&lt;T&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这看起来很美好，可是很快你又发现了问题：多个接口造成菱形继承：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diamond inheritance: CRTP&lt;T&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> : Scaleable&lt;Obj&gt;, Lengthable&lt;Obj&gt; &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里使用虚继承无助于解决问题：被虚继承的基类是不能用 <code>static_cast</code> 向下转型的。</p>
<p>试过很多方案都不能解决菱形继承问题（如果有请告诉我），只能硬避开菱形继承了：</p>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Interface</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> Interface&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scaleable</span> : CRTP&lt;T, Scaleable&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lengthable</span> : CRTP&lt;T, Lengthable&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这样一来，<code>Scaleable</code> 和 <code>Lengthable</code> 的基类是两个不同的类，同时保持了零开销抽象，完美解决问题。</p>
<p>仔细观察你会发现，CRTP 避开菱形继承的手段恰好是 CRTP！</p>
<p>顺便提醒一句，调用 <code>self()</code> 的时候必须写 <code>this-&gt;self()</code>，否则编译器不知道正确的名字空间。</p>
<h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>你很可能已经感觉到把 CRTP 当作接口用有什么好处：  </p>
<ol>
<li>接口表达了清晰、明确的语义；  </li>
<li>既可以重写实现，又可以提供默认实现，十分灵活；  </li>
<li>编译期内联能力，零开销抽象；  </li>
<li>链式调用时类型不会退化。<br>但 CRTP 也有不足之处：  </li>
<li>本质上是语言表达能力不足的妥协（还是推荐 concept）；  </li>
<li>要求类继承接口，不利于库设计；  </li>
<li>难以表达两种接口的交集；  </li>
<li>容易写 Bug，编译报错信息不友好；  </li>
<li>宣告放弃动态绑定，需要谨慎设计。</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1pq4y1y7oN">双笙子佯谬 - 聊一聊C++设计模式、函数式编程等</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/visit">std::visit - cppreference.com</a></li>
<li><a href="https://www.cppstories.com/2019/02/2lines3featuresoverload.html/">2 Lines Of Code and 3 C++17 Features - The overload Pattern - C++ Stories</a></li>
<li><a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern - Wikipedia</a></li>
<li><a href="https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/">What the Curiously Recurring Template Pattern can bring to your code - Fluent C++</a></li>
<li><a href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">An Implementation Helper For The Curiously Recurring Template Pattern - Fluent C++</a></li>
<li><a href="http://baiy.cn/doc/cpp/inside_rtti.htm">白杨 - RTTI、虚函数和虚基类的实现方式、开销分析及使用指导</a></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 标准笔记</title>
    <url>/2021/05/03/C/</url>
    <content><![CDATA[<p>本文始于 2018&#x2F;6&#x2F;27，用于汇聚关于 C++ 的实用知识和碰到的坑，温故而知新。</p>
<blockquote>
<p>2022&#x2F;1&#x2F;2 【更改】标题改为《C++ 标准笔记》<br>2022&#x2F;1&#x2F;2 【新增】StandardLayout<br>2022&#x2F;1&#x2F;2 【新增】bit field</p>
<p>更新预告：</p>
<ol>
<li>CRTP 原理，目的和应用</li>
<li>CRTP 应用之表达式模板</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h2><ul>
<li>union可匿名，常在结构定义中。</li>
<li>用于节省内存，尤其在嵌入式系统中。</li>
<li>union的定义形式与struct相同。</li>
</ul>
<hr>
<h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum 枚举"></a>enum 枚举</h2><ul>
<li>enum A {a,b,c};   首项默认为0，默认后项比前项大一。<br>A被看做一种类型，甚至可以省略；a,c,b被看做常量。<br>a,b,c可以自动提升为int, 但int不能自动转换为枚举类型，除非强制转换A（1）。<br>每个enum根据其常量的最大最小值确定其上下限。</li>
<li>enum创建的常量是静态的, 可以用作静态类成员常量. 运行时所有对象不会包含枚举</li>
<li><strong>更强的安全性--类作用域内枚举(C++11)</strong><ul>
<li>enum class name : type {...};</li>
<li>enum struct name {...};</li>
<li>class或struct二选一, <code>:type</code>可选.</li>
<li>作用域内枚举不允许隐式地转换为整型</li>
<li>默认底层为int</li>
<li>调用格式为name::x</li>
</ul>
</li>
<li>:type 放在枚举名后以指定底层, 否则将随实现而异.</li>
</ul>
<hr>
<h2 id="char-字符型"><a href="#char-字符型" class="headerlink" title="char 字符型"></a>char 字符型</h2><ul>
<li>char类型被输入输出流区别对待。cout &lt;&lt; (int*) st &lt;&lt; endl;</li>
<li>char类型数组的初始化被C++区别对待：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>; 合法,<span class="string">&quot;abcd&quot;</span>被转换为&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;, 可供修改</span><br><span class="line"><span class="type">char</span> s2[<span class="number">5</span>] = s1; 错误，即使s1是<span class="type">const</span>。</span><br><span class="line"><span class="type">char</span>* s3 = <span class="string">&quot;abcd&quot;</span>; 警告, <span class="string">&quot;abcd&quot;</span>是常量,不能修改.   参数<span class="type">char</span> s3[]=<span class="string">&quot;abcd&quot;</span>亦等价警告.</span><br></pre></td></tr></table></figure></li>
<li><code>const char []</code>所定义的字符串被保护，有内存位置隔离，不允许跟踪（但允许查看）地址。</li>
<li>char是否带符号取决于系统。</li>
<li>wchar_t可以表示系统使用的最大扩展字符集，输入输出用wcin,wcout</li>
<li>raw r&quot;(a&#x2F;b\c回车defg*)&quot;,   标识符  &quot;(   )&quot;  可变为 &quot;*@(  )*@&quot; 等等，保持平移对称</li>
</ul>
<h3 id="lt-cstring-gt-常用函数"><a href="#lt-cstring-gt-常用函数" class="headerlink" title="&lt;cstring&gt;常用函数"></a>&lt;cstring&gt;常用函数</h3><ul>
<li><code>char* strcpy(char* dest, const char* src)</code><ul>
<li>以src覆盖dest, 直到遇到src的终止符.返回dest.</li>
</ul>
</li>
<li><code>char* strncpy(char* dest, const char* src, size_t count)</code><ul>
<li>以src的前n位覆盖dest, 若遇到src的终止符则用0填充剩余位.返回dest.</li>
</ul>
</li>
<li><code>char* strcat(char *dest, char *src)</code><ul>
<li>将src复制到dest的末尾.返回dest.</li>
</ul>
</li>
<li><code>int strcmp(char *str1, char *str2)</code><ul>
<li>按字典序比较, 返回-1,0,1.</li>
</ul>
</li>
<li><code>int stricmp(char *str1, char *str2)</code><ul>
<li>按字典序但对大小写不敏感比较.</li>
</ul>
</li>
<li><code>int strncmp(char *str1, char *str2, size_t count)</code><ul>
<li>按字典序比较前n位</li>
</ul>
</li>
<li><code>int strnicmp(char *str1, char *str2, size_t count)</code><ul>
<li>按字典序但对大小写不敏感比较前n位</li>
</ul>
</li>
</ul>
<hr>
<h2 id="vector与array-模板类"><a href="#vector与array-模板类" class="headerlink" title="vector与array 模板类"></a>vector与array 模板类</h2><ul>
<li><code>vector&lt;typename&gt; arr(n_elem);</code> 也可以不指定长度</li>
<li><code>array&lt;typename, n_elem&gt; arr;</code> 定长数组。 等长数组可以直接复制。</li>
<li>下标可越界，欲防止越界用 <code>arr.at(x)</code></li>
</ul>
<hr>
<h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><ul>
<li><code>cin.getline(arr, arsize)</code> 空行不设置failbit</li>
<li><code>cin.get(arr, arsize)</code> 行读取结束后不丢弃换行符（无法跨越）</li>
<li><code>cin.get()</code> 读取一个任意字符，返回char值</li>
<li><code>cin.get(char)</code>返回cin</li>
<li><code>string</code>类读行 <code>getline(cin, str);</code></li>
</ul>
<hr>
<h2 id="fstream-文件流（以fin-fout为例）"><a href="#fstream-文件流（以fin-fout为例）" class="headerlink" title="fstream 文件流（以fin, fout为例）"></a>fstream 文件流（以fin, fout为例）</h2><ul>
<li>打开文件： <code>.open(&quot;filename&quot;);</code></li>
<li>关闭文件： <code>.close();</code></li>
<li>检测最后一次读入遇到EOF： <code>fin.eof();</code></li>
<li>检测最后一次读入遇到类型不匹配（包括EOF）： <code>fin.fail();</code></li>
<li>检测最后一次读入文件损坏、故障： <code>fin.bad();</code></li>
<li>检测最后一次读入完全正常： <code>fin.good();</code>  等价于 <code>(bool) fin &gt;&gt; value;</code></li>
<li>清空错误标记，准许读入： <code>.clear();</code></li>
</ul>
<hr>
<h2 id="switch-结构控制"><a href="#switch-结构控制" class="headerlink" title="switch 结构控制"></a>switch 结构控制</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constValue1 : statement1</span><br><span class="line">            <span class="keyword">break</span>;(optional)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> constValue2 : statement2</span><br><span class="line">            <span class="keyword">break</span>;(optional)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> : statement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><code>exit(EXIT_FAILURE);</code>   ： cstdlib, 同操作系统通信的参数值</li>
<li><code>nullptr</code> : C++11 关键字, 空指针值.</li>
</ul>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>应当将空指针写为<code>nullptr</code>. <code>delete</code>和<code>delete []</code> 都可以作用于空指针.</li>
<li>const 指针 将受保护，非const 指针 不能复制其值（除非利用强制类型转换），不允许通过const 指针 修改所指向值。<br>为了防止欺骗const检查，不允许令const 二级指针指向非const 一级指针</li>
</ul>
<hr>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>声明：<code>typename (*pointer name)(parameter list...);</code></li>
<li>获得某函数的地址：<code>pointer = function name;</code></li>
<li>使用函数指针：<code>(*pointer)(parameter list...);</code>  或  <code>pointer(parameter list...);</code></li>
<li>举例：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">原函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span>* <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">指向f1的指针：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*p1)(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>) = f1; 或 <span class="keyword">auto</span> p1 = f1;</span><br><span class="line"></span><br><span class="line">由f1,f2,f3组成数组：<span class="comment">//[]优先级高于*</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*ar[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>) = &#123;f1, f2, f3&#125;; 不允许<span class="keyword">auto</span></span><br><span class="line"></span><br><span class="line">指向ar[<span class="number">3</span>]的指针：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>* (*(*arp)[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span>[], <span class="type">int</span>) = &amp;ar; 或 <span class="keyword">auto</span> arp = &amp;ar；</span><br><span class="line"></span><br><span class="line">还可以用<span class="keyword">typedef</span>简化声明：</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">double</span>* (*p_fun)<span class="built_in">const</span>(<span class="type">const</span> <span class="type">double</span> [], <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">p_fun ar[<span class="number">3</span>] = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure></li>
<li>分析方法: 从变量名开始, 往右往左结合, 逐步解释结合体.<ul>
<li>当遇到一个指针, 总是关心它指向什么类型</li>
<li>当遇到一个数组, 总是关心它的元素的类型</li>
<li>当遇到一个函数, 总是关心它的返回值类型</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>参量（argument）是实参，参数（parameter）是形参。</li>
</ul>
<hr>
<h2 id="函数重载（函数多态）"><a href="#函数重载（函数多态）" class="headerlink" title="函数重载（函数多态）"></a>函数重载（函数多态）</h2><ul>
<li>同名函数共存要求：函数特征标（函数参数列表）不同。</li>
<li>当需要自动类型转换但选项不唯一时，编译不通过。</li>
<li>不区分const和非const变量（包括指针）。</li>
<li>区分指向const的指针和指向非const的指针。</li>
<li>区分指向const的引用和指向非const的引用。（编译器调用最匹配的版本）</li>
<li>如果没有右值引用参数版本，右值参量将赋给const引用参量。</li>
</ul>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>左值引用<ul>
<li>非const引用可以引自可修改的左值（防止修改const值和修改临时变量）</li>
<li>const引用可以引自任何左值、右值（毕竟数值不会变）</li>
<li>基类引用可以指向派生类对象</li>
</ul>
</li>
<li>指针也能被引用, 例如 int*&amp; x &#x3D; ptr;</li>
</ul>
<hr>
<h2 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h2><ul>
<li>||, &amp;&amp;具有短路作用,结果必然时短路,不计算右边的表达式</li>
</ul>
<hr>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><ul>
<li>在声明时用或在第一次调用前的定义用都行</li>
<li>不能处理递归, 编译器有权拒绝采用.</li>
<li>函数默认值必须放在原型声明中, 不能放在和声明分离的定义中.只能从右到左地提供默认值</li>
</ul>
<hr>
<h2 id="decltype-expression"><a href="#decltype-expression" class="headerlink" title="decltype(expression)"></a>decltype(expression)</h2><ul>
<li><p><strong>decltype(expression)核对表</strong></p>
<ol>
<li>如果expression是一个不带括号的标识符, 则返回相同类型, 包括const,*等限定符</li>
<li>否则,如果expression是一个函数调用(需要提供参数),则返回相同类型</li>
<li>否则,如果expression是一个带括号的左值,则返回其引用</li>
<li>否则,返回expression的类型(例:右值)</li>
</ol>
</li>
<li><p>可以利用<strong>typedef</strong> decltype(expression) somename;简化声明</p>
</li>
<li><p><strong>decltype 用于函数返回类型声明</strong></p>
<ul>
<li>声明返回类型时未知参数列表, 所以需要后置声明  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">gt</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span>     <span class="comment">// &quot;-&gt; 已知类型&quot;  也行</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p><strong>创建模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//也可以用class代替typename</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp;, T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>显式具体化</strong></p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp;, <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>&amp;, <span class="type">int</span>&amp;);</span><br></pre></td></tr></table></figure>
<p>  <em>为什么需要显示具体化?常规函数不能替代吗?</em></p>
</li>
<li><p><strong>显式实例化</strong></p>
<ul>
<li>不使用函数就能依照模板生成实例, 常用在库中</li>
<li><code>template void swap&lt;int&gt;(int&amp;, int&amp;);</code></li>
<li>使用函数时<code>add&lt;double&gt;((int)a, (double)b);</code> 会强制使用<double>模板.注意引用类型不能隐式类型转换.后续的强制使用仍需加&lt;double&gt;</li>
</ul>
</li>
</ul>
<hr>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="::变量名"></a>::变量名</h2><ul>
<li>表明采用全局变量而非局部变量</li>
</ul>
<hr>
<h2 id="储存空间"><a href="#储存空间" class="headerlink" title="储存空间"></a>储存空间</h2><ol>
<li>静态储存: 保证初始化为0, 生命周期和程序相同.</li>
<li>自动储存(栈内存): 不保证初始化;</li>
<li>动态储存(堆内存): 不保证初始化;</li>
</ol>
<hr>
<h2 id="储存说明符"><a href="#储存说明符" class="headerlink" title="储存说明符"></a>储存说明符</h2><ul>
<li>static用于变量   <em>编译阶段尽量初始化, 运行时直接分配空间,程序结束时销毁, 首次遇到时再保证初始化</em><ul>
<li>静态外部链接性变量: 直接在非被包括区域定义, 在其他单元中可用extern引用声明(不允许再次初始化)(ODR单定义规则)</li>
<li>静态内部链接性变量: 在非被包括区域加static, 限定在本单元内可以访问</li>
<li>静态无链接性变量:在被包括区域加static, 限定在本包括区域内可以访问</li>
</ul>
</li>
<li>static用于函数 覆盖函数的默认外部链接性为内部链接性,必须同时用于原型和定义中.</li>
<li>thread_local 变量持续性与所属线程的持续性相同, 可与static, extern结合使用(其他声明中不能使用多个储存说明符)</li>
<li>mutable 使得const对象中的属性能被修改,而不受const限制</li>
<li>register C++11之前是寄存器变量,不能取地址;  之后是显式指明自动变量(无实际作用,避免旧代码非法)</li>
</ul>
<hr>
<h2 id="显式指出语言链接性以帮助链接程序寻找匹配函数"><a href="#显式指出语言链接性以帮助链接程序寻找匹配函数" class="headerlink" title="显式指出语言链接性以帮助链接程序寻找匹配函数:"></a>显式指出语言链接性以帮助链接程序寻找匹配函数:</h2><pre><code>extern &quot;C&quot; void spiff(int);
</code></pre>
<hr>
<h2 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv-限定符"></a>cv-限定符</h2><pre><code>- const全局变量带有隐式static使得变量链接性为内部, 导致多文件同时include一个头文件时不会发生定义冲突 *可以使用extern覆盖隐式static使变量链接性为外部. 在其他单元中仍需用extern来引用它.*
- volatile 提示编译器该变量会在程序之外被修改, 不要进行寄存器缓存优化. 多见于驱动程序.
</code></pre>
<hr>
<h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><ul>
<li>原函数:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[] (std::size_T); <span class="comment">// new int[40] --&gt; new(40*sizeof(int))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="type">void</span> *);</span><br></pre></td></tr></table></figure></li>
<li>new, delete函数可以替换.</li>
<li>new在堆中查找满足要求的内存块</li>
<li>定位new运算符<ul>
<li><code>typename* p = new (MemAddress) typename</code></li>
<li>返回(void *)指定的内存地址</li>
<li>允许重载</li>
<li><strong>注意非堆内存不可delete</strong></li>
<li><strong>若内存中存放了对象，则需要手动调用析构函数，再由MemAddress释放内存，且需注意new []与delete []对应</strong></li>
</ul>
</li>
<li>元素的创建与销毁应遵循FILO顺序</li>
</ul>
<hr>
<h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><ul>
<li>声明区域: 可以声明变量的区域, 例如所在的文件, 代码块.</li>
<li>潜在作用域: 从声明点开始到声明区域的结尾. 可能被局部变量隐藏,故称潜在.</li>
<li>自定义名称空间:<code>namespace Somewhat &#123;...&#125;</code><ul>
<li>只能在函数外部定义, 允许在另一个名称空间中嵌套</li>
<li>因此, 默认情况下声明的名称的链接性为外部(除非它引用了常量)</li>
<li>可以在其他合法位置继续添加名称, 提供定义.</li>
</ul>
</li>
<li><code>using namespace Somewhat;</code>编译指令<ul>
<li>每个声明区域中都有一条隐式的<code>using namespace 全局名称空间;</code></li>
<li>若某处使用过<code>using namespace</code>编译指令,则其子声明区域也隐式添加这条语句.</li>
<li>局部变量拥有最高优先权,能隐藏各种using namespace同名变量(因为名称空间都在函数外部定义)</li>
</ul>
</li>
<li><code>using</code>声明<ul>
<li>类似于声明了一个局部变量, 在代码块中不允许同级同名.</li>
<li>因此使用using声明比使用using编译指令更安全.</li>
</ul>
</li>
<li>名称空间可以拥有别名, 用于简化代码: namespace MEF &#x3D; myth::elements::fire;</li>
<li>名称空间可以匿名, 声明之后自动隐式using, 用于避免其他using并替代static全局变量.</li>
<li>&lt;.h&gt;文件是不支持名称空间的版本.新版一般将函数搬到std中.</li>
<li>使用建议: 在大型程序&#x2F;多单元程序使用<ul>
<li>少用<code>using namespace</code></li>
<li>避免在头文件中使用using编译指令,若必须使用,则在所有#include之后使用</li>
<li>避免直接声明外部全局变量和静态全局变量,改用已命名的名称空间</li>
<li>using声明首选用在局部而不是全局</li>
</ul>
</li>
</ul>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>构造函数<ul>
<li>调用示例:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Classname object; <span class="comment">// 调用空参数构造函数</span></span><br><span class="line"><span class="function">Classname <span class="title">object</span><span class="params">()</span></span>; <span class="comment">// 警告, 正在声明函数</span></span><br><span class="line"><span class="function">Classname <span class="title">object</span><span class="params">(one, two, ...)</span></span>; <span class="comment">// 调用对应的构造函数</span></span><br><span class="line">Classname object = <span class="built_in">Classname</span>(one, ...); <span class="comment">// 有可能先构造临时对象</span></span><br><span class="line">Classname* p = <span class="keyword">new</span> <span class="built_in">Classname</span>(...);</span><br><span class="line">Classname object&#123;...&#125;; Classname object = Classname&#123;...&#125;; <span class="comment">// C++11</span></span><br><span class="line">Classname* p = <span class="keyword">new</span> Classname&#123;&#125;; <span class="comment">// C++11</span></span><br><span class="line">Classname object = value; <span class="comment">// 调用一个参数的构造函数, 可用explicit(修饰构造函数)关闭这种特性</span></span><br></pre></td></tr></table></figure></li>
<li>重载构造函数中使用的new或new []必须对应，因为析构函数只有一个。</li>
<li>初始化列表<ul>
<li>参数列表后由冒号引出的初始化信息。在此初始化对象将使用复制构造函数，而不是空构造函数加赋值运算符，因此效率更高。</li>
<li>初始化的顺序按照成员变量的声明顺序，而与初始化列表顺序无关。</li>
<li>一旦进入花括号，成员变量将完成默认的初始化，对象初步创建完成。因此，成员变量中，非静态常量与引用必须由此列表进行初始化。</li>
<li>类内初始化可等价于默认的列表初始化。列表初始化会覆盖类内初始化。</li>
<li>初始化列表负责调用基类构造函数（基类已在派生类类域中，无需加作用域解析符）</li>
<li>初始化列表负责调用成员对象的非默认构造函数</li>
</ul>
</li>
<li>默认不能继承构造函数（C++11）</li>
</ul>
</li>
<li>析构函数<ul>
<li>只能有一个析构函数, 且参数必须为空</li>
<li>注意用delete对应构造函数或其他过程的new</li>
<li>若对象由定位new运算符创建，则需要手动调用析构函数，且遵循FILO顺序。</li>
<li>必须以delete或delete []对应构造函数中的new或new []。</li>
<li>最后会自动调用基类的析构函数</li>
<li>应当将析构函数声明为虚函数</li>
<li>不能继承析构函数</li>
</ul>
</li>
<li>封装是一个编译期的概念<ul>
<li>编译期不存在实例，编译器仅针对类型做检查</li>
<li>可以在类方法中访问同类对象的私有成员</li>
</ul>
</li>
<li><em>同struct</em> : 避免环形构造<ul>
<li>编译器禁用简单环形定义, 如 <code> struct A &#123; A a; &#125;; // 使用了未完成的定义</code></li>
<li>编译器不能辨别复杂环形定义, 如<code>struct A &#123; A()&#123;&#125; A* a = new A(); &#125;</code></li>
</ul>
</li>
<li>非静态变量在运行时才会创建, 所以如int arr[MAXN]的MAXN必须是静态量,可以是全局const, 类中static const, enum{MAXN&#x3D;x}.</li>
<li>友元函数<ul>
<li>在共有部分声明友元函数原型, 也可以紧接定义以设为内联函数.后置的定义无需friend修饰</li>
<li>友元函数视为类外函数, 但可以访问类私有成员变量.</li>
<li>类的显式二元重载运算符应当用友元, 尽管没有直接修改类私有成员变量</li>
<li>重载&lt;&lt; : <code>std::ostream&amp; operator &lt;&lt; (const std::ostream&amp; os, const Classname&amp; obj)</code>以方便输出.</li>
<li>友元函数可方便隐式类型转换, 不必苛求由对象发起函数调用.例如cmp(&quot;asd&quot;, obj),可以对应原型cmp(string, string);</li>
<li>可以在派生类友元函数中，强制向上转型并使用基类友元函<br>  数据类型, 否则易有二义性<br>  函数, 避免隐式转换出错<br>  ass_name&amp;)&#96;<br>  始化、按值传递、按值返回、上转型并使用基类友元函数。</li>
</ul>
</li>
<li>转换函数<code>operator typeName()</code><ul>
<li>用途:将类转换成基础数据类型</li>
<li>必须是成员方法</li>
<li>不能指定返回类型</li>
<li>不能有参数</li>
<li>用于cout时应显式标明类型</li>
<li>应当用explicit修饰</li>
</ul>
</li>
<li>复制构造函数<code>Class_name(const Class_name&amp;)</code><ul>
<li>在初始化对象时使用(显示的初始化、按值传递、按值返回、编译器生成临时对象)</li>
<li><strong>新版本C++可用移动构造函数</strong></li>
<li>例:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Class_name <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">Class_name* pa = <span class="keyword">new</span> <span class="built_in">Class_name</span>(b);</span><br><span class="line">Class_name a = b; <span class="comment">// 可能生成临时对象后调用赋值运算符函数,根据实现而异.</span></span><br><span class="line">Class_name a = <span class="built_in">Class_name</span>(b); <span class="comment">// 同上</span></span><br><span class="line">按值传递函数调用<span class="built_in">func</span>(b); <span class="comment">// 按值传递也初始化了参数</span></span><br></pre></td></tr></table></figure></li>
<li>默认的复制构造函数，是在初始化列表中调用所有成员的复制构造函数。默认复制派生类对象的基类部分</li>
<li>应注意<strong>深度复制</strong>, 即妥善处理指针所指向内容的复制</li>
</ul>
</li>
<li>赋值运算符函数<ul>
<li>考虑妥善处理原来已有的,即将被抛弃的数据.</li>
<li>考虑自己赋值给自己的情况, 小心赋值前删除了自身数据.</li>
<li>记住返回自身引用, 即 <code>return *this</code></li>
<li>不能继承赋值运算符函数</li>
<li>不建议设置为虚方法，为了避免同基类的不同派生类互相赋值</li>
</ul>
</li>
<li>默认方法的潜在危险<ul>
<li>某个类在开发初期不需要复制构造函数&#x2F;赋值运算符重载，但在以后可能需要</li>
<li>可能写出符合常理的代码，但由于未覆盖默认方法而运行时异常</li>
<li>可能在未察觉的情况下调用了默认方法（用重载加法时按值传递、按值返回将调用复制构造函数）</li>
<li>解决办法：<ul>
<li>不管默认方法是否需要，总是提供正确的代码</li>
<li>将空方法设为private，并留下错误信息</li>
<li>使用delete（C++11）</li>
</ul>
</li>
</ul>
</li>
<li><code>[ ]</code>(取位)运算符: 两个操作数分立于左中括号两侧。只能是成员函数。</li>
<li>const对象<ul>
<li>只能使用const函数, 若返回引用, 则返回类型为const type&amp;</li>
</ul>
</li>
<li>静态类成员函数<ul>
<li>原型含static, 定义不含</li>
<li>和Java不同, 不能通过对象来调用静态成员函数</li>
<li>调用格式 <code>Class_name::s_method();</code></li>
</ul>
</li>
<li>静态类成员变量<ul>
<li>在类中声明, 不可定义</li>
<li>在类外定义并分配内存, 可以不初始化</li>
<li>静态常量在声明同时定义.</li>
</ul>
</li>
<li>派生&#x2F;继承<ul>
<li><code>class newClass : public baseClase</code></li>
<li>默认继承为private继承。私有继承的向上转型必须显式写出</li>
<li>多重继承的向上转型也应显示写出，以防不同基类的方法冲突</li>
<li>派生类中一旦定义某方法与基类方法同名，则基类所有该名方法被隐藏。与参数列表（特征标）无关。<ul>
<li>可用基类名::方法名的途径调用隐藏的方法</li>
<li>重新定义继承的方法，应确保与原来的原型完全相同</li>
<li>若返回类型为基类引用或指针，则可以修改为派生类的引用或指针（返回类型协变）</li>
<li>若基类虚方法被重载了，则应在派生类中重新定义所有的基类版本</li>
</ul>
</li>
<li>若派生类构造函数使用了new，则应提供复制构造函数&#x2F;赋值运算符（含<code>base::operator=(o);</code>）&#x2F;虚析构函数的定义</li>
<li>公有继承表达了is-a关系，私有继承&#x2F;包含表达了has-a关系。通常使用组合包含层次化来建立has-a关系。如果需要访问原有类的保护成员或重新定义虚方法，才使用私有继承。</li>
<li>欲调用基类对象，对(*this)强制向上转型(const Base &amp;)即可</li>
<li>用using改变继承成员权限：在派生类的public处<code>using Base::methodName;</code>(省略using的技术是即将被抛弃的旧技术)</li>
</ul>
</li>
<li>虚方法<ul>
<li>若希望通过基类引用或指针调用派生类方法，则需要将基类方法声明为virtual虚方法（一般也将派生类方法声明为virtual）</li>
<li>应当将析构函数定义为虚方法，以确保正确地销毁对象</li>
<li>在类中欲调用基类方法(而不是本类方法)，需使用作用域解析符<code>Base::baseMethod();</code></li>
<li>编译器对虚方法的一般实现：把类的所有虚函数的地址制作成表，在对象中添加隐藏的虚函数表指针，在运行时通过指针检索虚函数。</li>
<li>与Java不同，派生类虚方法的访问权限允许变严格，但由基类引用或指针的多态效果仍然生效。</li>
<li>派生类中一旦定义虚方法，就将隐藏基类所有同名方法，故应在派生类中重新定义所有的基类重载方法</li>
<li>可以令虚方法声明结尾处为<code>=0</code>，使方法成为纯虚方法。纯虚方法可以不提供定义。含有至少一个纯虚方法的类为抽象类，不能声明对象。</li>
</ul>
</li>
<li>访问权限<ul>
<li>private：仅本类和友元函数有权访问。对数据成员的理想访问控制。</li>
<li>protected：本类和派生类有权访问。在派生链中，此权限类似public；在类外部，此权限类似peivate。此权限通常只给成员函数。</li>
<li>public：在同一域中就能访问。</li>
</ul>
</li>
<li>引用限定成员函数<ul>
<li>函数签名的最后可以标注<code>&amp;</code>或<code>&amp;&amp;</code>来做「引用限定 ref-qualified」。<ol>
<li>非限定成员函数可由左值调用，也可由右值调用。此时不能再定义引用限定成员函数。</li>
<li>左值限定成员函数仅可由左值调用。</li>
<li>右值限定成员函数仅可由右值调用。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda是一种匿名函数，它在普通函数的基础上增加了一些功能。Lambda是通过函数对象实现的，具有在编译器内联的能力，因此性能可以比函数指针更好。</p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> q, <span class="type">int</span> p) &#123; <span class="keyword">return</span> q &gt; p; &#125; <span class="comment">// 常见的比较函数</span></span><br><span class="line">[mask](<span class="type">int</span> x) &#123; <span class="keyword">return</span> mask &amp; x; &#125; <span class="comment">// 判断有无交集</span></span><br><span class="line">[&amp;flag](<span class="type">int</span> x) &#123; flag[x] = <span class="literal">true</span>; &#125; <span class="comment">// 修改自动变量flag数组</span></span><br><span class="line">[&amp;](<span class="type">int</span> x)-&gt;<span class="type">int</span> &#123;   <span class="comment">// 按引用捕获当前作用域的全部自动变量。不是简单地return故要声明类型</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; mx) mx = x;</span><br><span class="line">    <span class="keyword">return</span> tot += x;</span><br><span class="line">&#125;</span><br><span class="line">[k, &amp;](<span class="type">int</span> del) &#123;  <span class="comment">// 按值捕获k、按引用捕获其他变量</span></span><br><span class="line">    sth += del;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl; <span class="comment">// k是只读的？？！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>rvalue,（非严格定义: ）匿名的临时值，常出现在等号的右方。最大特征是不可取地址，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// (2+3) 就是一个右值， &amp;(2+3)没有意义</span></span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>有时候运算过程中会生成一些体积大的临时对象，在完成表达式后这些临时对象会析构，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">  <span class="type">char</span>* data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//... 使用new和delete的模仿string类，具有拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;MyString&gt; arr; arr.<span class="built_in">reverse</span>(<span class="number">10</span>); <span class="comment">// 保留10个string的空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  arr.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">&quot;Hello_rvalue&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8行发生如下事件：</p>
<ol>
<li>MyString(&quot;Hello_rvalue&quot;) 产生一个右值。</li>
<li>push_back接收一个右值参数，并调用MyString的<strong>拷贝构造函数</strong>新建一个对象。</li>
<li>MyString(&quot;Hello_rvalue&quot;)生命周期结束，析构。</li>
</ol>
<p>发现拷贝构造函数存在资源浪费：既然右值的资源已经没有后续价值，大可以将其资源“偷”过来使用。</p>
<p>于是，MyString类新增<strong>移动构造函数</strong>（还有<strong>移动赋值函数</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">  <span class="comment">// ... 同上</span></span><br><span class="line">  <span class="built_in">MyString</span>(MyString&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = x-&gt;data;</span><br><span class="line">    x-&gt;data = <span class="literal">nullptr</span>; <span class="comment">// 资源被偷走</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; x) &#123;</span><br><span class="line">    <span class="comment">// 类似移动构造函数，不赘述</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如此一来，push_back将自动调用移动构造函数来创建对象，避免大量new内存。</p>
<p>右值引用的存在，就是为了<strong>尽量榨干临时对象的价值</strong>。</p>
<p>要利用右值引用，最重要的是<strong>合理地定义移动构造和移动赋值</strong>。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>有时候一些左值就像右值一样即将消亡，弃之可惜，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="function">string <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	tmp += <span class="string">&quot; rvalue?&quot;</span>; <span class="comment">// tmp经过一系列复杂的处理</span></span><br><span class="line">  arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能像右值引用一般把tmp的资源“偷”走就好了，于是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="function">string <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	tmp += <span class="string">&quot; rvalue?&quot;</span>; <span class="comment">// tmp经过一系列复杂的处理</span></span><br><span class="line">  arr.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp)); <span class="comment">// 强制转换为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，move(tmp)后由于资源已经被偷走，tmp可能像野指针一样危险。被move后对象的行为由程序员负责。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是针对c++模板函数的概念。</p>
<p>我们不得不先介绍c++引用折叠概念：</p>
<table>
<thead>
<tr>
<th>typename T</th>
<th>T&amp;</th>
<th>T&amp;&amp;</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>G&amp;</td>
<td>G&amp;&amp;</td>
</tr>
<tr>
<td>G&amp;</td>
<td>G&amp;</td>
<td><strong>G&amp;</strong></td>
</tr>
<tr>
<td>G&amp;&amp;</td>
<td><strong>G&amp;</strong></td>
<td>G&amp;&amp;</td>
</tr>
</tbody></table>
<p>模板函数的右值引用具有欺骗性！在模板实例化时，<code>T&amp; &amp;&amp;</code> 和<code>T&amp;&amp; &amp;</code>都会被转换为<code>T&amp;</code>。只有<code>T&amp;&amp; &amp;&amp;</code>会成为<code>T&amp;&amp;</code>。利用这一点，我们可只定义<code>T&amp;&amp;</code>的函数行为。</p>
<p><em>（对于简单的情况，<code>T &amp;&amp;</code> 等价于 <code>T&amp;&amp; </code>）</em></p>
<p>但此时也出现了另一个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;&amp; x1)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp;&amp; x2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望，若f1接收左值，那么f2也应该接收左值；如果f1接收右值，那么f2也应该接收右值。但c++规定，“右值引用”是一个左值，因为它有名字，还可以取地址。在这里，f2无论如何都会接收左值。怎样才能写出自动接收左右值的模板函数呢？</p>
<p>利用<strong>任意表达式都能生成匿名值</strong>，最简单的，就像<code>static_cast&lt;T&amp;&amp;&gt;(x1)</code>，此时表达式的结果可以转化为右值。再加上引用折叠的特性，就是<code>std::forward</code>的基本原理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T可以是scalar,object,lref。 但不可能是rref！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;&amp; x1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现了左值转发为左值，右值转发为右值。</span></span><br><span class="line">  <span class="built_in">f2</span>(std::forward&lt;T&gt;(x1)); <span class="comment">// 不能依赖C++17的自动推导，因为x1总是lref！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附：std的实现</span></span><br><span class="line"><span class="comment">// FUNCTION TEMPLATE forward</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an lvalue as either an lvalue or an rvalue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg); <span class="comment">// 注意这里可能发生引用折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FUNCTION TEMPLATE move</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg); <span class="comment">// 注意这里不可能发生引用折叠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>捕获异常时，从具体到抽象，最后到<code>...</code>。</li>
<li>如果异常携带字符串信息，则可能引发<code>std::bad_alloc</code>，惊不惊喜！</li>
<li>std定义的异常分类：<code>#include &lt;stdexcept&gt;</code>  <ol>
<li><code>logic_error</code> 逻辑出错。</li>
<li><code>invalid_argument</code> 无效参数。</li>
<li><code>domain_error</code> 值域错误。（继承自<code>logic_error</code>）</li>
<li><code>length_error</code> 试图超越最大体积。（继承自<code>logic_error</code>）</li>
<li><code>out_of_range</code> 试图越界。（继承自<code>logic_error</code>）</li>
<li><code>runtime_error</code> 仅在运行时可知的错误。</li>
<li><code>range_error</code> 计算结果无法用目标类型表示。（继承自<code>runtime_error</code>）</li>
<li><code>overflow_error</code> 算术上溢。（继承自<code>runtime_error</code>）</li>
<li><code>underflow_error</code> 算术下溢。（继承自<code>runtime_error</code>）</li>
<li><code>tx_exception</code> 可用于回滚或取消transaction的异常。（Transactional Memory Technical Specification, TM TS）</li>
</ol>
</li>
</ul>
<hr>
<h2 id="constexpr-if"><a href="#constexpr-if" class="headerlink" title="constexpr if"></a>constexpr if</h2><p>使用 <code>if constexpr</code>，将在编译期计算分支选择</p>
<p>常常配合 <code>&lt;type_traits&gt;</code> 或变参模板使用。</p>
<ol>
<li>条件必须能在编译期计算，并转换为 <code>bool</code>。</li>
<li>被抛弃的分支：<ol>
<li>不参与函数返回值类型推导</li>
<li>可以使用有声明但没有定义的变量（不属于 ORD-use）</li>
</ol>
</li>
<li>在一个<a href="https://en.cppreference.com/w/cpp/language/templates#Templated_entity">模板实体</a>中，被抛弃的分支不引起后续的实例化。常用于 <code>if constexpr (sizeof...(rs) &gt; 0) &#123; f(rs...) &#125;</code></li>
<li>在一个非模板实体中，被抛弃的分支依然参与语义分析（例如你不能使用一个未声明的变量）。所以 <code>if constexpr</code> 不能替代 <code>#if</code></li>
<li>任何时候，被抛弃的分支都不允许 ill-formed（例如 <code>static_assert(false,&quot;&quot;)</code>）。你可能需要 Concept。</li>
</ol>
<hr>
<h2 id="StandardLayout"><a href="#StandardLayout" class="headerlink" title="StandardLayout"></a>StandardLayout</h2><p><em><a href="https://en.cppreference.com/w/cpp/language/data_members#Standard_layout">StandardLayout</a></em> 的前身是 <em>POD</em>。为了内存对齐，各路厂商的编译器会对结构体的数据成员进行偏移量编排。如果需要字节级粒度的操作（常见于网络），我们需要弄清楚结构体内部的具体布局。</p>
<h3 id="结构体布局"><a href="#结构体布局" class="headerlink" title="结构体布局"></a>结构体布局</h3><p>C++标准 对结构体布局仅做了很有限的规定：</p>
<ol>
<li>同一访问权限的字段的相对顺序与定义相对顺序相同：先定义的在低地址，后定义的在高地址。</li>
<li>不同访问权限的字段的相对顺序是未指定的。</li>
<li>为了内存对齐，允许编译器在字段之间、结构体的末尾添加空字节。</li>
</ol>
<h3 id="标准局部（原-POD）"><a href="#标准局部（原-POD）" class="headerlink" title="标准局部（原 POD）"></a>标准局部（原 POD）</h3><ul>
<li>C++11 以前，<em>PODType</em> 等价于 <em>StandardLayoutType</em></li>
<li>C++11 开始，<em>StandardLayoutType</em> 要求类满足以下条件：<ol>
<li>所有非静态数据成员具有同一个访问权限。</li>
<li>没有虚函数，没有虚基类。</li>
<li>任何非静态数据成员都不是引用类型。</li>
<li>所有非静态数据成员和基类都是 standard layout。</li>
<li>不存在菱形继承。</li>
<li><strong>bit-fields（位域）和所有非静态数据成员在同一个类内定义。</strong></li>
<li>其他复杂的条件（参考 cppref）</li>
</ol>
</li>
</ul>
<p><em>StandardLayout（标准布局）</em> 是 C++ 标准提出的概念，但没做具体布局。</p>
<p>常见的实现遵循以下原则，可以帮助我们肉眼判断 size 和 alignment：</p>
<ol>
<li>结构体自身对齐到最宽的<strong>基础类型</strong>数据成员。（嵌套 struct 的情况下要展开判断）</li>
<li>结构体内<strong>基础类型</strong>字段对齐到自身大小，<strong>子 struct</strong> 则按照上一条对齐。（在字段之间 padding）</li>
<li>结构体的 size 必须是对齐字节的整数倍。（在结构体末尾 padding）</li>
</ol>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    size = 8</span></span><br><span class="line"><span class="comment">    alignment = 4</span></span><br><span class="line"><span class="comment">    |a___|bbbb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    size = 16</span></span><br><span class="line"><span class="comment">    alignment = 4</span></span><br><span class="line"><span class="comment">    |c___|a___|bbbb|d___</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    A obj; <span class="comment">// obj 要对齐到 4 字节，char c 和 char a 不能紧贴相邻</span></span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否标准布局</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line">std::is_standard_layout&lt;B&gt;::value;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="bit-field"><a href="#bit-field" class="headerlink" title="bit field"></a>bit field</h2><p>bit field（位域）是一种<strong>语法糖</strong>。它用于极致紧凑地在内存中排列结构体内容，但是需要额外位操作指令。</p>
<p>这里介绍位域的实现原理。</p>
<ul>
<li>C++ 标准没有规定位域应该如何实现，所以，使用位域的 C++ 程序本质上是<strong>不可移植</strong>的。</li>
<li>要考虑字节<strong>内外部</strong>的大小端问题。通常内外部的大小端保持一致，如 x86 就是不同字节小端在前（低地址），同一字节内小端在前（低编号）。</li>
<li>编译器会额外添加位操作指令（如 <code>shl</code>, <code>shr</code>, <code>sar</code>, <code>or</code> 等）来保证读写位域的语义正确性。</li>
<li>位域的类型决定了对齐边界。例如 <code>int x : 17</code> 会保证 <code>x</code> 不会越过 4 字节的对齐边界。</li>
<li>相邻的位域，如果对齐长度相同，编译器会尽量将他们装在一起，如果装得下的话。</li>
<li>可以使用匿名位域做人工 padding。长度为 0 的匿名位域会强制下一个位域重新开始对齐。</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>CG with OpenGL</title>
    <url>/2020/09/19/CG-with-OpenGL/</url>
    <content><![CDATA[<p>更新：现在都用核心模式了，推荐<a href="https://learnopengl-cn.github.io/">LearnOpenGL</a>，不推荐往下看啦。</p>
<hr>
<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>OpenGL系统由独立于设备的函数集（核心库）、实用库（GLU）和实用工具包（GLUT）三部分组成。</p>
<span id="more"></span>

<h2 id="二维几何变换"><a href="#二维几何变换" class="headerlink" title="二维几何变换"></a>二维几何变换</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="搬砖"><a href="#搬砖" class="headerlink" title="搬砖"></a>搬砖</h2><blockquote class="blockquote-center">
<p>码农之路不可长远</p>

</blockquote>


<h3 id="glut模板"><a href="#glut模板" class="headerlink" title="glut模板"></a>glut模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someDrawing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); <span class="comment">// 显示背景色</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.4</span>, <span class="number">0.2</span>); <span class="comment">// 设置颜色为绿色</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 画线</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_LINES);</span><br><span class="line">        <span class="built_in">glVertex2i</span>(<span class="number">180</span>, <span class="number">15</span>); <span class="comment">// (180, 15) --- (10, 145)</span></span><br><span class="line">        <span class="built_in">glVertex2i</span>(<span class="number">10</span>, <span class="number">145</span>);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glFlush</span>(); <span class="comment">// 立即处理OpenGL常规事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用单缓存，且使用RGB模式</span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 距离左边界50像素，距离上边界100像素</span></span><br><span class="line">    <span class="built_in">glutInitWindowPosition</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 宽度400像素，高度300像素</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Window Title&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 背景缓存色为白色，Alpha值（调和参数）为0</span></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置正投影模式,将世界坐标系二维矩形区域内的内容映射到屏幕上</span></span><br><span class="line">    <span class="comment">// x坐标为[0, 200]，y坐标为[0, 150]。此范围外的内容不予显示</span></span><br><span class="line">    <span class="comment">// 纵横比与窗口保持一致，使图形不变形</span></span><br><span class="line">    <span class="built_in">glMatrixMode</span>(GL_PROJECTION);</span><br><span class="line">    <span class="built_in">glLoadIdentity</span>(); <span class="comment">// 排除之前投影矩阵的影响</span></span><br><span class="line">    <span class="built_in">gluOrtho2D</span>(<span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">0.0</span>, <span class="number">150.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(someDrawing); <span class="comment">// 注册绘图函数</span></span><br><span class="line">    <span class="built_in">glutMainLoop</span>(); <span class="comment">// 进入主循环：显示所有东西然后等待</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主动错误检查"><a href="#主动错误检查" class="headerlink" title="主动错误检查"></a>主动错误检查</h3><p>OpenGL记录一个全局错误标志，表示最近一个未被程序员抓取的错误信息。推荐在每一个显示回调子程序中至少检查一次出错情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLenum <span class="title">errorCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> GLenum code = <span class="built_in">glGetError</span>();</span><br><span class="line">    <span class="keyword">if</span> (code != GL_NO_ERROR) &#123;</span><br><span class="line">        <span class="type">const</span> GLubyte* what = <span class="built_in">gluErrorString</span>(code); <span class="comment">// 静态常量内存</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;OpenGL error: %s\n&quot;</span>, what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="画点与画线"><a href="#画点与画线" class="headerlink" title="画点与画线"></a>画点与画线</h3><p>函数后缀：int-&gt;<code>i</code>，short-&gt;<code>s</code>，float-&gt;<code>f</code>，double-&gt;<code>d</code>，vector-&gt;<code>v</code>，2D-&gt;<code>2</code>，3D-&gt;<code>3</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p1[] = &#123;<span class="number">75</span>, <span class="number">150</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_POINTS); <span class="comment">// 点</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINES); <span class="comment">// 两个点构成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);<span class="comment">// 成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);    <span class="comment">// 成线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);    <span class="comment">// 被忽略</span></span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINE_STRIP); <span class="comment">// 普通折线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);</span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);    </span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_LINE_LOOP); <span class="comment">// 封闭折线</span></span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p1);   <span class="comment">// p1与p5成线</span></span><br><span class="line">    <span class="built_in">glVertex2i</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p3);    </span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p4);</span><br><span class="line">    <span class="built_in">glVertex2iv</span>(p5);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>
<p>有关OpenGL的出错编码请自行查找资料。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Concurrency With C++</title>
    <url>/2021/04/01/Concurrency-with-C/</url>
    <content><![CDATA[<p>不同语言&#x2F;操作系统&#x2F;硬件的线程实现还不一样，因此学一个比较主流的多线程库还是挺重要的。<br>C++ STL的线程支持库就是一个好例子。在这之前，最好先复习一下基础知识。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><strong>不变量(invariants)</strong> 是指对数据结构的断言<ul>
<li>例：某种帐本，任意前缀和不为负数。</li>
<li>例：链表某个节点的后继的前驱是自己。</li>
<li>众所周知，不良的并发编程会破坏不变量！</li>
<li>破坏不变量的根源是写操作。<span id="more"></span></li>
</ul>
</li>
<li>在并发中的<strong>竞争条件(race condition)</strong> 是指，任何结果依赖于在两个或多个线程上操作执行的相对顺序。<ul>
<li>有问题的竞争条件会破坏不变量，引发Bug。</li>
<li>Debug模式下可能无法发现有问题的竞争条件。</li>
<li>下文的竞争条件默认是有问题的。</li>
<li>在类内部使用互斥锁<em>不能</em>完全消除竞争条件。<ul>
<li>例：<code>return &amp;locked_data;</code> 泄露指针或引用，使得数据离开内部锁的保护！</li>
<li>例：<code>template&lt;typename F&gt; ... F(&amp;locked_data);</code> 可能已经泄露了指针或引用！</li>
<li>例：<code>if (!s.empty()) s.pop();</code> 很可能引发一次不安全的pop！</li>
<li>例：<code>tmp = s.top(); s.pop(); return tmp;</code> 在return时发生构造函数异常，数据丢失！</li>
<li>解决办法：<ol>
<li>传入引用或指针来接收返回值。缺点：一些类不支持赋值。</li>
<li>要求拷贝&#x2F;移动构造函数不抛出异常。缺点：用户说我偏不。</li>
<li>返回指向原返回值的指针，最好配合shared_ptr。缺点：性能损耗。</li>
<li>1+2 或者 1+3。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>死锁</strong><ul>
<li>四要素：互斥，持有并等待，非抢占，循环等待。</li>
<li>解决办法：破坏四要素中任意一个<ol>
<li>保证上锁的顺序是唯一的。</li>
<li>使用<code>std::lock()</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>锁的粒度</strong>是指单个锁保护的数据量和保护时间。<ul>
<li>挑选合适的数据量大小。</li>
<li>在耗时的操作中尽可能地释放锁，例如I&#x2F;O操作。</li>
</ul>
</li>
<li><strong>懒汉模式</strong>特指单例模式中的延迟初始化。<ul>
<li>裸懒汉模式显然是线程不安全的。</li>
<li>双重检查加锁也充满了陷阱，因为最外层的检查可能是错误的（赋好了指针，但未彻底完成初始化）！</li>
<li>理想的解决方法是保证标志位是最后初始化的（要防止编译器乱序优化），而不要将指针看作标志位。</li>
<li>使用<code>std::call_once</code>！</li>
<li>还可以利用C++的static局部变量实现懒汉模式。C++11标准保证这是线程安全的！</li>
</ul>
</li>
<li><strong>读写锁</strong>是指共享锁。<ul>
<li>用于很少更新的数据结构。</li>
<li>C++11啥也没有。</li>
<li>C++14新增<code>shared_timed_mutex</code>。</li>
<li>C++17新增<code>shared_mutex</code>，性能更好，好耶！</li>
<li>推荐将<code>shared_mutex</code>声明为<code>mutable</code>。</li>
<li>当心读者太多，写者饿死！</li>
</ul>
</li>
<li><strong>递归锁</strong>允许一个线程多次上锁，但必须进行相同次数的释放锁。<ul>
<li>例：<code>A.a()</code>需要锁，<code>A.b()</code>也需要锁，而且<code>A.a()</code>需要调用<code>A.b()</code>。</li>
<li>不建议这样用，因为<code>A.b()</code>可能要面对错误的数据。</li>
<li>建议抽出<code>A.a()</code>和<code>A.b()</code>的公共部分，成为一个新的私有函数，且不上锁（因为已经上了锁）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="C-Library"><a href="#C-Library" class="headerlink" title="C++ Library"></a>C++ Library</h2><h3 id="Thread-线程"><a href="#Thread-线程" class="headerlink" title="Thread 线程"></a>Thread 线程</h3><p><a href="https://en.cppreference.com/w/cpp/thread">cppreference thread</a></p>
<p><code>#include &lt;thread&gt;</code></p>
<p>起一个线程！</p>
<ul>
<li><code>thread</code> 类<ul>
<li>默认构造不代表任何线程</li>
<li>可移动，不可复制</li>
<li>构造函数完成后立即就绪</li>
<li>若子线程抛出异常，则调用<code>std::terminate</code>中止进程</li>
<li>使用<code>thread_local</code>关键字，令变量的生命周期和所属线程相同</li>
<li><code>join()</code> 调用者等待，直到线程执行完毕</li>
<li><code>detach()</code> 分离线程和线程对象，此时可以安全地销毁线程对象。</li>
<li><code>joinable()</code> 是否可以使用<code>join()</code>。正在运行中、未分离的线程都是 joinable.</li>
<li><code>thread::hardware_concurrency()</code> 获取线程数参考值。</li>
</ul>
</li>
<li><code>this_thread</code> 命名空间<ul>
<li><code>yield()</code> 建议当前线程进入就绪状态</li>
<li><code>get_id()</code> 获取线程id。结果可用<code>&lt;&lt;</code>序列化，虽然意义不大。</li>
<li><code>sleep_for(duration)</code>&#x2F;<code>sleep_until(time_point)</code> 当前线程阻塞一段时间</li>
</ul>
</li>
</ul>
<hr>
<p>提到多线程，几乎避不开互斥、同步等概念。</p>
<h3 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h3><p><a href="https://en.cppreference.com/w/cpp/header/mutex">cppreference mutex</a></p>
<p><code>#include &lt;mutex&gt;</code></p>
<p>主要用于保护<strong>数据</strong>的操作原子性。</p>
<p>若多个线程请求同一个锁，而此锁尚未被释放，则当锁释放时，其中一个线程获得锁（退出阻塞），其余线程维持阻塞。</p>
<ul>
<li><code>mutex</code> 类<ul>
<li><code>lock()</code> 阻塞，直到获得锁</li>
<li><code>unlock()</code></li>
<li><code>try_lock()</code> 若无法获得锁，则返回 false 但不阻塞</li>
<li>小心<code>mutex</code>的生命周期。销毁一个被其他线程持有的锁是后果无定义的。</li>
<li>销毁线程前应当释放锁，否则后果无定义。</li>
<li>不可拷贝，不可移动</li>
<li>同一线程不可对同一<code>mutex</code>多次上锁，这样做的后果是无定义的。</li>
</ul>
</li>
<li><code>recursive_mutex</code> 类<ul>
<li>同一线程可以多次上锁。上锁和解锁应一一对应。</li>
<li>例如<code>std::lock_guard&lt;std::recursive_mutex&gt; lk(m);</code></li>
</ul>
</li>
<li><code>timed_mutex</code> 类<ul>
<li><code>try_lock_for(timeout_duration)</code> 最多等待一段时间，无法获得锁则返回 false</li>
<li><code>try_lock_until(timeout_time)</code> 最多等待至一个时间点，无法获得锁则返回 false</li>
</ul>
</li>
<li><code>recursive_timed_mutex</code> 类<ul>
<li>混合了两者的功能</li>
</ul>
</li>
<li><code>void lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn)</code> 全局函数<ul>
<li>安全地“同时”请求多个互斥锁</li>
<li>保证不会引发死锁</li>
</ul>
</li>
<li><code>lock_guard</code> 类<ul>
<li>RAII 请求和释放一个锁</li>
<li>必须拥有一个锁</li>
<li><code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>假定已经获得了锁</li>
</ul>
</li>
<li><code>scoped_lock</code> 类<ul>
<li>RAII 同时请求和释放多个锁</li>
<li>保证不会引发死锁</li>
</ul>
</li>
<li><code>unique_lock</code> 类<ul>
<li>RAII 独占锁</li>
<li>可以主动解锁。常见于条件变量。暂时或提前释放锁通常可提高时间性能。</li>
<li>可以不拥有锁，因此有空间和性能损耗。常见于需要延迟上锁或转移所有权。</li>
<li>adopt_lock假定已经获得了锁，defer_lock假定延迟获得锁。</li>
<li>若延迟上锁，随后可用<code>std::lock(unique_lock, ...)</code>上锁。</li>
</ul>
</li>
<li><code>shared_lock</code> 类<ul>
<li>RAII 共享锁</li>
</ul>
</li>
<li><code>void call_once( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args );</code> 函数<ul>
<li>全局仅执行函数<code>f(args)</code>一次</li>
<li>若<code>flag</code>是复位，则允许执行<code>f(args)</code></li>
<li>支持多线程并发</li>
<li>若<code>f(args)</code>正常结束，则<code>flag</code>置位，防止第二次调用</li>
<li>若<code>f(args)</code>抛出未处理的异常，则<code>flag</code>保持复位，允许第二次调用</li>
<li>一个<code>flag</code>可以对应多个<code>f</code>，不保证哪个函数先执行。</li>
</ul>
</li>
</ul>
<h3 id="Condition-Variable-条件变量"><a href="#Condition-Variable-条件变量" class="headerlink" title="Condition Variable 条件变量"></a>Condition Variable 条件变量</h3><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference condition_variable</a></p>
<p>条件变量可以用来阻塞一个或多个线程，直到某个活动线程修改一个共享变量（即条件），并通知条件变量。</p>
<ol>
<li>为了保护上述共享变量，需要上互斥锁。</li>
<li>对比互斥锁的优势是：避免定时，定向唤醒，占用资源低，事件驱动。</li>
<li>被唤醒的线程需要手动或自动地检查条件，若条件失败，则再次被阻塞，等待被唤醒。</li>
</ol>
<p><code>#include &lt;condition_variable&gt;</code></p>
<ul>
<li><code>condition_variable</code>类<ul>
<li>只有默认构造函数</li>
<li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock );</code> <ul>
<li>释放锁，然后进入阻塞，直到被唤醒。</li>
<li>被唤醒后，先获得锁。</li>
</ul>
</li>
<li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred );</code> <ul>
<li>释放锁，然后进入阻塞，直到被唤醒。</li>
<li>被唤醒后，先获得锁</li>
<li>只要<code>pred</code>不满足，就会再次释放锁然后阻塞。</li>
<li>避免在<code>pred</code>里加副作用，因为无法确定它会执行多少次。</li>
</ul>
</li>
<li><code>notify_one()</code>&#x2F;<code>notify_all()</code> <ul>
<li>唤醒关联的阻塞线程。</li>
<li>当前线程应当事先释放锁（lock_guard应已析构）。</li>
</ul>
</li>
<li><code>void notify_all_at_thread_exit( std::condition_variable&amp; cond, std::unique_lock&lt;std::mutex&gt; lk );</code> <ul>
<li>全局函数。 </li>
<li>线程退出时（所有thread_local被销毁后），释放锁，然后唤醒全部。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Future-amp-Async-未来与异步"><a href="#Future-amp-Async-未来与异步" class="headerlink" title="Future &amp; Async 未来与异步"></a>Future &amp; Async 未来与异步</h3><p><a href="https://en.cppreference.com/w/cpp/header/future">cppreference future</a></p>
<p>有时候，起一个线程仅仅是为了一次返回值。thread不能提供返回值，条件变量又太重量级了，你需要使用<code>async</code>。</p>
<p><code>async</code>可以轻量级地开启一个带返回值的线程，通常短期内你用不到返回值。一段时间后，你需要返回值了，才阻塞自己，直到返回值就绪。需要花费一段时间才能就绪的返回值就是<code>future</code>。</p>
<p><code>async</code>也允许你推迟执行，这意味着没有新线程，而是同步地执行。</p>
<ul>
<li><code>async</code>函数<ul>
<li>可接受<code>std::launch policy</code>为第一个参数，允许的值有：<ul>
<li><code>std::launch::async</code> 开启新线程，异步执行。</li>
<li><code>std::launch::deferred</code> 没有新线程，懒惰同步执行。</li>
<li><code>launch::async|launch::deferred</code> 默认值，由实现选择策略。</li>
<li>C++标准允许实现采用不同的默认策略，甚至允许新增策略。</li>
</ul>
</li>
<li><code>async</code>返回一个<code>future</code></li>
</ul>
</li>
<li><code>future&lt;&gt;</code>类<ul>
<li>表示一个值，这个值可能正在计算中，可能就绪，也可能是抛出的异常。</li>
<li><code>get()</code>成员函数。 保证返回就绪的值或者抛出异常。（若未就绪，则当前线程阻塞）。此函数只能调用一次，然后将<code>valid()</code>设置为false。</li>
<li><code>valid()</code>成员函数。 检查下一次<code>get()</code>的合法性，即有没有共享状态。</li>
<li><code>wait()</code>成员函数。 保证值就绪或者抛出异常。（若未就绪，则阻塞）</li>
<li><code>wait_for</code>, <code>wait_until</code>成员函数。有限等待。</li>
<li><code>share()</code>成员函数。移动自己，构造一个<code>shared_future&lt;&gt;</code>。</li>
<li>可移动，不可复制。</li>
</ul>
</li>
<li><code>shared_future&lt;&gt;</code>类<ul>
<li>与<code>future&lt;&gt;</code>类似，但可以<code>get()</code>多次。</li>
<li>可移动也可以复制。</li>
<li>正确的用法就是每个线程持有一份复制。</li>
</ul>
</li>
<li><code>packaged_task&lt;Callable&gt;</code>类<ul>
<li>将future绑定到函数（或可调用对象），方便自定义调度。</li>
<li>构造器仅接受函数（可以是lambda！），不绑定参数。只有在<code>operator ()</code>时才传入参数。</li>
<li>packaged_task本身也是一个可调用对象！可以用它起一个新线程。<code>thread(move(task), args...)</code></li>
<li>可移动，不可复制。</li>
<li><code>get_future()</code> 获取绑定的future。</li>
<li><code>operator(args...)</code> 立即在当前线程执行，然后future就绪，意味着唤醒等待此future的线程。</li>
<li><code>make_ready_at_thread_exit(args...)</code> 立即在当前线程执行，但是future不就绪。当线程退出且所有thread_local对象销毁后，future才就绪。</li>
<li><code>reset()</code> 重新构造自己。旧版的future作废。</li>
</ul>
</li>
<li><code>promise&lt;&gt;</code>类<ul>
<li>比async提供更强的自由度，可以手动设置future！如此可以在设置future后继续清理工作。</li>
<li>可移动，不可复制。</li>
<li>一般先<code>get_future()</code>留下接口，然后move<code>promise</code>到别的线程，在别的线程<code>set_value</code>。</li>
<li><code>set_value(value)</code> 设置关联的future的值，唤醒在等待的线程。</li>
<li><code>set_value_at_thread_exit(value)</code> 类似<code>set_value</code>，但当前线程退出后，才唤醒在等待的线程。</li>
<li><code>void set_exception( std::exception_ptr p )</code> 令future的<code>get()</code>抛出异常。<ul>
<li>在try-catch块中，配合<code>std::current_exception()</code>使用</li>
<li>不用try-catch，性能更高，配合<code>make_exception_ptr(E e)</code>用。</li>
</ul>
</li>
<li><code>set_exception_at_thread_exit</code> 同理。</li>
</ul>
</li>
</ul>
<h2 id="内存模型和原子操作"><a href="#内存模型和原子操作" class="headerlink" title="内存模型和原子操作"></a>内存模型和原子操作</h2><h2 id="设计无锁数据结构"><a href="#设计无锁数据结构" class="headerlink" title="设计无锁数据结构"></a>设计无锁数据结构</h2><ul>
<li>无锁数据结构应如何设计？</li>
<li>无锁数据结构的内存管理有何难题？</li>
<li>更多的建议？</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Expression Templates</title>
    <url>/2022/01/31/Expression-Templates/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>在研究 CRTP 时发现了一种经典应用——表达式模板。今天学一学，顺便水一篇博客。🐶</p>
<h1 id="Motivation-and-example"><a href="#Motivation-and-example" class="headerlink" title="Motivation and example"></a>Motivation and example</h1><p>表达式模板是一种模板元编程，它在编译期展开向量的一系列复合运算，从而将辅助空间从 $O(n)$ 降到 $O(1)$。相比于朴素算法，表达式模板属于惰性求值，求值时间点是赋值运算。</p>
<span id="more"></span>

<p>举个例子，有这样一个 vector 运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tot = (a + b) * c;</span><br></pre></td></tr></table></figure>
<p>朴素算法的语义是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp0 = a + b; <span class="comment">// allocating O(n) space</span></span><br><span class="line">    <span class="keyword">auto</span> tmp1 = tmp0 * c;</span><br><span class="line">    tot = tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使你知道「引用限定成员函数」，使你可以抹掉 <code>tmp1</code> 的空间分配，但是 <code>tmp0</code> 的辅助空间总是逃不掉。</p>
<p>能帮助你的只有表达式模板，它可以表达出这样的语义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>, n=a.<span class="built_in">size</span>(); i&lt;n; ++i) &#123;</span><br><span class="line">    tot[i] = (a[i] + b[i]) * c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来需要的辅助空间就是寄存器级别的！去掉了函数调用也更方便编译器做进一步的优化。</p>
<h1 id="My-first-attempt"><a href="#My-first-attempt" class="headerlink" title="My first attempt"></a>My first attempt</h1><details class="note primary"><summary><p>我的首次尝试</p>
</summary>
<p>忍住不看教程，我先试着实现出来，看看差距有多大。🤔</p>
<p>我的想法：</p>
<ol>
<li>利用类型系统，将懒惰信息记录在模板参数中</li>
<li>定义惰性二元运算符，它的操作数可以是 vector 或者惰性二元运算符。</li>
<li>魔改 <code>vector</code>，在赋值运算符中触发求值；重载加减乘除运算。</li>
</ol>
<h2 id="Draft-1"><a href="#Draft-1" class="headerlink" title="Draft 1"></a>Draft 1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeferredOperator</span> &#123;</span><br><span class="line">    <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">    <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">DeferredOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        BinaryOperator, <span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        : lhs(lhs), rhs(rhs) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs[pos], rhs[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lhs.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Op&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(Op &amp;&amp;op) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = op.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = op[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    vec = <span class="built_in">DeferredOperator</span>(</span><br><span class="line">        std::multiplies&lt;<span class="type">int</span>&gt;&#123;&#125;, <span class="built_in">DeferredOperator</span>(std::plus&lt;<span class="type">int</span>&gt;&#123;&#125;, a, b), c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == (<span class="number">1</span> + <span class="number">3</span>) * <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="What-39-s-wrong"><a href="#What-39-s-wrong" class="headerlink" title="What&#39;s wrong"></a>What&#39;s wrong</h2><p>这段程序是正确的！😁但也有一些犯蠢的地方：</p>
<ol>
<li>没有重载运算符，用起来太丑；</li>
<li>显式模板参数太多，比如 <code>int</code> 出现太多次。理想中应该只在 <code>Vec</code> 定义时表明<code>T = int</code>，后面的通通自动推导；</li>
<li>魔改的 <code>Vec</code> 类没有沿用 <code>std::vector</code> 的非默认构造函数；</li>
<li>当调用 <code>vec = vec</code> 时会错误地调用惰性求值版本；</li>
<li>没有显式 CRTP，证明不够熟练；</li>
<li>在计算前调用 <code>vector::resize()</code> 真的好吗？有点违反零开销抽象的感觉。</li>
</ol>

</details>

<h1 id="The-second-attempt"><a href="#The-second-attempt" class="headerlink" title="The second attempt"></a>The second attempt</h1><details class="note primary"><summary><p>查文档再改进</p>
</summary>
<p>针对上一章节列出的缺点，我查阅文档做了一些改进：</p>
<h2 id="Inheriting-constructors"><a href="#Inheriting-constructors" class="headerlink" title="Inheriting constructors"></a>Inheriting constructors</h2><p><a href="https://en.cppreference.com/w/cpp/language/using_declaration">cppreference</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就能使用 <code>std::vector</code> 的构造接口了，我们的 C++ 真的太好用啦！</p>
<h2 id="Template-Inner-Class"><a href="#Template-Inner-Class" class="headerlink" title="Template Inner Class"></a>Template Inner Class</h2><p>我们可以将 <code>DeferredOperator</code> 类定义在 <code>Vec</code> 内部，这样就不用到处传递基础数据类型啦！</p>
<h2 id="Who-needs-operator"><a href="#Who-needs-operator" class="headerlink" title="Who needs operator+()?"></a>Who needs operator+()?</h2><ol>
<li><code>Vec</code> 类需要实现 <code>operator+()</code>，并由这个函数返回一个 <code>DeferredOperator</code></li>
<li><code>DeferredOperator</code> 类需要实现 <code>operator+()</code>，这个函数同样返回一个 <code>DeferredOperator</code></li>
</ol>
<h2 id="Ambiguity-of-operator-x3D"><a href="#Ambiguity-of-operator-x3D" class="headerlink" title="Ambiguity of operator&#x3D;()"></a>Ambiguity of operator&#x3D;()</h2><p>为了区分 <code>Vec = Vec</code> 和 <code>Vec = DeferredOperator</code>，我们需要更精细地定义参数。</p>
<h2 id="Draft-2"><a href="#Draft-2" class="headerlink" title="Draft 2"></a>Draft 2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec : Container &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DeferredOperator</span> &#123;</span><br><span class="line">        <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">        <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="title">DeferredOperator</span><span class="params">(<span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : lhs(lhs), rhs(rhs) &#123;</span>&#125;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs[pos], rhs[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterRHS&gt;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> OuterRHS &amp;outerRHS) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DeferredOperator&lt;std::plus&lt;&gt;, DeferredOperator, OuterRHS&gt;(</span><br><span class="line">                *<span class="keyword">this</span>, outerRHS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lhs.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> RHS &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DeferredOperator&lt;std::plus&lt;&gt;, Vec, RHS&gt;(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DeferredOperator&lt;BinaryOperator,LHS,RHS&gt; &amp;op) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tag\n&quot;</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = op.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = op[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; vec, <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">1</span>), <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">3</span>), <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    vec = a; <span class="comment">// check bug</span></span><br><span class="line">    vec = a + b + c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == (<span class="number">1</span> + <span class="number">3</span>) + <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Direction-of-improvement"><a href="#Direction-of-improvement" class="headerlink" title="Direction of improvement"></a>Direction of improvement</h2><p>WoW! 这段代码也是正确的！但还是写得有点臭：</p>
<ol>
<li>这里只写了重载加法。如果每种运算符都要写两个成员函数，那也太难看了。</li>
<li>只对 <code>Vec</code> 类实现了惰性加法。万一再来一个 <code>Matrix</code> 类呢？惰性运算能不能接口化？</li>
<li>CRTP 在哪？</li>
</ol>

</details>

<h1 id="Peak-of-Evolution"><a href="#Peak-of-Evolution" class="headerlink" title="Peak of Evolution"></a>Peak of Evolution</h1><p>这次依然是原创代码，改进了一些地方：</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>多层次的 CRTP 用起来容易头晕，应该事先设计好类的关系：</p>
<p><img src="/2022/01/31/Expression-Templates/crtpEt.svg" alt="CRTP relationship"></p>
<p>橙色和红色的类才是 CRTP 的模板实参。白色的类主要用作接口，类似于抽象类。</p>
<h2 id="ET-interface"><a href="#ET-interface" class="headerlink" title="ET interface"></a>ET interface</h2><ul>
<li>用户类只要继承 <code>VectorExpresstion</code> 接口，同时定义合适的 <code>operator[]</code> 和 <code>operator=</code> 即可实现模板表达式。</li>
<li>用户可以在 <code>operator=</code> 中做性能优化，例如手工循环展开、SIMD 等等，非常灵活。</li>
<li>用户还可以自定义运算符，但我暂时想不到有什么不啰嗦的实现方法（除了宏）。</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// necessary header for Expression Template library</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header for user-define things</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// helper class for CRTP. For more info, please see my previous blog</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Interface</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CRTP</span> &#123;</span><br><span class="line">    <span class="function">T &amp;<span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">self</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T &amp;&gt;(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CRTP</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">friend</span> Interface&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// my Expression Template library implementation</span></span><br><span class="line"><span class="keyword">namespace</span> ET &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base class for lazy evaluation</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Expression</span> : CRTP&lt;T, Expression&gt; &#123;</span><br><span class="line">    <span class="comment">// use a looong function name to avoid ambiguity</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">evaluate</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">self</span>()[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">selfSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">self</span>().<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class to indicate a single value (instead of an vector)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArithmeticExpression</span> : Expression&lt;ArithmeticExpression&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="built_in">ArithmeticExpression</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;std::<span class="type">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;, <span class="type">bool</span>&gt; = <span class="literal">true</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">ArithmeticExpression</span>(<span class="type">const</span> T value) <span class="keyword">noexcept</span> : <span class="built_in">val</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> T <span class="keyword">operator</span>[](<span class="type">size_t</span>) <span class="type">const</span> &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// return void for easier metaprogramming</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class to indicate an vector (instead of a single arithmetic value)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VectorExpression</span> : Expression&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BinaryOperator, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryExpression</span></span><br><span class="line">    : VectorExpression&lt;BinaryExpression&lt;BinaryOperator, LHS, RHS&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> i) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// evaluation happens when operator[] is called</span></span><br><span class="line">        <span class="keyword">return</span> BinaryOperator&#123;&#125;(lhs.<span class="built_in">evaluate</span>(i), rhs.<span class="built_in">evaluate</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return the size of an *vector*</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!std::is_same_v&lt;<span class="keyword">decltype</span>(lhs.selfSize()), <span class="type">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> lhs.<span class="title">selfSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rhs.<span class="built_in">selfSize</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BinaryExpression</span>(<span class="type">const</span> LHS &amp;lhs, <span class="type">const</span> RHS &amp;rhs) : <span class="built_in">lhs</span>(lhs), <span class="built_in">rhs</span>(rhs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> LHS &amp;lhs;</span><br><span class="line">    <span class="type">const</span> RHS &amp;rhs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> AddExpression = BinaryExpression&lt;std::plus&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> SubExpression = BinaryExpression&lt;std::minus&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> MulExpression = BinaryExpression&lt;std::multiplies&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;</span><br><span class="line"><span class="keyword">using</span> DivExpression = BinaryExpression&lt;std::divides&lt;&gt;, LHS, RHS&gt;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded operator to export:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> ETNum = ET::ArithmeticExpression&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>+(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">// notice Expression&lt;E1&gt; -&gt; E1</span></span><br><span class="line">    <span class="comment">// so &quot;Expression&quot; is removed</span></span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">AddExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>-(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">SubExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>*(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">MulExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span><br><span class="line"><span class="keyword">operator</span>/(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">DivExpression</span>&lt;E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-define operator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I find it hard to convert a function into an operator() overloading.</span></span><br><span class="line"><span class="comment">// If you have a good idea, please tell me!</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POW</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp &amp;&amp;<span class="type">__t</span>, _Up &amp;&amp;__u)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(std::forward&lt;_Tp&gt;(<span class="type">__t</span>), std::forward&lt;_Up&gt;(__u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span></span><br><span class="line"><span class="function"><span class="title">Pow</span><span class="params">(<span class="type">const</span> ET::Expression&lt;E1&gt; &amp;lhs, <span class="type">const</span> ET::Expression&lt;E2&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ET::<span class="built_in">BinaryExpression</span>&lt;POW, E1, E2&gt;(lhs.<span class="built_in">self</span>(), rhs.<span class="built_in">self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-define vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Vec</span><br><span class="line">    : Container</span><br><span class="line">    , ET::VectorExpression&lt;Vec&lt;T, Container&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Container::Container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Exp&gt;</span><br><span class="line">    Vec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ET::Expression&lt;Exp&gt; &amp;exp) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> n = exp.<span class="built_in">selfSize</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i) = exp.<span class="built_in">evaluate</span>(i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec&lt;<span class="type">double</span>&gt; ans, <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">1</span>), <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">2</span>), <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">8</span>), <span class="built_in">d</span>(<span class="number">5</span>, <span class="number">7</span>), <span class="built_in">e</span>(<span class="number">5</span>, <span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">Pow</span>((a + b) * c / d + <span class="built_in">ETNum</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>), e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : ans) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">assert</span>(x == <span class="built_in">pow</span>(((<span class="number">1</span> + <span class="number">2</span>) * <span class="number">8</span> / <span class="number">7.0</span> + <span class="number">1</span>), <span class="number">0.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion-and-Prospect"><a href="#Conclusion-and-Prospect" class="headerlink" title="Conclusion and Prospect"></a>Conclusion and Prospect</h1><p>一个基本可用的表达式模板库诞生了。但是要记住：</p>
<ol>
<li>表达式模板离开了内联优化就是负优化。经过简单测试，gcc 至少要在 <code>-O1</code> 条件下才有内联成员函数的能力。</li>
<li>使用表达式模板和其他优化手段并不冲突，可以在自定义 <code>operator=</code> 处做 SIMD，循环展开等等。</li>
</ol>
<p>我不得不承认这份代码对比基础库的水准还是差了很多，至少有以下方面可以改进：</p>
<ul>
<li>more type trait，描述表达式的可加性、可乘性、可被除和可除性等等。</li>
<li>进一步简化用户自定义运算符的代码。</li>
<li>实现一元运算符。</li>
<li>在矢量和标量的混合运算中抹去显式构造标量。</li>
</ul>
<p>但模板元编程暂时不是我的主要学习方向，所以还是再等等吧~</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Expression_templates">Expression templates - Wikipedia</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template">More C++ Idioms&#x2F;Expression-template - Wikibooks</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/using_declaration">Using-declaration - cppreference.com</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Coroutine Tutorial: Generators</title>
    <url>/2022/02/22/Generators-with-Coroutine/</url>
    <content><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>要掌握 C++20 协程，仅仅看完文档是远远不够的。C++ 和其他语言的协程的最大不同点在于，C++ 提供了最少量的编译器实现和极大量的「可定制点」，而其他语言可能连「调度器」都给用户准备好了。</p>
<p>在茫茫多的可定制点面前，如果你能一眼看出「为什么 C++ 要这样设计」，那么我愿称你为天才。否则，还是从常见的范式下手，逐渐体会设计者的思想吧。</p>
<p>我们将从最简单的范式——Generator 下手。</p>
<span id="more"></span>

<p><small>本文力求概念定义的权威性，但无法做任何保证。</small></p>
<h1 id="What-is-Generator"><a href="#What-is-Generator" class="headerlink" title="What is Generator"></a>What is Generator</h1><p>Generator 泛指一段序列（有限或无限长）的生成器。在协程的语境下，Generator 特指一个<strong>懒惰</strong>的协程，它每次运行时会在调用者线程<strong>同步</strong>地计算一个值，然后暂停自己，同时把值返回给调用者。</p>
<div class="note info"><p>因为 Generator 在是在调用者线程下立即同步执行的，所以它不需要任何调度器。</p>
</div>

<p>Fibonacci 数列就是 Generator 的 hello-world。我们来看一看效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a0;</span><br><span class="line">    <span class="keyword">co_yield</span> a1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a2; <span class="literal">true</span>;) &#123;</span><br><span class="line">        a2 = a0 + a1;</span><br><span class="line">        a0 = a1;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        <span class="keyword">co_yield</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len=<span class="number">10</span>; <span class="type">int</span> i : <span class="built_in">fibonacci</span>(<span class="number">1</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (--len == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现这个效果，只要实现 <code>Generator&lt;T&gt;</code><del>，虽然很麻烦</del>。</p>
<h1 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator"></a>Why Generator</h1><p>上一段例子很愚蠢，我随手写一个 <code>struct Fibo</code> 重载 <code>operator()</code>，内置一个迭代器不香？为什么要大费周章实现 Generator，还要付出协程的运行时代价？</p>
<p><del>我也不知道为什么，纯纯为了学而学</del> Generator 可以免去你每次重新设计结构体的麻烦，无需你重写各种迭代器，可以看作一个又香又臭的语法糖。更进一步，Generator 可以很方便地相互嵌套，相比其他做法大大降低了编程复杂度。</p>
<h1 id="Analyze-How-to"><a href="#Analyze-How-to" class="headerlink" title="Analyze How-to"></a>Analyze How-to</h1><p>希望你已经大致了解 C++ Coroutine 的运作方式，至少了解 <code>co_await</code> 关键字的作用。顺便推销一下我的另一篇文章 <a href="/2021/11/18/C-20-Coroutine/">C++20 Coroutine</a>，它可以帮助你记住 <code>co_await</code>。</p>
<p>现在按照协程的生命周期来分析 <code>Generator&lt;T&gt;</code>，看看它应该具有哪些接口和行为。</p>
<h2 id="get-return-object"><a href="#get-return-object" class="headerlink" title="get_return_object"></a>get_return_object</h2><p>协程在初次进入的时候会调用 <code>promise.get_return_object()</code>，其返回值会在第一次暂停的时候返回给 caller。caller 要向协程索取返回值，通常只能通过这个<code>return_object</code> 去要，所以它相当于一个 handler。</p>
<p>按照 C++ 标准规定 <code>promise.get_return_object()</code> 的返回值必须是协程类型，也就是 <code>Generator&lt;T&gt;</code>，也好，省得我们思考了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;&lt;unspecified&gt;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="inital-suspend"><a href="#inital-suspend" class="headerlink" title="inital_suspend"></a>inital_suspend</h2><p>协程在初次进入的时候（且在上一步之后）会调用 <code>co_await promise.inital_suspend()</code>。我们希望的是协程不要做任何计算（懒惰），并且直接让出执行权给 caller。所以有如下设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;&lt;unspecified&gt;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>别去找 <code>std::suspend_always</code> 的实现了，我已经给你准备好了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_always</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suspend_never</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>std::suspend_always</code> 在被 <code>co_await</code> 的时候总是会让出执行权给 caller&#x2F;resumer，而且<strong>不做任何调度</strong>。如果 caller&#x2F;resumer 未来不将这个协程加入调度，那它就<strong>被永远遗忘</strong>在堆内存中了。</p>
<p>另一方面，可以发现 <code>co_await std::suspend_always&#123;&#125;</code> 的返回值总是 <code>void</code>。</p>
<h2 id="caller-resume"><a href="#caller-resume" class="headerlink" title="caller resume"></a>caller resume</h2><p>目前为止，一个协程已经构造好了，而且已经暂停了。用户程序大概长这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Generator&lt;<span class="type">int</span>&gt; fibo = <span class="built_in">fibonacci</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 运行时，因为 co_await initial_suspend() 而跳出协程，执行到这里</span></span><br><span class="line">    <span class="comment">// fibo 就是我们要用的 handler</span></span><br><span class="line">    <span class="comment">// 要再入协程、获取返回值、销毁协程等等都要靠 fibo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们想做两件事：</p>
<ol>
<li>resume 一下 <code>fibo</code>，从而计算出第一个值</li>
<li>通过 <code>fibo</code> 拿到第一个值</li>
</ol>
<p>根据 C++ 标准，要恢复一个协程，必须持有对应的 <code>std::coroutine_handle</code>，换句话说 <code>fibo</code> 必须持有 <code>std::coroutine_handle</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那 Generator 是由谁初始化的呢？别忘了，初始化的事是由 <code>promise.get_return_object()</code> 干的。</p>
<p>问题又来了，如何在 <code>promise.get_return_object()</code> 初始化 <code>std::coroutine_handle</code>？</p>
<p>我们要认识到以下事实：</p>
<div class="note info"><p>&amp;promise 和 coroutine_handle 一一对应，它们的偏移量是编译期已知的，可以互相换算。</p>
</div>

<p>也就是说，可以根据 <code>promise</code> 的地址算出协程的 <code>std::coroutine_handle</code>，也可以反过来用 <code>std::coroutine_handle</code> 换算出 <code>promise</code> 的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note info"><p><code>std::coroutine_handle</code> 的本质是指向协程帧的指针，通常按值传递。</p>
</div>

<p>现在，我们可以任意给 Generator 加成员方法，让它利用 <code>m_handle</code> 做任何事情，比如利用 <code>fibo.m_handle.resume()</code> 恢复协程，进行一次计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125; <span class="comment">// 计算下一个值</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="co-yield"><a href="#co-yield" class="headerlink" title="co_yield"></a>co_yield</h2><p>现在，用户调用了 <code>fibo.next()</code>，协程被恢复执行。现在我们想返回第一个值给用户，意味着必须暂停协程，归还执行权。C++ 给我们提供了关键字 <code>co_yield</code>，它是一个语法糖，<code>co_yield expr</code> 等价于 <code>co_await promise.yield_value(expr)</code>。</p>
<p>所以在 <code>promise.yield_value(expr)</code> 里面，我们要做两件事：</p>
<ol>
<li>将 <code>expr</code> 保存在 <code>promise</code> 里面，便于外部访问。</li>
<li>返回一个 <code>std::suspend_always&#123;&#125;</code>，令 caller 重获执行权。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note info"><p><code>std::coroutine_handle&lt;Promise&gt;::promise()</code> 可以拿到对应的 promise 对象，从而拿到计算结果。但请特别小心协程可能已经被销毁！</p>
</div>

<div class="note warning"><p>从容器的角度看，<code>T m_value</code> 是一个很烂的设计，仅供示意，请勿模仿！</p>
</div>

<h2 id="Finish-the-leftover"><a href="#Finish-the-leftover" class="headerlink" title="Finish the leftover"></a>Finish the leftover</h2><p>现在，Generator 已经具备我们所需的全部功能，但还有一些手续要办：</p>
<ol>
<li>异常处理</li>
<li>定义 <code>co_return</code> 的行为</li>
</ol>
<h3 id="uncaught-exception-handler"><a href="#uncaught-exception-handler" class="headerlink" title="uncaught exception handler"></a>uncaught exception handler</h3><p>协程运行时没有被显式 catch 的异常会导致立即调用 <code>promise.unhandled_exception()</code>，紧接着调用 <code>co_await promise.final_suspend()</code>。</p>
<p>简单起见，我们先不处理异常，留下一个空函数就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="define-co-return"><a href="#define-co-return" class="headerlink" title="define co_return"></a>define <code>co_return</code></h3><p>协程可以显式 <code>co_return [expr]</code>，或者因为执行完函数体而隐式 <code>co_return</code>。</p>
<p>我们的 fibonacci 不需要 <code>co_return</code> 任何东西，但是作为一篇负责任的教程，我还是会告诉你：</p>
<div class="note info"><p><code>co_return expr;</code> 会调用 <code>promise.return_value(expr)</code>，随后析构协程内的自动变量，但 promise 和协程参数仍然存活。</p>
<p>类似地 <code>co_return;</code> 或者 <code>co_return (void)expr;</code> 会调用 <code>promise.return_void()</code>。</p>
</div>

<div class="note warning"><p><code>return_value(expr)</code> 和 <code>return_void()</code> 是我们访问协程内自动变量的最后机会。但是 promise 和协程参数仍会存活。</p>
</div>

<p><code>return_xxx()</code> 和 自动变量析构后，协程执行 <code>co_await promise.final_suspend()</code>，若协程<strong>不暂停</strong>，则协程帧析构：</p>
<ol>
<li>析构 <code>promise</code></li>
<li>析构协程参数</li>
<li>释放堆空间</li>
<li>转移执行权</li>
</ol>
<p>若协程暂停，就<strong>只能</strong>通过 <code>std::coroutine_handle::destroy()</code> 来显式析构，无论是否已经析构都<strong>不能再 resume</strong>。</p>
<p>关于协程的各类元素的生命周期，是一大坑点，未来我会撰写一篇文章来表述。</p>
<p>言归正传，我们只要随便写一个 final_suspend() 就好，反正这个 Generator 永远不会 <code>co_return</code>。</p>
<h2 id="Demo-fibonacci"><a href="#Demo-fibonacci" class="headerlink" title="Demo: fibonacci"></a>Demo: fibonacci</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">promise_type</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~promise_type\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>() <span class="keyword">noexcept</span> : <span class="built_in">m_handle</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Generator\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_handle) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;m_handle.destroy()\n&quot;</span>;</span><br><span class="line">            m_handle.<span class="built_in">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO begin() end() operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator&lt;<span class="type">int</span>&gt; <span class="title">fibo</span><span class="params">(<span class="type">int</span> a0, <span class="type">int</span> a1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> a0;</span><br><span class="line">    <span class="keyword">co_yield</span> a1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a2; <span class="literal">true</span>;) &#123;</span><br><span class="line">        a2 = a0 + a1;</span><br><span class="line">        a0 = a1;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        <span class="keyword">co_yield</span> a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">auto</span> fi = <span class="built_in">fibo</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        fi.<span class="built_in">next</span>();</span><br><span class="line">        cout &lt;&lt; fi.<span class="built_in">result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">~Generator</span><br><span class="line">m_handle.destroy()</span><br><span class="line">~promise_type</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion-and-Prospect"><a href="#Conclusion-and-Prospect" class="headerlink" title="Conclusion and Prospect"></a>Conclusion and Prospect</h1><p>我们实现了一个基本能用的 Generator，因为是入门教程，代码故意写得很糙，聪明的你一定知道如何改进。</p>
<p>如果你想自己造一个 Generator，那么还需要改进的地方至少有：</p>
<ol>
<li><code>promise_type</code> 内置一个更高效、安全的容器</li>
<li><code>Generator&lt;T&gt;</code> 内置一个迭代器类，以支持 range for 循环。</li>
<li>如果你很熟悉生命周期的坑点，<code>promise_type</code> 内置的容器可以仅存放指向协程自动变量的指针，进一步压缩空间，提升 <code>yield</code> 效率。</li>
<li>利用 execution 来实现异步版本的 Generator。</li>
<li>思考递归 <code>yield</code> 的效率问题，以及如何改进（难但秀）。</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="/2021/11/18/C-20-Coroutine/">C++20 Coroutine - 等疾风</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine (C++20) - cppreference</a></li>
<li><a href="https://github.com/lewissbaker/cppcoro">cppcoro - lewissbaker</a></li>
<li><a href="https://www.bilibili.com/video/BV1z5411Z7K5">协程上手经典案例：实现一个序列生成器 - Benny Huo</a></li>
</ul>
<h1 id="Some-Slight-Improvements"><a href="#Some-Slight-Improvements" class="headerlink" title="Some Slight Improvements"></a>Some Slight Improvements</h1><ol>
<li>使用 <code>std::optional</code> 来做容器，自动调用正确的构造&#x2F;析构函数，支持移动语义。(可以进一步改用 <code>std::variant</code>)。</li>
<li>定义了 Generator 的几个构造和赋值函数，增强了安全性(safety)。</li>
<li>在 <code>unhandled_exception()</code> 内存放了 <code>std::exception_ptr</code>。</li>
<li>用例改为稍微复杂一些的字符串生成，里面有一些性能问题，读者有兴趣的可以找找茬。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 Generator::promise_type  成为一个更安全高效的单元素容器</span></span><br><span class="line"><span class="comment">// 限制了 Generator 的所有权，删除了默认构造，拷贝构造和拷贝赋值</span></span><br><span class="line"><span class="comment">// Generator 保证在构造后持有</span></span><br><span class="line"><span class="comment">// coroutine_handle，但可能被移动走，所以析构时要检查非空</span></span><br><span class="line"><span class="comment">// TODO 迭代器，异常传播</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">promise_type</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;</span><br><span class="line">                std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *m_value; &#125;</span><br><span class="line">        <span class="function">T &amp;<span class="title">result</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *m_value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(T &amp;&amp;value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            m_value.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; m_exception = std::<span class="built_in">current_exception</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">        std::optional&lt;T&gt; m_value;</span><br><span class="line">        std::exception_ptr m_exception;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T &amp;<span class="title">result</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line">    <span class="function">T &amp;<span class="title">result</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_handle.<span class="built_in">promise</span>().<span class="built_in">result</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(std::coroutine_handle&lt;promise_type&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">m_handle</span>(handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(<span class="type">const</span> Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    Generator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Generator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    Generator &amp;<span class="keyword">operator</span>=(Generator &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != other) &#123;</span><br><span class="line">            m_handle = other.m_handle;</span><br><span class="line">            other.m_handle = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_handle) m_handle.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; m_handle.<span class="built_in">resume</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; m_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO begin() end() operator* operator-&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Generator&lt;std::string&gt; <span class="title">lottery</span><span class="params">(<span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    std::string winningNumbers;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> numLen = std::<span class="built_in">to_string</span>(mod - <span class="number">1</span>).<span class="built_in">size</span>();</span><br><span class="line">        winningNumbers.<span class="built_in">reserve</span>(size * (numLen + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_yield</span> winningNumbers += std::<span class="built_in">to_string</span>(<span class="built_in">rng</span>() % mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        winningNumbers += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">co_yield</span> winningNumbers += std::<span class="built_in">to_string</span>(<span class="built_in">rng</span>() % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">auto</span> fi = <span class="built_in">lottery</span>(<span class="number">10</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        fi.<span class="built_in">next</span>();</span><br><span class="line">        cout &lt;&lt; fi.<span class="built_in">result</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">253</span><br><span class="line">253 148</span><br><span class="line">253 148 56</span><br><span class="line">253 148 56 2</span><br><span class="line">253 148 56 2 179</span><br><span class="line">253 148 56 2 179 41</span><br><span class="line">253 148 56 2 179 41 96</span><br><span class="line">253 148 56 2 179 41 96 10</span><br><span class="line">253 148 56 2 179 41 96 10 125</span><br><span class="line">253 148 56 2 179 41 96 10 125 123</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>C++协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; NexT 更新方式</title>
    <url>/2021/04/01/Hexo-NexT-%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g cnpm                 <span class="comment"># 升级 npm</span></span><br><span class="line">cnpm cache clean -f                 <span class="comment"># 清除 npm 缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 package.json 中的 hexo 及个插件版本</span></span><br><span class="line">cnpm install -g npm-check           <span class="comment"># 检查之前安装的插件，都有哪些是可以升级的 </span></span><br><span class="line">cnpm install -g npm-upgrade         <span class="comment"># 升级系统中的插件</span></span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">cnpm update</span><br><span class="line"></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h3 id="更新NexT"><a href="#更新NexT" class="headerlink" title="更新NexT"></a>更新NexT</h3><ol>
<li>重命名原有的主题文件（夹）</li>
<li><code>npm install hexo-theme-next@latest</code></li>
<li>diff配合肉眼更新配置</li>
<li>参考<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">官方文档</a></li>
</ol>
]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellisense and Copy elision</title>
    <url>/2022/04/04/Intellisense-and-Copy-elision/</url>
    <content><![CDATA[<p>最近开发 <code>co_context</code>，遇到了很多 C++ 周边的坑。其中一个坑是 intellisense 翻脸不认 C++17 标准的强制拷贝消除（Mandatory elision of copy&#x2F;move operations）。</p>
<p>这个 intellisense 来自 Vscode Extention: C&#x2F;C++ (Microsoft)。</p>
<h2 id="Brief-Solution"><a href="#Brief-Solution" class="headerlink" title="Brief Solution"></a>Brief Solution</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __INTELLISENSE__</span></span><br><span class="line"><span class="comment">// The fake code to cheat intellisense...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// The real code for compiler...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p><code>co_context</code> 要开发一个 <code>lock_guard</code>，但用户必须要写 <code>co_await</code>，导致只能写成以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lk = <span class="keyword">co_await</span> mtx.<span class="built_in">lock_guard</span>();</span><br></pre></td></tr></table></figure>

<p><code>lk</code> 在析构的时候会自动调用 <code>mtx.unlock()</code>。这看起来很美好，但这里发生了 Copy elision，根据 C++17 标准，这是强制编译器执行的优化，无论拷贝&#x2F;移动构造函数有没有副作用。为了防止用户误用，我干脆删除了拷贝&#x2F;移动构造函数，注意这也是符合标准的做法。</p>
<p>但问题是，intellisense 不知道 Copy elision！因为我删除了那些构造函数，导致 intellisense 会报错：「无法引用 xx 构造函数，它已经被删除」。</p>
<p>最糟糕的是，库的用户在正确使用 <code>lock_guard</code> 时，都可能收到这一条错误的报错（哪怕编译通过），这很有迷惑性，显然会大大降低用户体验。</p>
<h2 id="One-way-compromise"><a href="#One-way-compromise" class="headerlink" title="One way: compromise"></a>One way: compromise</h2><p>最初我选择向 intellisense 妥协：你想让我写移动构造，我写就是了。为了语义正确性，我不得不将 <code>lock_guard</code> 类内部的 <code>mutex&amp;</code> 改成 <code>mutex*</code>，以支持「移动」。</p>
<p>最后在 <code>~lock_guard()</code> 内，我不得不判断 <code>if (mtx != nullptr) mtx-&gt;unlock()</code>，这很丑，也影响了性能。我不能忍受。</p>
<h2 id="The-second-way-cheat"><a href="#The-second-way-cheat" class="headerlink" title="The second way: cheat"></a>The second way: cheat</h2><p>错误的根源是 intellisense 不知道 Copy elision。错误的代价不应由我来承担。</p>
<p>我为 <code>lock_guard</code> 增加了移动构造函数，但标注了 <code>[[deprecated]]</code>，而且内部是 <code>assert(false)</code>，这是为了防止用户误用。这成功地骗过了 intellisense。</p>
<p>因为保证不会拷贝&#x2F;移动，所以可以删除 <code>if (mtx != nullptr)</code> 这样的愚蠢代码啦！</p>
<h2 id="The-final-solution-ifdef"><a href="#The-final-solution-ifdef" class="headerlink" title="The final solution: #ifdef"></a>The final solution: #ifdef</h2><p>经过高人指点，欺骗 intellisense 有专门的宏来完成。所以最后的解决办法是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __INTELLISENSE__</span></span><br><span class="line">    [[<span class="built_in">deprecated</span>(</span><br><span class="line">        <span class="string">&quot;This function is for cheating intellisense, &quot;</span></span><br><span class="line">        <span class="string">&quot;who doesn&#x27;t sense RVO. &quot;</span></span><br><span class="line">        <span class="string">&quot;You should NEVER use this explicitly or implicitly.&quot;</span>)]]</span><br><span class="line">    <span class="built_in">lock_guard</span>(lock_guard &amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">mtx</span>(other.mtx) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span> &amp;&amp; <span class="string">&quot;Mandatory copy elision failed!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">lock_guard</span>(lock_guard &amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中，<code>[[deprecated]]</code> 和 <code>assert</code> 可以删去，因为编译器永远不会处理它们。</p>
]]></content>
  </entry>
  <entry>
    <title>跟我一起写Makefile</title>
    <url>/2020/02/01/Makefile/</url>
    <content><![CDATA[<p>路过一篇写得很到位的Makefile介绍文章，转载一下：</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/overview.html">seisman.github.io&#x2F;how-to-write-makefile</a></p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>One Minute to C++ &quot;defer&quot;</title>
    <url>/2022/02/06/One-Minute-to-C-defer/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lambda&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Defer</span> : Lambda &#123;</span><br><span class="line">    ~<span class="built_in">Defer</span>() &#123; Lambda::<span class="built_in">operator</span>()(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lambda&gt;</span></span><br><span class="line"><span class="function"><span class="title">Defer</span><span class="params">(Lambda)</span> -&gt; Defer&lt;Lambda&gt;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage</span></span><br><span class="line">Defer guard&#123;[sockfd]&#123;</span><br><span class="line">    <span class="built_in">shutdown</span>(sockfd, SHUT_WR);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>This is a short tutorial on implementing golang-style &quot;defer&quot; in C++.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">The favored technique will be:</span><br><span class="line"><span class="addition">+ C++ template and lambda</span></span><br><span class="line"><span class="deletion">- C macro</span></span><br></pre></td></tr></table></figure>

<h1 id="The-Explaination"><a href="#The-Explaination" class="headerlink" title="The Explaination"></a>The Explaination</h1><ol>
<li>Inheriting from a lambda type, we define a template class <code>Defer</code> whose dtor calls the <code>Lambda::operator()</code>.</li>
<li>Explicitly deduce a ctor <code>Defer(Lambda)</code> to the exact type <code>Defer&lt;Lambda&gt;</code>. This step can be omitted in C++20 or later.</li>
<li>Define a <code>Defer</code> object, initialized with the lambda, at any scope, similar to golang.</li>
</ol>
<h1 id="Tips-and-More"><a href="#Tips-and-More" class="headerlink" title="Tips and More"></a>Tips and More</h1><ol>
<li>You may need to capture some local variables into the lambda.</li>
<li><code>-O1</code> is recommended for the lambda inlining, which makes this idiom zero-overhead.</li>
<li>Using C macro, this idiom can be developed more concise. Personally I don&#39;t like C macro, however, because of safety concerns.</li>
<li>A library: <a href="https://github.com/lizho/FakeGolang/blob/master/include/fake_golang.h">lizho&#x2F;FakeGolang</a></li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM实战剖析</title>
    <url>/2020/10/11/SAM%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<ul>
<li><em>实战不会SAM？导致比赛打铁？快 点 学 ！</em></li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机 Suffix Automaton">后缀自动机(Suffix-Automaton)</a>

<span id="more"></span>

<h1 id="在自动机上游走"><a href="#在自动机上游走" class="headerlink" title="在自动机上游走"></a>在自动机上游走</h1><p>从$root$开始，沿目标字符串逐个字符走。若路径存在，即当前子串存在；反之，若出边不存在，即目标子串不存在。</p>
<h2 id="求最小表示"><a href="#求最小表示" class="headerlink" title="求最小表示"></a>求最小表示</h2><p>求字符串$S$的最小表示。</p>
<p><em>度娘有$O(n)$的特殊做法，此处不赘述。</em></p>
<p>构造字符串$SS$的后缀自动机，从$root$开始，每次沿最小的出边走，走n步就得到了$SS$中长度为n的最小子串，即$S$的最小表示。</p>
<h2 id="求本质不同的第k小子串"><a href="#求本质不同的第k小子串" class="headerlink" title="求本质不同的第k小子串"></a>求本质不同的第k小子串</h2><p><a href="https://www.spoj.com/problems/SUBLEX/">SPOJ SUBLEX</a> 题意：求字符串$S$的所有本质不同子串中的第$k$小。$length(S)\le 9e4, 询问数量\le 500$。</p>
<p>SAM构造完成后得到一个DAG，利用拓扑序求从每个点出发可能的路径数目。见<a href="#SAM%E4%B8%8A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序的方法</a>。最后用类似二分法求第k小即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存池+计数排序的SAM，相对优秀</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">9e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    State *pa;</span><br><span class="line">    State *go[MAXW];</span><br><span class="line">    <span class="type">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt;    </span><br><span class="line">&#125;sam[MAXN&lt;&lt;<span class="number">1</span>], *last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(<span class="type">int</span> Max)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref.Max = Max;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">State* <span class="title">alloc</span><span class="params">(State* src)</span> </span>&#123;</span><br><span class="line">    State&amp; ref = sam[State::cnt++];</span><br><span class="line">    ref = *src;</span><br><span class="line">    <span class="keyword">return</span> &amp;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = <span class="built_in">alloc</span>(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;Max == p-&gt;Max+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State* nq = <span class="built_in">alloc</span>(q);</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> State::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"><span class="type">int</span> Q, len;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line">State* b[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似二分法求当前第lef小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> State* now, <span class="type">int</span> dep, <span class="type">int</span> lef)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ans[MAXN];</span><br><span class="line">    <span class="keyword">if</span> (lef == <span class="number">0</span>) &#123;</span><br><span class="line">        ans[dep] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAXW; ++i) <span class="keyword">if</span> (now-&gt;go[i]) &#123;</span><br><span class="line">        <span class="type">const</span> State* g = now-&gt;go[i];</span><br><span class="line">        <span class="keyword">if</span> (lef &lt;= g-&gt;siz) &#123;</span><br><span class="line">            ans[dep] = i+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(g, dep+<span class="number">1</span>, lef<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lef -= g-&gt;siz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    last = root = <span class="built_in">alloc</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=len; st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="built_in">extend</span>(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) ++num[sam[i].Max];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line">    <span class="comment">// 沿拓扑序DP</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;State::cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (b[i]-&gt;go[j])</span><br><span class="line">                 b[i]-&gt;siz += b[i]-&gt;go[j]-&gt;siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="type">int</span> aim;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aim);</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, aim);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="离线计算-Right"><a href="#离线计算-Right" class="headerlink" title="离线计算|Right|"></a>离线计算|Right|</h1><p>构造好的后缀自动机隐含了一颗分裂树，只需访问所有节点和$Pa$指针，就能还原这颗分裂树。显然，叶子节点的$|Right| &#x3D; 1$，但仅有这些信息还不足推出其他节点的$|Right|$，这是因为节点在往下分裂时可能丢失元素<br><br/><img src="/2020/10/11/SAM%E5%AE%9E%E6%88%98/abaTree.png" alt="&quot;aba&quot;的分裂树。“1”没有出现在叶节点中"></p>
<p>如上图所示，“1”在分裂的过程中消失了，不存在叶子节点中。</p>
<p>为什么$Right$集合的元素无法往下分裂？这是因为它表示的子串无法向左端扩展，换句话说，它是前缀。注意到叶子节点也是前缀。综上所述，只要对前缀所在节点的$|Right|$预置为$1$（其他节点预置为$0$），然后自底向上更新分裂树即可得到所有$|Right|$</p>
<h2 id="分裂树上拓扑排序"><a href="#分裂树上拓扑排序" class="headerlink" title="分裂树上拓扑排序"></a>分裂树上拓扑排序</h2><p>上文引出了一个新问题，如何自底向上地访问分裂树？一种直观的办法是bfs收集SAM所有节点再做拓扑排序，这逻辑复杂而代码繁琐。一种更好的办法是，在构造SAM时采用内存池技术，之后对内存池按照$Max$降序排序即可。原因是<br>$$ Max(fa)+1&#x3D;Min(s) \Rightarrow Max(s) &gt; Max(fa)$$<br>有趣的是，分裂树的拓扑序也是自动机的拓扑序！原因是<br>$$ trans(s, *)&#x3D;t \Rightarrow Max(t) &gt; Max(s) $$<br>如果你忘记了，请复习<a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机 Suffix Automaton">后缀自动机的更多性质</a>。</p>
<div class="note primary"><h4 id="拓扑排序要点"><a href="#拓扑排序要点" class="headerlink" title="拓扑排序要点"></a>拓扑排序要点</h4><ol>
<li>指针板构造采用内存池技术</li>
<li>$Max$可能的取值仅有$[1,n]$，所以要采用计数排序</li>
<li>不要真的修改内存池，而是新开指针做排序</li>
<li>如果不得不写常规拓扑排序，bfs时请注意DAG的重复访问</li>
</ol>
</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) ++num[sam[i].Max];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) num[i] += num[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) b[--num[sam[i].Max]] = &amp;sam[i];</span><br><span class="line"><span class="comment">// sam[] has been top sorted by b[].</span></span><br></pre></td></tr></table></figure>

<p>剩余细节在<a href="#%E6%B1%82%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AC%ACk%E5%B0%8F%E5%AD%90%E4%B8%B2">例题1</a>、<a href="#%E6%B1%82%E9%95%BF%E5%BA%A6%E4%B8%BA-i-%E7%9A%84%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">例题2</a>中体现</p>
<h2 id="求长度为i的子串的最大出现次数"><a href="#求长度为i的子串的最大出现次数" class="headerlink" title="求长度为i的子串的最大出现次数"></a>求长度为i的子串的最大出现次数</h2><p><a href="https://www.spoj.com/problems/NSUBSTR/">SPOJ NSUBSTR</a> 题意：给出字符串S（长度&lt;&#x3D;2.5e5），设f(x)为S中长度为x的子串的最大出现次数，求f(1...length(s))。</p>
<p>分析：后缀自动机中每个状态$s$蕴含的字符串长度为$[Min(s), Max(s)]$，每个出现了$Right(s)$次，只需用$|Right(s)|$更新$ans[Max(s)]$就行了，在最后输出前依次用$ans[i+1]$更新$ans[i]$即可。原因是长度更长的子串出现的次数一定不超过长度短的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 朴素的拓扑排序版本，推荐改用计数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">50</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">250000</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    State* pa;</span><br><span class="line">    State* go[MAXW];</span><br><span class="line">    <span class="type">int</span> Max;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> RSiz = <span class="number">0</span>, inD = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> Max) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="built_in">sizeof</span>(go));</span><br><span class="line">        pa = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Max = Max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">State</span>(<span class="type">const</span> State* o) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(go, o-&gt;go, <span class="built_in">sizeof</span>(go));</span><br><span class="line">        pa = o-&gt;pa;</span><br><span class="line">        Max = o-&gt;Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root, *last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    State *p = last, *np = <span class="keyword">new</span> <span class="built_in">State</span>(p-&gt;Max+<span class="number">1</span>);</span><br><span class="line">    last = np;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; !p-&gt;go[c])</span><br><span class="line">        p-&gt;go[c] = np, p = p-&gt;pa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line">    </span><br><span class="line">    State *q = p-&gt;go[c];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Max+<span class="number">1</span> == q-&gt;Max)</span><br><span class="line">        <span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line">        </span><br><span class="line">    State *nq = <span class="keyword">new</span> <span class="built_in">State</span>(q);</span><br><span class="line">    q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">    nq-&gt;Max = p-&gt;Max + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;go[c] == q)</span><br><span class="line">        p-&gt;go[c]=nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">State* q[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        State* <span class="type">const</span> now = q[i];</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;pa) ++now-&gt;pa-&gt;inD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;MAXW; ++j)</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;go[j] &amp;&amp; !now-&gt;go[j]-&gt;vis) &#123;</span><br><span class="line">                q[cnt++] = now-&gt;go[j];</span><br><span class="line">                now-&gt;go[j]-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="built_in">partition</span>(q, q+cnt, [](<span class="type">const</span> State* o) &#123;</span><br><span class="line">        <span class="keyword">return</span> o-&gt;inD == <span class="number">0</span>;</span><br><span class="line">    &#125;) - q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        State* now = q[head++];</span><br><span class="line">        <span class="keyword">if</span> (!now-&gt;pa) <span class="keyword">continue</span>;</span><br><span class="line">        now-&gt;pa-&gt;RSiz += now-&gt;RSiz;</span><br><span class="line">        <span class="keyword">if</span> (--now-&gt;pa-&gt;inD == <span class="number">0</span>)</span><br><span class="line">            q[tail++] = now-&gt;pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    root = last = <span class="keyword">new</span> <span class="built_in">State</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=(len=<span class="number">0</span>); st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        st[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="built_in">extend</span>(st[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs取出SAM中的所有节点，注意判重</span></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对SAM中所有蕴含前缀的状态 |Right| = 1（其它置为0）</span></span><br><span class="line">    State* p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        p = p-&gt;go[st[i]];</span><br><span class="line">        ++p-&gt;RSiz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序，顺便自底向上更新|Right|</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; ++i) &#123;</span><br><span class="line">        ans[q[i]-&gt;Max] = <span class="built_in">max</span>(ans[q[i]-&gt;Max], q[i]-&gt;RSiz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; --i)</span><br><span class="line">        ans[i<span class="number">-1</span>] = <span class="built_in">max</span>(ans[i<span class="number">-1</span>], ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="跳向父亲，舍弃左端，寻求匹配"><a href="#跳向父亲，舍弃左端，寻求匹配" class="headerlink" title="跳向父亲，舍弃左端，寻求匹配"></a>跳向父亲，舍弃左端，寻求匹配</h1><p><code>now = now-&gt;pa</code>的本质是抛弃左端一部分字符，带来的效果是$Right$集合的扩张。这个特性在求最长公共子串的时候尤为好用，与KMP舍弃右端部分字符以寻求匹配的原理有异曲同工之妙。</p>
<h2 id="求两字符串的最长公共子串"><a href="#求两字符串的最长公共子串" class="headerlink" title="求两字符串的最长公共子串"></a>求两字符串的最长公共子串</h2><p><a href="https://www.spoj.com/problems/LCS/">SPOJ LCS</a> 题意：求字符串$S1,S2$的最长公共子串(要求连续)</p>
<p>分析：后缀自动机很擅长处理连续串的匹配。试想我们做出$S1$的SAM，然后直接跑$S2$，势必出现出边不存在的问题——无法继续匹配了。不妨设无法继续匹配时，导致无法匹配的字符是$S2[i]$，当前状态为$s$，即$trans(s, S2[i])$不存在，即不存在$S1[r_j]&#x3D;S2[i], r_j\in Right(s)$。想要寻求匹配，只能抛弃已匹配的子串左端，而<code>s=s-&gt;pa</code>恰好带来了最少的抛弃量，使得$Right(s)$能扩张，从而带来匹配的可能性。</p>
<p>换句话说，当<code>s-&gt;go[S2[i]] == nullptr</code>时，重复<code>s = s-&gt;pa</code>，直到获得匹配<code>s-&gt;go[S2[i]] != nullptr</code>或不可能匹配<code>s == nullptr</code>。</p>
<p>假如直接能匹配呢？那太简单了，匹配长度加一，下一位。</p>
<p>于是最终解为：记当前已匹配长度$match$，当前答案$ans$，当前自动机状态$s$，接下来尝试匹配$S2[i]$，若$trans(s,S2[i])$存在，就转移，并且$match$加一；否则尝试不断跳分裂树的$fa$，直到转移存在，由于$Max(fa) &lt; Min(s) \le match$，$match$必能取到$Max(fa)$，所以$s$跳到$trans(fa, S2[i])$， $match$取为$Max(fa)+1$即可。每走一步都用$match$更新$ans$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略SAM的构造和其他乱七八糟的东西</span></span><br><span class="line">    State* now = root;</span><br><span class="line">    <span class="type">int</span> match = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; sb[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> c = (sb[i]-=<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now-&gt;go[c]) &#123;</span><br><span class="line">            now = now-&gt;go[c];</span><br><span class="line">            ++match;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (now &amp;&amp; !now-&gt;go[c])</span><br><span class="line">                now = now-&gt;pa;</span><br><span class="line">            <span class="keyword">if</span> (now) &#123;</span><br><span class="line">                match = now-&gt;Max+<span class="number">1</span>;</span><br><span class="line">                now = now-&gt;go[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now = root;</span><br><span class="line">                match = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, match);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机 Suffix Automaton</title>
    <url>/2020/10/01/Suffix-Automaton/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="自动机的五个部分"><a href="#自动机的五个部分" class="headerlink" title="自动机的五个部分"></a>自动机的五个部分</h2><ol>
<li><strong>alpha</strong> 字符集</li>
<li><strong>state</strong> 状态集合。另让$null$表示不存在的状态或转移</li>
<li><strong>init</strong> 初始状态</li>
<li><strong>end</strong> 结束状态集合</li>
<li><strong>trans</strong> 状态转移函数：令$trans(s, str)$表示在状态$s$时读入字符串$str$后，所达到的状态。$trans$应具有传递性。</li>
</ol>
<span id="more"></span>

<h2 id="设"><a href="#设" class="headerlink" title="设"></a>设</h2><ol>
<li>自动机能识别的所有字符串集合<strong>Reg(A)</strong> ，其中的字符串$x$满足$trans(init, x)\in end$</li>
<li>从状态$s$开始能识别的字符串 <strong>Reg(s)</strong></li>
<li>后缀自动机<strong>SAM</strong>，一个能识别母串$S$的所有后缀的自动机。$SAM(x)&#x3D;true$当且仅当$x$是$S$的后缀。</li>
<li>$trans(init, str)$即从初始状态读入$str$后到达的状态<strong>ST(str)</strong> <em>（ST是state的缩写)</em></li>
<li>母串$S$的所有后缀的集合<strong>Suf</strong>，从$a$位置开始的后缀<strong>Suffix(a)</strong></li>
<li>母串$S$的所有连续子串的集合<strong>Fac</strong>，位置为$[l,r)$的子串<strong>S[l,r)</strong></li>
</ol>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="SAM的可行性分析"><a href="#SAM的可行性分析" class="headerlink" title="SAM的可行性分析"></a>SAM的可行性分析</h2><ol>
<li><p>对于字符串$s$，若$s\in Fac$，则$ST(s)$应存在，这是因为可以在$s$后面加上一些字符使其变成$S$的后缀。<em>反之$s\notin Fac$，则应有$ST(s)&#x3D;null$以节省空间</em></p>
</li>
<li><p>考虑$ST(a)$能识别哪些字符串，即$Reg(ST(a))$。若$x\in Reg(ST(a))$，则$ax\in Suf$，故$ax$是后缀，$x$也是后缀。$Reg(ST(a))$是每次$a$出现后接下来的后缀。设<strong>Right(a)</strong> 为a每次出现的开区间末位置，则$Reg(ST(a))$完全由$Right(a)$决定。</p>
</li>
<li><p>对于状态$s$（不是单个字符串），我们关心$Reg(s)$。如果对于$a,b\in Fac$有$Right(a)&#x3D;Right(b)$，那么可令$ST(a)&#x3D; ST(b)$。所以一个状态$s$由所有$Right$集合是<strong>Right(s)</strong> 的字符串组成。</p>
</li>
<li><p>考虑状态$s$包括的字符串长度，易证若$s$包含长度为$l$,$r$的字符串，那么一定包含长度为$m(l \leq m \leq r)$的字符串。所以这些字符串长度一定可以组成一个区间，设为 <strong>[Min(s), Max(s)]</strong></p>
</li>
<li><p>状态数是线性的。<br/>　　状态由$Right$集合决定，考虑两个状态$a,b$的$Right$集合$R_a,R_b$。假设$R_a,R_b$有交集，设$r \in R_a \cap R_b$。由于一个子串只能属于一个状态，所以$a$，$b$所表示的子串不会有交集，即由$r$往前不能有长度相同的子串，故$[Min(a), Max(a)]$和$[Min(b), Max(b)]$没有交集，不妨设$Max(a) &lt; Min(b)$，由于$a$，$b$包含的所有串都可以视为$r$往前的子串，故$a$的所有串都是$b$的任意串的后缀。因$b$的任意串都能找到后缀属于$a$，两者$Right$集合又不相等，故$R_b \subset R_a$。那么任意两个状态的$Right$集合要么不相交，要么一个是另一个的真子集。<br/>　　疾风将以状态为节点，以$Right$包含关系为父子关系构成的树叫 <strong>“分裂树”</strong> <br/>　　不考虑字符串这个主题，“分裂树”易证是线性的；实际上，$SAM$的结点个数最多为$2n$。<br><br/><img src="/2020/10/01/Suffix-Automaton/%E5%88%86%E8%A3%82%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="分裂树举例"></p>
</li>
<li><p>更严谨的分裂树定义：令满足$Right(s) \subset Right(fa)$的最小$|Right(fa)|$的$fa$为状态$s$的父亲。<br/>　　直观地看，一定是$fa$中最长的字符串向前扩展一位导致了$Right$集合分裂，所以$Max(fa)+1&#x3D;Min(s)$。</p>
</li>
<li><p>自动机的边数是线性的。<br/>　　直观地看，自动机是一个DAG（否则可以无限地在自动机上走，即识别无限长的字符串，显然这是不可能的），而能从$init$走到某个$end$点的肯定是字符串的某一个后缀。字符串只有$n$个后缀，意味着从$init$到$end$只能有$n$种路径；另一方面，节点数只有$O(n)$，所以猜测边数也是$O(n)$的。<br/>　　标出自动机任意一个生成树，则对于一条非树边$(a\rightarrow b)$，存在若干路径${init \rightarrowtail a \rightarrow b \rightarrowtail e(e\in end)}$对应着一个后缀。对每一个后缀，对应在自动机上走到的第一条非树边。如此每个后缀最多对应一个非树边，而非树边至少被一个后缀对应，所以后缀数量$\geq$非树边数量。所以边数是$O(n)$的。</p>
</li>
</ol>
<h2 id="归纳法构造SAM"><a href="#归纳法构造SAM" class="headerlink" title="归纳法构造SAM"></a>归纳法构造SAM</h2><h3 id="SAM的更多性质"><a href="#SAM的更多性质" class="headerlink" title="SAM的更多性质"></a>SAM的更多性质</h3><p><em>这一部分是SAM构造算法的重要依据。<br/>请确认上文所有加粗内容都已理解。</em></p>
<ol>
<li><p>后缀自动机是一个有向无环图<br>$$<br>SAM &#x3D; {分裂树的点，自动机的有向边}<br>$$ </p>
</li>
<li><p>SAM的构造算法是在线的，即从左到右逐个添加字符。根据数学归纳法，<strong>下文假设已有字符串$T$的后缀自动机</strong>。</p>
</li>
<li><p>考虑一个状态$s$，它的$Right(s)&#x3D;{r_1, r_2, \cdots, r_n}$，假如有状态转移$trans(s,c) &#x3D; t$（即状态$s$后添加一个字符$c$得到状态$t$），由于向右扩展了一位字符，$Right(s)$中只有$T[r_i]&#x3D;c$的满足要求。所以$Right(t)&#x3D;{r_i+1 | T[r_i]&#x3D;c}$。<br/>　　如果$trans(s,c)$存在，那么$trans(Pa(s), c)$必定存在，其中$Pa(s)$表示分裂树上状态$s$的父亲。并且$Right(trans(s,c)) \subseteq Right(trans(Pa(s),c))$。<br/>　　另一个显然的结论是$Max(s)&lt;Max(t)$。</p>
</li>
<li><p>后缀自动机没有显式地储存$Right$集合。因此可以认为修改$Right$的时间复杂度为$O(0)$。</p>
</li>
<li><p>初始状态时母串$T$为空字符串，自动机只有一个节点$root$。</p>
</li>
</ol>
<h3 id="添加一位字符更新自动机"><a href="#添加一位字符更新自动机" class="headerlink" title="添加一位字符更新自动机"></a>添加一位字符更新自动机</h3><p>　　令当前字符串为$T$，长度为$L$；末尾添加一个字符$x$，要将$SAM(T)$更新为$SAM(Tx)$。<br><br/>　　那么新增的子串是$Tx$的所有后缀，可看作$T$的所有后缀后添加了$x$。令$SAM(T)$中表示$T$的后缀的节点为${v_1, v_2, \cdots, v_k&#x3D;root}$。因为后缀在字符串的末尾出现，所以$L\in Right(v_i)$，可知$v_i$在分裂树上恰好构成一条从叶子到$root$的链，不妨设${v_1, v_2, \cdots, v_k&#x3D;root}$已经按从叶子到祖先排序。<br><br/>　　添加字符$x$后，首先新建状态$np$表示$ST(Tx)$，这是一个已确定的状态（因为没有出边），可知$Right(np)&#x3D;{L+1}$。<br><br/>　　回头考虑旧自动机的$v_i$，设$Right(v_i)&#x3D;{r_1, r_2, \cdots, r_n&#x3D;L}$。如果能在后面添加字符$x$（注意现在仍是字符串$T$的自动机），即$nv&#x3D;trans(v_i, x)$存在，我们已经知道$Right(nv)&#x3D;{r_i+1|T[r_i]&#x3D;x}$；反之如果$v_i$没有$x$的出边，意味着没有$r_i$满足$T[r_i]&#x3D;x$。由于分裂树上父亲的$Right$扩大，如果$trans(v_i,x)$存在，那么$trans(v_{i+1}, x)$也存在。<br><br/>　　对于所有$trans(v,x)&#x3D;null$的$v$，而只有$Tx[r_n&#x3D;L]&#x3D;x$满足转移条件，于是添加一条边$trans(v,x)&#x3D;np$。<br><br/>　　令$v_p$是$v_1, v_2, \cdots, v_k$中第一个有$x$出边（即$trans(v_p, x)$存在）的状态。令$q&#x3D;trans(v_p, x)$，注意，现在仍是旧的自动机。我们能不能直接在$Right(q)$中直接插入$L+1$呢？答案是不能。这是因为有可能$Max(q) &gt; Max(v_p)+1$，隐含意思是$q$在”$v_p$末尾添加$x$”的基础上，由于$Right$集合的缩减，纳入了左端更多字符；如果强行在$Right(q)$中插入$L+1$，会导致$Max(q)$减小而丢失了原来的状态，破坏了自动机的正确性。</p>
<p><img src="/2020/10/01/Suffix-Automaton/%E5%BC%BA%E8%A1%8C%E6%8F%92%E5%85%A5%E7%9A%84%E5%8F%8D%E4%BE%8B.png" alt="强行插入的反例"><br><br/>　　如图所示，$v_p$含有的最长字符串是红色5个“A”，但$trans(v_p,x)&#x3D;q$含有的最长字符串是蓝色7位字符串，如果在$Right(q)$中强行插入$L+1$即变为绿色部分，会使$Max(q)$从7减少到6从而丢失信息。<br><br/>　　如果足够幸运，$Max(q) &#x3D; Max(v_p)+1$，就没有上面的问题，我们可以在$Right(q)$中插入$L+1$，然后只要令$Pa(np)&#x3D;q$即可完成自动机更新。<em>注：理论上$Right(trans(v_p\dots v_k,x))$都要插入$L+1$，但这些状态的出边都没有发生改变，而后缀自动机实际上不记录$Right$，所以更新完成。</em><br><br/>　　如果没那么幸运，从图上可知，原状态$q$在插入末尾字符$x$后应转换两个状态，设蓝色对应的状态为$q&#39;$（沿用$q$)，绿色状态为$nq$（新建节点）。显然<br>$$<br>trans(q&#39;, *) &#x3D; trans(q, *), \<br>Pa(q&#39;)&#x3D;nq，\<br>Right(nq)&#x3D;Right(q&#39;)\cup {L+1}，\<br>Max(nq) &#x3D; Max(v_p)+1<br>$$<br>显然$Right(nq)$是真包含${L+1}$的最小集合，所以<br>$$ Pa(np)&#x3D;nq $$<br><br/>　　截至目前我们新添了$np$，将$q$转化为$q&#39;,nq$，其中$np,q&#39;$都正确处理了出边和分裂树父亲。<br>那么$nq$的分裂树父亲又是谁呢？结合上图易证<br>$$ Pa(nq)&#x3D;Pa(q) $$</p>
<p>$nq$的出边是哪一些？由于新添的最后一个字符不能带来更多的状态转移（最后一个字符后面再没有字符了），所以<br>$$ trans(nq, *) &#x3D; trans(q, *) $$<br><br/>　　最后，我们还要考虑原自动机中指向$q$的状态，和新自动机中应当指向$q&#39;$和$nq$的状态。在$v_p,\cdots,v_k$中，由于$Right$的扩大，$Right(trans(v_i,x))$也逐渐扩大（不缩小），所以只有一段连续的$v_p,\cdots,v_e(e\le k)$是指向$q$的，由于要配合在$Right$集合中插入$L+1$，这些出边要修改为<br>$$ trans(v_i,x) &#x3D; nq $$<br>其余指向$q$的状态必然由于左端有过多字符而无法指向$nq$，于是改为指向$q&#39;$，等效于不做任何修改。<br><br/>　　最后的最后，对于$v_{e+1},\cdots,v_k$，对于$nv&#x3D;trans(v_i, x)$，必然可以粗暴地令$Right(nv)$插入$L+1$，所以转移关系可以保持不变，等效于不做任何修改。</p>
<h1 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXW = <span class="number">26</span>, MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">	State* go[MAXW];</span><br><span class="line">	State* pa;</span><br><span class="line">	<span class="type">int</span> mx;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">State</span>(<span class="type">int</span> MX):<span class="built_in">pa</span>(<span class="number">0</span>), <span class="built_in">mx</span>(MX) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(go, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">State</span>(<span class="type">const</span> State* o) &#123;</span><br><span class="line">		pa = o-&gt;pa;</span><br><span class="line">		<span class="built_in">memcpy</span>(go, o-&gt;go, <span class="built_in">sizeof</span>(o-&gt;go));</span><br><span class="line">		mx = o-&gt;mx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;*last, *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	State* p = last;</span><br><span class="line">	State* np = <span class="keyword">new</span> <span class="built_in">State</span>(p-&gt;mx+<span class="number">1</span>);</span><br><span class="line">	last = np;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==<span class="number">0</span>)</span><br><span class="line">		p-&gt;go[x] = np, p = p-&gt;pa;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> np-&gt;pa = root, <span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">	State* q = p-&gt;go[x];</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;mx+<span class="number">1</span> == q-&gt;mx)</span><br><span class="line">		<span class="keyword">return</span> np-&gt;pa = q, <span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">	State* nq = <span class="keyword">new</span> <span class="built_in">State</span>(q);</span><br><span class="line">	nq-&gt;mx = p-&gt;mx+<span class="number">1</span>;</span><br><span class="line">	q-&gt;pa = np-&gt;pa = nq;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;go[x]==q)</span><br><span class="line">		p-&gt;go[x] = nq, p = p-&gt;pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line"></span><br><span class="line">	last = root = <span class="keyword">new</span> <span class="built_in">State</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; st[i]!=<span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line">		<span class="built_in">extend</span>(st[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>　　SAM思路真的异常精妙，环环相扣，巧夺天工。不幸的是优美的结论是以复杂而庞大的论证为代价的。<br><br/>　　被奉为圣经的<code>2012年noi冬令营陈立杰讲稿(SAM后缀自动机)</code>在描述构造过程的时候没有解释可以省略的操作为什么被省略，导致思路有很大残缺和跳跃。即使是本文也用了不少“显然”字眼，但比较原文已有较大改进。另外，原讲稿没有交代构造算法为什么是$O(n)$的。<del>疾风理解这ppt花了整整三天</del>如果本文对你有帮助，不妨赏疾风一支冰阔乐喝（馋.jpg）<br><br/>　　有人说SAM完全可以当做黑盒来用，我认为不然。黑盒SAM的唯一功能是判定子串是否存在，局限性很大。而SAM的实战应用代码相对裸构造有很大增改，例如要结合dfs序，平衡树，动态树等等技巧，且都是建立在完全理解后缀自动机的基础上，难度依然很大。这部分日后再填补。</p>
<p><em>转载请注明原作者和网址</em></p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu双系统双显卡装机</title>
    <url>/2020/01/25/Ubuntu%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久之前就在Windows笔记本上装了ubuntu 18.04 LTS，因为是双系统，需要手动给硬盘分区，而当时ubuntu的系统分区贼多，埋下了某一个分区过小的伏笔。最近某Filesystem塞满了（500MB），才发现很多双系统安装教程没有卸载教程！</p>
<p>于是探索的旅程又开始了。<strong>我们将卸载现有的Ubuntu系统，调整硬盘分区，然后重装ubuntu，并安装最棒的软件和驱动</strong>。</p>
<span id="more"></span>

<h1 id="卸载原有ubuntu"><a href="#卸载原有ubuntu" class="headerlink" title="卸载原有ubuntu"></a>卸载原有ubuntu</h1><p>原有的系统是手动分区的，导致一个硬盘上分区数较多。</p>
<ol>
<li>启动Windows系统，使用分区助手将ubuntu占用的分区合并，并格式化成ext4系统。（格式化似乎不是必要步骤）</li>
<li>准备好ubuntu装机u盘。应该都会吧！用UltraISO。</li>
<li>调整BIOS设置。设置为u盘启动，关闭secure boot，华硕的主板还要关闭fast boot。</li>
</ol>
<h1 id="安装ubuntu-18-04-3-LTS"><a href="#安装ubuntu-18-04-3-LTS" class="headerlink" title="安装ubuntu 18.04.3 LTS"></a>安装ubuntu 18.04.3 LTS</h1><ol>
<li>u盘启动，选择试用ubuntu。</li>
<li>开始安装，接好wifi。在询问是否与windows共存的时候点自定义。在分区表中将刚刚在分区助手中合并的分区删除，归还的空间分配到windows的C盘上。然后后退，选择与windows共存。</li>
<li>这时界面让你分割windows的C盘，供ubuntu使用。我分割了32GB，建议贪多，原因玄学。</li>
<li>一路安装，没什么大问题。</li>
</ol>
<h1 id="登录ubuntu"><a href="#登录ubuntu" class="headerlink" title="登录ubuntu"></a>登录ubuntu</h1><p>因为是双显卡（Intel集显 + Geforce MX150），这可能会导致开机登录困难，原因是默认的独显驱动有问题，导致机器卡死。</p>
<ol>
<li><p>在grub引导时，对ubuntu按&quot;e&quot;，倒数第二行找到<code>quiet splash *</code>，修改为<code>quiet splash acpi_osi=linux nomodeset *</code>，按&quot;F10&quot;引导。这么做是为了禁用所有显卡驱动。</p>
</li>
<li><p>开机后分辨率是800*600的，操作不便时按&quot;Alt+F7&quot;移动窗口。</p>
</li>
<li><p>安装vim。(喜欢gedit的不安装也完全可以)</p>
</li>
<li><p>按照以下代码禁用Nvidia开源显卡驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内加入以下黑名单</span></span><br><span class="line">blacklist vga16fb</span><br><span class="line">blacklist nouveau</span><br><span class="line">blacklist rivafb</span><br><span class="line">blacklist rivatv</span><br><span class="line">blacklist nvidiafb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出，然后更新boot配置</span></span><br><span class="line">sudo update-initramfs -u</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li>
<li><p>现在可以正常开机了。接下来安装Nvidia官方闭源驱动（可跳过）。打开ubuntu自带软件Software &amp; Updates，在Additional Drivers里勾选闭源驱动，版本号选大一点，Apply Changes，等一段时间下载安装即可。</p>
</li>
<li><p>重启电脑，Enjoy！可以根据喜好调整NVIDIA X Server Settings的内容。<br>PS：不要自行下载英伟达官网的驱动！亲测无效！相信我！</p>
</li>
<li><p>调整grub引导，自己看着办吧，当然不是必须的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="触摸板右键失灵"><a href="#触摸板右键失灵" class="headerlink" title="触摸板右键失灵"></a>触摸板右键失灵</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad click-method areas</span><br></pre></td></tr></table></figure>

<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>ubuntu默认源已经很久没更新Vim，所以加上源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/vim </span><br></pre></td></tr></table></figure>

<p>再给出竞赛用~&#x2F;.vimrc岂不美哉！赶紧背下来！</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="keyword">set</span> autoread</span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">call</span> CompileCPP()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! CompileCPP()</span><br><span class="line">    exec <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;g++ -Wall -DDEBUG % -o %&lt;&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> Run()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! Run()</span><br><span class="line">    exec <span class="string">&quot;!./%&lt;&quot;</span></span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>

<p>如果控制台&quot;F10&quot;被占用，就在preferences里取消掉。</p>
<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p>没什么好说的，只想说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --get-selections | grep firefox</span><br><span class="line">sudo apt purge firefox firefox-locale-en firefox-locale-zh-hans</span><br><span class="line">sudo apt autoremove</span><br><span class="line"><span class="comment"># 司马笑</span></span><br></pre></td></tr></table></figure>

<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>借助Settings Sync插件可以很快配置Code，但是各种task还需要自行备份。</p>
<h1 id="飞机"><a href="#飞机" class="headerlink" title="飞机"></a>飞机</h1><p>第一次在~&#x2F;.local下安装软件，需要注销重登录才能正常使用。<br>某些算法需要额外的库，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libsodium-dev</span><br></pre></td></tr></table></figure>
<p>搞定之后在Settings-&gt;...-&gt;Socks Host作调整即可。</p>
<h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p>调整控制台的配色和透明度，换壁纸等等，不多说了。</p>
<p>ubuntu很鸡贼，用日本字来糊弄我，字体很不好看，统统干掉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将SC挪到最前面，解决“门”等字显示不正常的问题。</span></span><br><span class="line">sudo vim /etc/fonts/conf.d/64-language-selector-prefer.conf</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其他杂七杂八的东西就自行解决吧，祝看官ubuntu旅程愉快！</p>
]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>co_context[0]: C++高性能协程框架</title>
    <url>/2022/05/26/co-context-0/</url>
    <content><![CDATA[<p><a href="https://github.com/Codesire-Deng/co_context">co_context</a> 是最近开发的 C++ 异步协程框架，以<strong>易用性</strong>为最高目标，尽量兼顾<strong>性能</strong>。希望从此 C++ 的异步能比 Node.js 更简单，更优雅。</p>
<p>co_context 是基于 Linux io_uring，I&#x2F;O 走内核态协议栈，这是 co_context 努力逼近的性能上限。</p>
<span id="more"></span>

<p>做了几个小测试，性能还是比较猛的。如果别的网络框架，但凡沾上 <code>shared_ptr</code>，<code>mutex</code>，<code>memory_order_seq_cst</code> 等等重型工具，多半要比 co_context 慢一些。</p>
<hr>
<p>2022&#x2F;5&#x2F;26 更新：</p>
<ul>
<li>新增 「I&#x2F;O 取消」和「超时 I&#x2F;O 取消」，API 更好用了；</li>
<li>更新调度策略，redis-PING QPS 突破 50 万了；</li>
<li>重做 redis-benchmark 的实验：<ul>
<li>发现后台运行 Chrome 会显著影响 CPU 调度，进而影响性能表现——关闭 Chrome；</li>
<li>发现网络代理会降低 localhost 通信的性能——关闭网络代理；</li>
</ul>
</li>
<li>链式 I&#x2F;O 中operator+ 的求值顺序是由编译器定义的，因此弃用，改用operator&amp;&amp; ；</li>
<li>毕设 co_context 通过审核了 ，过几天儿童节答辩 ~</li>
</ul>
<hr>
<h2 id="用例速览"><a href="#用例速览" class="headerlink" title="用例速览"></a>用例速览</h2><h3 id="redis-PING-INLINE"><a href="#redis-PING-INLINE" class="headerlink" title="redis-PING_INLINE"></a>redis-PING_INLINE</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/io_context.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/lazy_io.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;co_context/net/acceptor.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint16_t</span> port = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">reply</span>(co_context::socket sock) &#123;</span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">co_await</span> sock.<span class="built_in">recv</span>(recv_buf);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">co_await</span> (sock.<span class="built_in">send</span>(&#123;<span class="string">&quot;+OK\r\n&quot;</span>, <span class="number">5</span>&#125;) &amp;&amp; sock.<span class="built_in">recv</span>(recv_buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">server</span>() &#123;</span><br><span class="line">    acceptor ac&#123;inet_address&#123;port&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sockfd; (sockfd = <span class="keyword">co_await</span> ac.<span class="built_in">accept</span>()) &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="built_in">co_spawn</span>(<span class="built_in">reply</span>(co_context::socket&#123;sockfd&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context ctx&#123;<span class="number">32768</span>&#125;;</span><br><span class="line">    ctx.<span class="built_in">co_spawn</span>(<span class="built_in">server</span>());</span><br><span class="line">    ctx.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个 redis-server，但无论接收什么命令，都只会返回一个&quot;+OK&quot;。猜猜它的 QPS 是多少？单线程下，面向 1000 个客户端，co_context QPS 是 55 万，而 redis 本尊是 36 万，平均延迟、p99延迟等均碾压。虽然……这样的性能在网络框架里勉强及格 （毕竟隔壁 bRPC 动不动五百万并发。。）。</p>
<p>测试工具是 redis-benchmark，其线程开1~3个（使QPS最优），测试环境是单机 5800X, 32GB 3200MHZ-ddr4。</p>
<p><img src="/2022/05/26/co-context-0/redis-single-thread.png" alt="单线程"></p>
<h3 id="链式-I-x2F-O"><a href="#链式-I-x2F-O" class="headerlink" title="链式 I&#x2F;O"></a>链式 I&#x2F;O</h3><p>链式 I&#x2F;O 能减少再入内核态和调度器的次数，增强性能。只需用<code>&amp;&amp;</code>连接请求即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// co_await 优先级太高，须加括号</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">co_await</span> (<span class="built_in">A</span>() &amp;&amp; <span class="built_in">timeout</span>(<span class="built_in">B</span>(), <span class="number">3</span>s) &amp;&amp; <span class="built_in">C</span>());</span><br></pre></td></tr></table></figure>

<p>先做 A，然后做 B（限时 3 秒），（如果没有超时或错误）最后做 C。有错误则返回错误，否则返回 C 的结果。</p>
<h3 id="一秒定时器"><a href="#一秒定时器" class="headerlink" title="一秒定时器"></a>一秒定时器</h3><p>接下来只展示核心代码了，因为非核心代码和上面差不多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">my_clock</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Time = %d\n&quot;</span>, cnt++);</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">timeout</span><span class="params">(<span class="number">1</span>s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每隔一秒，在屏幕上打印时间。当然，这种写法容易有累计误差，切勿模仿喔~</p>
<h3 id="网络超时取消"><a href="#网络超时取消" class="headerlink" title="网络超时取消"></a>网络超时取消</h3><p>用<code>timeout(req, time)</code>能够令<code>req</code>请求限制在<code>time</code>时间以内，若超时则返回失败。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">task&lt;&gt; <span class="built_in">run</span>(co_context::socket peer) &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">int</span> nr = <span class="keyword">co_await</span> <span class="built_in">timeout</span>(peer.<span class="built_in">recv</span>(buf), <span class="number">3</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">lazy::write</span><span class="params">(STDOUT_FILENO, &#123;buf, (<span class="type">size_t</span>)nr&#125;, <span class="number">0</span>)</span></span>;</span><br><span class="line">        nr = <span class="keyword">co_await</span> <span class="built_in">timeout</span>(peer.<span class="built_in">recv</span>(buf), <span class="number">3</span>s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log_error</span>(-nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log_error</span><span class="params">(<span class="type">int</span> err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">case</span> ECANCELED: <span class="comment">// 超时取消</span></span><br><span class="line">            log::<span class="built_in">e</span>(<span class="string">&quot;timeout!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 其他错误</span></span><br><span class="line">            log::<span class="built_in">e</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(err)); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每次TCP<code>recv</code>调用限时3秒钟。</p>
<h3 id="I-x2F-O-取消"><a href="#I-x2F-O-取消" class="headerlink" title="I&#x2F;O 取消"></a>I&#x2F;O 取消</h3><p>I&#x2F;O 可以无理由取消订单，前提是货还没到你的手上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">cancel_fd</span><span class="params">(fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>取消与指定 fd 有关的 I&#x2F;O 操作。</p>
<p>PS: 内部还可以做更细致的取消操作，只是作者还没想好怎么设计 API 比较优雅~</p>
<h3 id="并发量限制"><a href="#并发量限制" class="headerlink" title="并发量限制"></a>并发量限制</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">counting_semaphore sem&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">co_await</span> sem.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="built_in">co_spawn</span>([]() -&gt; task&lt;&gt; &#123;</span><br><span class="line">            socket sock&#123;..&#125;;</span><br><span class="line">            <span class="keyword">co_await</span> sock.<span class="built_in">connect</span>(..) &amp;&amp; sock.<span class="built_in">send</span>(..) &amp;&amp; sock.<span class="built_in">recv</span>(..)</span><br><span class="line">                     &amp;&amp; sock.<span class="built_in">close</span>();</span><br><span class="line">            sem.<span class="built_in">release</span>();</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将业务并发量限制在 100 以内。注意<code>counting_semaphore</code>是针对 co_context 特制的，wait-free，性能比较好。</p>
<h3 id="其他协程间同步工具"><a href="#其他协程间同步工具" class="headerlink" title="其他协程间同步工具"></a>其他协程间同步工具</h3><p>类似的同步工具还有<code>mutex</code>，<code>condition_variable</code>。所有的同步工具的使用体验和 C++ 标准定义的类似，不会有额外学习成本哦~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line">co_context::mutex mtx;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">add</span>() &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = <span class="keyword">co_await</span> mtx.<span class="built_in">lock_guard</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) ++cnt;</span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context ctx&#123;<span class="number">2048</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) ctx.<span class="built_in">co_spawn</span>(<span class="built_in">add</span>());</span><br><span class="line">    ctx.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>cnt</code>安全地递增至 1e9。</p>
<h2 id="co-context-的主要内容"><a href="#co-context-的主要内容" class="headerlink" title="co_context 的主要内容"></a>co_context 的主要内容</h2><p>co_context 在 4 个方面有贡献：</p>
<ul>
<li>liburingcxx: io_uring 的高性能 C++ binding。</li>
<li>io_context: 针对 L1 cache 的高性能调度器。</li>
<li>coro: 面向用户的协程库，提供简洁、好用、符合直觉的 API，还提供了同步 syscall 的协程 API（基于同步syscall 的上层库可以快速地移植到 co_context）。</li>
<li>net: 基于 coro 提供一些便捷的网络抽象（非必需）。</li>
</ul>
<p>限于篇幅，co_context 的原理将写到其他文章中（也许就是将毕业设计报告的内容抄过来……逃）。</p>
<p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>C++协程</tag>
        <tag>co_context</tag>
      </tags>
  </entry>
  <entry>
    <title>co_context[1]: 易用性设计</title>
    <url>/2022/06/25/co-context-1/</url>
    <content><![CDATA[<p><a href="https://github.com/Codesire-Deng/co_context">co_context</a> 是最近开发的 C++ 异步协程框架，基于 Linux io_uring。<strong>「易用性」</strong>和「性能」是我们最重视的属性，这篇文章，我们介绍在 co_context 中有关易用性的设计。</p>
<span id="more"></span>

<h2 id="I-x2F-O：同步风格，业务专注"><a href="#I-x2F-O：同步风格，业务专注" class="headerlink" title="I&#x2F;O：同步风格，业务专注"></a>I&#x2F;O：同步风格，业务专注</h2><p>任何有意义的计算机程序都需要做 I&#x2F;O，为了提高性能，我们不得不追求更好的 I&#x2F;O 模型。很多网络文章将 I&#x2F;O 模型分成阻塞、非阻塞、多路复用等多种，但本人不太喜欢这种分类（阻塞+非阻塞≠全集，违反直觉）。从代码风格上，我将 I&#x2F;O 模型分成两种：同步式，函数回调式。</p>
<p>以一个简单需求为例：等待五秒钟后，打印“Hello, world!”。我们对比一下同步式和函数回调的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步式，使用C++标准库</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delay_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    <span class="built_in">printf</span>(“Hello, world!\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务代码中使用</span></span><br><span class="line"><span class="built_in">delay_print</span>(); <span class="comment">// 导致当前线程会阻塞5秒</span></span><br><span class="line">std::thread t&#123;delay_print&#125;; <span class="comment">// 生成新线程，令其阻塞5秒</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步式，使用co_context</span></span><br><span class="line"><span class="function">task&lt;<span class="type">void</span>&gt; <span class="title">delay_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">timeout</span><span class="params">(<span class="number">5</span>s)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(“Hello, world!\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务代码中使用</span></span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">delay_print</span><span class="params">()</span></span>; <span class="comment">// 当前协程暂停5秒后被继续执行；当前线程不阻塞（转而执行其他协程）</span></span><br><span class="line"><span class="built_in">co_spawn</span>(<span class="built_in">delay_print</span>()); <span class="comment">// 生成一个新协程，5秒后被执行；当前协程继续执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数回调，使用Boost.Asio</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> error_code &amp; <span class="comment">/*e*/</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context io;</span><br><span class="line">    <span class="function">asio::steady_timer <span class="title">t</span><span class="params">(io, <span class="number">5</span>s)</span></span>;</span><br><span class="line">    t.<span class="built_in">async_wait</span>(&amp;print); <span class="comment">// 总是不会造成阻塞</span></span><br><span class="line">    io.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">同步阻塞式</th>
<th align="left">函数回调式</th>
<th align="left">co_context（同步式）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">学习难度</td>
<td align="left">易</td>
<td align="left">难</td>
<td align="left"><strong>易</strong></td>
</tr>
<tr>
<td align="left">编程难度</td>
<td align="left">易</td>
<td align="left">难</td>
<td align="left"><strong>易</strong></td>
</tr>
<tr>
<td align="left">阅读难度</td>
<td align="left">易</td>
<td align="left">非常难</td>
<td align="left"><strong>易</strong></td>
</tr>
<tr>
<td align="left">调度者</td>
<td align="left">OS（线程调度）</td>
<td align="left">用户（显式）</td>
<td align="left"><strong>用户（隐式）</strong></td>
</tr>
<tr>
<td align="left">并发容量参考</td>
<td align="left">千级</td>
<td align="left">十万级</td>
<td align="left"><strong>十万级</strong></td>
</tr>
<tr>
<td align="left">典型场景</td>
<td align="left">磁盘；客户端</td>
<td align="left">网络；服务器</td>
<td align="left"><strong>全场景</strong></td>
</tr>
</tbody></table>
<p>从业务逻辑的角度看，同步式的表达更加流畅，语言噪音更小，<strong>简单易懂</strong>；而函数回调写的业务比较零散，仅因一个计时器就需要将业务分割成两部分（等待 5 秒，打印 Helloworld），当业务越来越复杂，代码分裂割据的现象就越严重。只需看 Boost.Asio 的 echo server 例子就能知道，回调不是一般人能喜欢写的。所以，co_context 选择了同步写法。</p>
<h2 id="抽象层次：从系统调用出发"><a href="#抽象层次：从系统调用出发" class="headerlink" title="抽象层次：从系统调用出发"></a>抽象层次：从系统调用出发</h2><p>在众多 C++ 异步框架中，抽象层次有高有低。<a href="https://www.boost.org/doc/libs/1_79_0/doc/html/boost_asio/overview.html">Asio</a> 对 Proactor 模式的应用登峰造极，做出 Executor，Strand，Buffer，Stream 等偏向编程的抽象；最近比较活跃的搜狗 <a href="https://github.com/sogou/workflow">Workflow</a> 面向任务流抽象，直接内置了通用网络协议，用户将基础任务和协议串联或并联成自己的应用；中文互联网教科书级别的 <a href="https://github.com/chenshuo/muduo">Muduo</a> 针对网络层和传输层抽象，对熟练计算机网络的同学比较友好；还有 libevent、libev、libuv 等等……任何一种抽象都在学习成本和开发效率上有所优劣。而 co_context 的做法是，直接对<strong>同步阻塞系统调用</strong>抽象（走操作系统的路，让操作系统无路可走）。偏底层的开发者基于 co_context 完成高级业务库后，偏上层的开发者同样是以同步编程的风格来描述业务逻辑。</p>
<h3 id="用系统调用构建你的库"><a href="#用系统调用构建你的库" class="headerlink" title="用系统调用构建你的库"></a>用系统调用构建你的库</h3><p>在 Linux 中，同步阻塞 API 直截了当地表达了程序员的意图，而 co_context 提供的 API 极力地继承了这种特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux 系统调用</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(fd, buf, count);</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">writev</span>(fd, iov, iovcnt);</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">accept4</span>(sockfd, addr, addrlen, flags); <span class="comment">// man7.org/linux/man-pages/man2/accept.2.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// co_context</span></span><br><span class="line"><span class="type">int</span> n = <span class="keyword">co_await</span> <span class="built_in">read</span>(fd, buf, count);</span><br><span class="line"><span class="type">int</span> n = <span class="keyword">co_await</span> <span class="built_in">writev</span>(fd, iov, iovcnt);</span><br><span class="line"><span class="type">int</span> fd = <span class="keyword">co_await</span> <span class="built_in">accept</span>(sockfd, addr, addrlen, flags);</span><br></pre></td></tr></table></figure>

<p>从实现的角度上说，因为底层的 io_uring 也是面向系统调用的，所以提供这些接口的实现并不困难。从用户的角度看，用这些系统调用来实现基本的功能实在是太简单了（相比用函数回调）。例如，实现一个 netcat 基础功能，将 TCP 连接上接收到的任何信息打印到 stdout：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;<span class="type">int</span>&gt; <span class="title">hear</span><span class="params">(co_context::socket peer)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">int</span> nr = <span class="keyword">co_await</span> peer.<span class="built_in">recv</span>(buf);</span><br><span class="line">    <span class="keyword">while</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">co_await</span> <span class="title">lazy::write</span><span class="params">(STDOUT_FILENO, &#123;buf, nr&#125;, <span class="comment">/*offset*/</span><span class="number">0</span>)</span></span>;</span><br><span class="line">        nr = <span class="keyword">co_await</span> peer.<span class="built_in">recv</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle_error(-nr); // 当场处理错误码</span></span><br><span class="line">    <span class="comment">// throw std::system_error&#123;-nr, std::system_category(), &quot;hear&quot;&#125;; // 或者，抛出异常</span></span><br><span class="line">    <span class="keyword">co_return</span> -nr; <span class="comment">// 或者，返回错误码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，上层可以同步地调用<code>hear</code>协程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;<span class="type">void</span>&gt; <span class="title">run</span><span class="params">(<span class="type">int</span> some_para)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> err = <span class="keyword">co_await</span> <span class="built_in">hear</span>(sockfd);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) <span class="built_in">handle_error</span>(err);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>task&lt;void&gt;</code>（或者缩写<code>task&lt;&gt;</code>）是一种特殊的协程类型，可以独立地被生成并运行，例如，开启 10000 个 <code>run()</code> 协程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i)</span><br><span class="line">    <span class="built_in">co_spawn</span>(<span class="built_in">run</span>(i));</span><br><span class="line"><span class="comment">// 是不是很像 std::thread&#123;run, i&#125;.detach() ？</span></span><br></pre></td></tr></table></figure>

<h3 id="库-调度器-x3D-应用"><a href="#库-调度器-x3D-应用" class="headerlink" title="库+调度器&#x3D;应用"></a>库+调度器&#x3D;应用</h3><p>上面的例子演示了如何用协程式 API 实现自己的业务库，但是，光有库是不能做成应用的，我们需要一个调度器来运行这些库函数。调度器负责管理所有的协程，在协程因等待 I&#x2F;O 而暂停时，调度器寻找下一个就绪的协程，并恢复其执行，如此往复。调度器可以掌控一个或多个线程。</p>
<p>co_context 的调度器名叫<code>io_context</code>，这是从 Boost.Asio 借鉴而来的。 与 Asio 需要经常指定 <code>io_context</code> 不同，co_context 是隐式指定的，默认沿用当前的调度器，所以<strong>调度器的存在感非常低</strong>。通常，只有为了更好的负载均衡，将任务分配到特定的线程组上，才需要显式指定调度器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">a</span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">b</span>() &#123;</span><br><span class="line">    <span class="built_in">co_spawn</span>(<span class="built_in">a</span>()); <span class="comment">// 不显式指定，则使用当前的调度器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">c</span>(io_context&amp; io) &#123;</span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">a</span>()); <span class="comment">// 显式指定调度器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c\n&quot;</span>);</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io&#123;<span class="number">32768</span>&#125;;</span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">b</span>()); <span class="comment">// 根源的co_spawn必须指定调度器</span></span><br><span class="line">    io.<span class="built_in">co_spawn</span>(<span class="built_in">c</span>(io));</span><br><span class="line">    io.<span class="built_in">run</span>(); <span class="comment">// 调度器开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高阶-API"><a href="#高阶-API" class="headerlink" title="高阶 API"></a>高阶 API</h2><p>很多人，包括我的毕设答辩考官，可能会忽视协程式 API 的威力。“你是不是仅仅对系统调用做了一个迁移（简单包装）？”当然不是，co_context 提供的惰性求值 API 具有可组合的能力，在<strong>易用性</strong>和<strong>性能</strong>上都是大杀器。</p>
<p><img src="/2022/06/25/co-context-1/HO-api.png" alt="高阶API"></p>
<p>如上图所示，用户可以将两个原始的一阶 API 组合，形成二阶 API。只要有意义，用户要写成三四五六七八阶都不是问题。如下图所示，在运行时，co_context 将整个高<br>阶 API 转化为链表，整个链表只进入一次调度器，只进入一次 io_uring，显然可以节省调度开销。</p>
<p><img src="/2022/06/25/co-context-1/HO-api-principle.png" alt="高阶API原理"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>「面向系统调用」和「高阶 API 」是一套组合拳，从底层开始为用户提供了易用性（和性能）。因为使用了同步的代码风格，我们不难将已有的同步库改写成 co_context 的形式，从而获得强大的并发性能；如果原有库是基于系统调用，那么……可能加一次班就能完成迁移了。</p>
<p>co_context 在易用性上还有其他设计，例如：C++协程帮你托管了堆内存，你不再需要用<code>shared_ptr</code>了；当你忘记用<code>co_await</code>时， 编译器会向你道歉；等等，只不过这些内容有点喧宾夺主，我就不多写了。在未来的文章中，我可能会介绍这些易用性是怎样实现的。下一章，打算先介绍 co_context 的性能设计，看看它用了哪些 trick 来骗取性能。</p>
<hr>
<p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>C++协程</tag>
        <tag>co_context</tag>
      </tags>
  </entry>
  <entry>
    <title>co_context[2]: 性能优化杂谈</title>
    <url>/2022/06/25/co-context-2/</url>
    <content><![CDATA[<p>Hello，我是等疾风！本篇介绍在 <a href="https://github.com/Codesire-Deng/co_context">co_context</a> 中用到的性能优化技巧，希望在各位 C&#x2F;C++ 道友的项目上有所帮助。<strong>重点将在技巧的入门</strong>，而不是 co_context 本身。</p>
<span id="more"></span>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>大多数情况下，我们其实是在优化已有的代码，而不是在设计全新的高性能业务。所以建议在优化之前，先分析出哪些代码是<strong>热点</strong>，哪些代码占用最多的<strong>运行时间&#x2F;空间</strong>，然后再针对性地做优化。相关的工具有 perf，vtune，valgrind 等等。需注意性能分析工具会不会<strong>拖慢程序运行速度</strong>（例如 valgrind，好家伙直接令我的程序假死），因为这会带来测量的误差。</p>
<p>除了现成工具，还可以用 <strong>rdtsc 指令</strong>做低损耗、高精度的时间测量。</p>
<p>在 co_context 里，性能在一开始就是设计重点，所以会减轻一些总体工作量。</p>
<h2 id="无锁化"><a href="#无锁化" class="headerlink" title="无锁化"></a>无锁化</h2><h3 id="细数互斥锁「四宗罪」"><a href="#细数互斥锁「四宗罪」" class="headerlink" title="细数互斥锁「四宗罪」"></a>细数互斥锁「四宗罪」</h3><p>无锁设计，是性能优化入门的一道坎。我们在写多线程程序时，很自然想到用<strong>互斥锁（mutex）</strong>来保护共享数据，防止读到脏数据，防止竞争条件（race condition）。互斥锁还有信号量（semaphore），条件变量等变体，它们的原理都是类似的。但它们会有一些性能缺陷：</p>
<ol>
<li>和线程高度绑定：如果互斥锁抢不到，线程就陷入<strong>阻塞</strong>；</li>
<li>引入额外的数据结构：至少有一条唤醒<strong>队列</strong>，记录哪些线程等待唤醒；且这条队列是<strong>不定长</strong>的；</li>
<li>和操作系统高度绑定：线程的阻塞和唤醒都要走操作系统<strong>内核态</strong>；会打断 CPU 流水线，所以极致性能优化下一般不喜欢看见内核态；</li>
<li>要切换上下文：每次切线程都要暂存和恢复寄存器的值，可能引发<strong>内存 I&#x2F;O</strong>。</li>
</ol>
<p>说了一堆屁话，总之<strong>能避开互斥锁就避开</strong>，而 co_context 比较无脑粗暴，几乎直接禁用了互斥锁。这也会带来一些副作用：线程在空闲的时候也没法阻塞，会导致 CPU 空转，对于其他进程来说无疑是 CPU 强盗。（所以我也给出了备选方案：使用 <code>std::atomic&lt;xxx&gt;::wait/notify</code>，它的原理类似 futex，线程可以阻塞）</p>
<h3 id="无锁世界的秩序"><a href="#无锁世界的秩序" class="headerlink" title="无锁世界的秩序"></a>无锁世界的秩序</h3><p>无锁世界的秩序主要靠<strong>「原子变量」</strong>来维持。原子变量本质是对 CPU 内存顺序、原子指令、编译器乱序约束的封装。本节只做最基本的入门介绍，入门之后，读者可以快速读懂其他文章。</p>
<p>比方说，县长说他到鹅城来，只干三件事，然后就离开。这三件事涉及机密，完成之前外人没法知道其状态。有一天，县长离开了鹅城，说明「三件事」已经完成了。至于是哪件事先做完，哪件事后做完，民间众说纷纭。</p>
<p>在例子中，我们令「县长的位置」为原子变量，若「县长的位置」≠「鹅城」，则编译器和 CPU 保证三件「事」已经完成，但是，由于乱序优化和内存顺序等问题，这三件「事」的完成顺序是不确定的。所幸，我们不关心顺序，只要访问这三件「事」的结果就可以了。</p>
<p>于是，我们解锁了两种 C++ 内存顺序：<code>std::memory_order_release</code> 和 <code>std::memory_order_acquire</code></p>
<p>我们结合代码举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; distance_from_e_city = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="built_in">do_A</span>();</span><br><span class="line"><span class="built_in">do_B</span>();</span><br><span class="line"><span class="built_in">do_C</span>();</span><br><span class="line">distance_from_e_city.<span class="built_in">store</span>(<span class="number">100</span>, std::memory_order_release); <span class="comment">// 瞬移100公里不过分吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (distance_from_e_city.<span class="built_in">load</span>(std::memory_order_acquire) &gt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="built_in">use_A</span>(); <span class="comment">// 必定能看见do_A的结果</span></span><br><span class="line">    <span class="built_in">use_B</span>();</span><br><span class="line">    <span class="built_in">use_C</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会保证<code>std::memory_order_release</code>之前的指令不会被乱序到其之后，但是不保证<code>do_A()</code> <code>do_B()</code> <code>do_C()</code>之间的乱序。</p>
<p>对称地， 保证<code>std::memory_order_acquire</code>之后的指令不会被乱序到其之前，但是不保证<code>use_A()</code> <code>use_B()</code> <code>use_C()</code>之间的乱序。</p>
<p>最终，以原子变量为桥梁，我们实现了安全的共享数据访问。读者可以学习<code>std::memory_order_seq_cst</code> <code>std::memory_order_relaxed</code> 等等来解锁更多姿势。关键词：C++ 内存顺序</p>
<h3 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h3><p>理解内存顺序之后，就能轻松上手无锁数据结构了。**定长单生产者单消费者队列(SPSC queue)**是一种高性能的无锁队列，它有很多约束：容量固定、只支持一个生产者和一个消费者。但它的延迟非常低，实现非常简单，只依赖内存顺序，不依赖互斥锁。co_context 用了 n 条 SPSC 队列来模拟“单生多消”和“多生单消”功能。</p>
<p>其实，保证越少，性能越高。SPSC 队列尚且保留了「先进先出」的队列性质，倘若抛弃队列性质，还有更猛的乱序数据结构，性能提高可逼近100%。但是，乱序性会带来太高的 debug 难度，在负载均衡上也不实用，最终还是被我弃用了。</p>
<h3 id="用户态互斥锁"><a href="#用户态互斥锁" class="headerlink" title="用户态互斥锁"></a>用户态互斥锁</h3><p>底层开发者可以承受没有互斥锁的不便，但不能不给应用层提供互斥锁的等价工具。co_context 给用户提供了互斥锁、信号量和条件变量，它们的 API 与 C++ 标准库几乎一致，在体验上没有差别，在实现上性能会略强，一是因为无等待且完全<strong>不经过内核态</strong>，二是因为没有<strong>引入堆内存分配</strong>。涉及的技巧比较复杂，在这里就不展开介绍了，关键词：用<strong>侵入式链表</strong>实现等待队列。这里推荐参考 <a href="https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/async_mutex.hpp">cppcoro</a> 的互斥锁实现。</p>
<h2 id="cacheline-编排"><a href="#cacheline-编排" class="headerlink" title="cacheline 编排"></a>cacheline 编排</h2><p>常见 CPU 的内存读写都是以 64 字节为单位的，对应 CPU 的 cache 也是每 64 字节为一个「cacheline」。性能优化的必修课之一是妥善安排数据在 cache 中的位置。不妥的安排会导致以下情况：</p>
<ol>
<li><strong>伪共享（false sharing）</strong>：线程 1 读写变量 a，线程 2 读写变量 b，本是老死不相往来，却偏偏让 a 和 b 处于同一 cacheline。</li>
<li><strong>乒乓缓存（cacheline ping-ponging）</strong>：常见于伪共享。变量 a 和 b 位于同一 cacheline，线程 1 只读 a，线程 2 频繁改写 b。结果，每当 b 被线程 2 修改时，线程 1 都要同步 a 所在的 cacheline，这实际上是多余的。</li>
<li>多余读写：常见于指针解引用、通讯协议。可以只用一条 cacheline 完成跨核通讯，实际却用了多条。</li>
<li>cache 浪费：偷懒，无脑塞 64 字节做 padding。这是不负责任的做法，本质只是将 cache-miss 转移到其他数据上。</li>
</ol>
<p>只要善用 C++ 的<code>alignas</code>关键字，针对以上问题，相信读者能想出优化的办法。</p>
<p>co_context 大量使用了 <code>alignas(64)</code>来指定结构体在 cacheline 中的位置，以优化性能。</p>
<h2 id="跨核通信压缩"><a href="#跨核通信压缩" class="headerlink" title="跨核通信压缩"></a>跨核通信压缩</h2><p>这一节也与 CPU cache 有关。</p>
<h3 id="解引用真的有必要吗？"><a href="#解引用真的有必要吗？" class="headerlink" title="解引用真的有必要吗？"></a>解引用真的有必要吗？</h3><p>在多线程程序里，经常见到线程 1 写入变量 a，然后将 <code>p=&amp;a</code> 告诉线程 2，最后，线程 2 读取<code>*p</code> 。这里大概率涉及了两条 cacheline 的同步：一条是指针 p，另一条是<code>*p</code>也就是变量 a。 但这真的有必要吗？</p>
<p>以 co_context 为例，优化前，线程 1 写入 <code>a.type = xxx</code> ，<code>p = &amp;a</code>交给线程 2，线程 2 根据 <code>p-&gt;type</code> 做不同的操作。但是，由于 <code>a.type</code> 只有 8 种取值 ，对应二进制 3 个 bit，而变量 a 正好是按照 8 字节对齐的，a 的地址末尾 3 个 bit 必然为 0，意味着 <code>p = &amp;a</code> 的末尾 3 个 bit 没有携带任何信息。那么为什么不让这 3 个 bit 存放 <code>a.type</code> 呢？</p>
<p>于是，优化后，线程 1 写入<code>p = &amp;a; p |= a.type = xxx;</code> ，p 交给线程 2，线程 2 根据 <code>p &amp; 7</code> 做不同的转发，全过程没有解引用 p，节省了一次 cacheline 传播。</p>
<h3 id="使用-union-但不是-std-variant"><a href="#使用-union-但不是-std-variant" class="headerlink" title="使用 union 但不是 std::variant"></a>使用 union 但不是 std::variant</h3><p>（这一条建议非常激进，读者一旦使用，最好补上充足的文档）</p>
<p>使用 union（联合体）可以进一步压缩 struct 的体积。每当用 union 将 struct 的体积减小到 n*64，每次同步 cacheline 所传输的信息量就会提升，理论性能就会出现一次质变。</p>
<p>用 std::variant 也能达到压缩体积的目的，但是 std::variant 的以类型为单位的多态粒度比较粗糙，内置的异常处理也带来了性能损耗，在极致性能优化时可能会禁用（但 std::variant 满足普通项目是绰绰有余了）。</p>
<h2 id="批处理请求"><a href="#批处理请求" class="headerlink" title="批处理请求"></a>批处理请求</h2><p>在 co_context 中，很容易完成一个批处理优化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">A_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">B_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">C_IO</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="built_in">co_await</span> (<span class="built_in">A_IO</span>(&amp;buf) &amp;&amp; <span class="built_in">B_IO</span>(&amp;buf) &amp;&amp; <span class="built_in">C_IO</span>(&amp;buf));</span><br></pre></td></tr></table></figure>

<p>上面的例子，原本要进入调度器 3 次，将 I&#x2F;O 请求提交给内核态 3 次，在优化后统统变为 1 次。批处理优化的思想无论在底层还是架构层应用层都是非常实用的。</p>
<p>要留意的是批处理是否会<strong>对延迟造成不可接受的影响</strong>，如果为了批处理而强行等待，可能得不偿失。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇介绍了一些 C++ 性能优化的技巧，重点是内存顺序和 CPU cache。虽然性能优化的水很深，需要大量的基础知识和经验积累，但正因此我们有机会为世界做别出心裁的贡献，坚定前行吧骚年！最后，放两张祖传的 co_context 性能测试图：</p>
<p>netcat 网络吞吐（单连接）：<br><img src="/2022/06/25/co-context-2/netcat.png" alt="netcat"></p>
<p>redis-benchmark QPS 和平均延迟（单线程）：<br><img src="/2022/06/25/co-context-2/redis-single-thread.png" alt="redis-benchmark"></p>
<hr>
<p>代码实时同步于 <a href="https://github.com/Codesire-Deng/co_context">Github</a>，求 star~</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>C++协程</tag>
        <tag>co_context</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA 学习笔记</title>
    <url>/2021/08/05/cuda/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>《CUDA 编程 基础与实践》樊哲勇</li>
<li><a href="https://docs.nvidia.com/cuda/index.html">CUDA Toolkit Documentation</a></li>
</ul>
<h2 id="获得-GPU-加速的关键"><a href="#获得-GPU-加速的关键" class="headerlink" title="获得 GPU 加速的关键"></a>获得 GPU 加速的关键</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol>
<li>数据传输比例较小</li>
<li>核函数的算术强度较高</li>
<li>核函数中定义的线程数目较多</li>
</ol>
<h4 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h4><ol>
<li>减少主机与设备之间的数据传输</li>
<li>提高核函数的算术强度</li>
<li>增大核函数的并行规模</li>
</ol>
<span id="more"></span>

<h2 id="SM-流多处理器"><a href="#SM-流多处理器" class="headerlink" title="SM 流多处理器"></a>SM 流多处理器</h2><p>官方有时简称 Multiprocessor</p>
<h3 id="SM-的构成"><a href="#SM-的构成" class="headerlink" title="SM 的构成"></a>SM 的构成</h3><ol>
<li>寄存器</li>
<li>共享内存</li>
<li>常量内存的缓存</li>
<li>纹理和表面内存的缓存</li>
<li>L1 缓存</li>
<li>（常见4个）线程束调度器</li>
<li>执行核心：INT32, FP32, FP64, 单精度浮点数超于函数的特殊函数单元(special function unit, SFUs), 混合精度的张量核心(tensor cores)</li>
</ol>
<h3 id="SM-的占有率"><a href="#SM-的占有率" class="headerlink" title="SM 的占有率"></a>SM 的占有率</h3><p>当并行规模较小，有些 SM 占有率为零，导致程序性能低下。当并行规模足够大时，也有可能得到非 100% 的占有率。</p>
<p>考虑指标（查询官方文档 CUDA_Occupancy_Calculator.xls 的图灵架构）：</p>
<ol>
<li>一个 SM 最多拥有线程块个数$\ N_b &#x3D; 16$。</li>
<li>一个 SM 最多拥有的线程个数$\ N_t &#x3D; 1536$。</li>
<li>线程块大小最大为$\ 1024$。</li>
</ol>
<p>当并行规模足够大（核函数配置的总线程数足够多），需要分几种情况讨论 SM 的理论占有率：</p>
<ol>
<li>寄存器核共享内存使用量很少。SM 的占有率完全由线程块大小决定。首先，由于线程束大小是 32，线程块大小最好是 32 的倍数。其次，线程块大小不能小于$\ N_t&#x2F;N_b$​，才可能利用最大线程数量。因此，96 的线程块大小就能获得 100% 的占有率。类似的，128 的线程块大小在开普勒架构下能获得满占有率。（我选择 128）</li>
<li>寄存器带来占有率瓶颈。一个 SM 最多有 65536（64K）个寄存器。如果令线程数最大化（1536），那么平均一个线程可用 42.7 个寄存器。当每个线程所用的寄存器个数大于 42 时，SM 的占有率将低于 50%。</li>
<li>有限的共享内存对占有率的约束。一个 SM 拥有 65536 字节共享内存。如果线程块大小为 128，且SM 是线程满载（1536），要令占有率为 100%，则网格大小为 12，一个线程块最多有 5461 字节的共享内存。</li>
</ol>
<h3 id="运行时API查询设备"><a href="#运行时API查询设备" class="headerlink" title="运行时API查询设备"></a>运行时API查询设备</h3><p>参考<code>deviceQuery.cpp</code></p>
<h2 id="全局内存的合理使用"><a href="#全局内存的合理使用" class="headerlink" title="全局内存的合理使用"></a>全局内存的合理使用</h2><h3 id="合并访问"><a href="#合并访问" class="headerlink" title="合并访问"></a>合并访问</h3><p>全局内存具有最高的延迟，所以配置有缓存，每次 Cache Miss 默认读取 32 字节。由于缓存命中问题，需要提高内存访问的合并度，从而提高效率。简单起见，只考虑全局内存到 L2 缓存。可以定义合并度(degree of coalescing) 为<strong>一个线程束</strong>请求的字节数除以实际数据传输处理的字节数。合并度体现了显存带宽的利用率。</p>
<p>CUDA 运行时 API 函数分配的内存的首地址至少是256字节的整数倍。</p>
<p>只要确保每当线程束读取一次内存后，该内存对应的32字节范围都被当前线程束利用，则合并度就是100%。</p>
<p>对于一个线程束访问同一个全局内存地址的 4 字节，属于广播式的非合并访问（因为只用了 4 字节而非 32 字节，合并度为 12.5%）。如果内存只读，那么适合采用常量内存。</p>
<h3 id="写优先于只读"><a href="#写优先于只读" class="headerlink" title="写优先于只读"></a>写优先于只读</h3><p>有时候合并写入与合并读取无法兼顾，例如矩阵转置。此时应当优先保证写入是合并的。</p>
<p>这是因为从帕斯卡架构开始，若编译器判定一个全局内存变量在整个核函数的范围内都<strong>只读</strong>，则会自动用函数<code>__ldg()</code>读取全局内存，附带缓存效果，缓解非合并访问的影响。但对于全局内存的写入，没有类似的优化手段。</p>
<h2 id="共享内存的合理使用"><a href="#共享内存的合理使用" class="headerlink" title="共享内存的合理使用"></a>共享内存的合理使用</h2><p>在核函数内，使用<code>__shared__</code>修饰的变量（数组）将使用共享内存。同一线程块使用同一个共享内存副本，而不同线程块的共享内存是互相独立的，不可见的。</p>
<p>利用共享内存，可以消除一些无法兼顾读写合并的全局内存访问，例如数组归约，先将要读取的数据从全局内存拷贝至共享内存（然后<code>__syncthreads()</code>同步一下），可以带来细微的性能提升。</p>
<p>对共享内存的访问越频繁，性能提升越明显。</p>
<h3 id="动态共享内存"><a href="#动态共享内存" class="headerlink" title="动态共享内存"></a>动态共享内存</h3><p>共享内存大小可以在核函数的执行配置中指定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;grid_size, block_size, <span class="built_in">sizeof</span>(real) * block_size&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>同时要修改共享内存变量的声明方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">__shared__ real a[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">extern</span> __shared__ real a[];</span><br></pre></td></tr></table></figure>

<p>动态和静态的声明方式在性能上几乎没有差别。</p>
<h3 id="避免共享内存的bank冲突"><a href="#避免共享内存的bank冲突" class="headerlink" title="避免共享内存的bank冲突"></a>避免共享内存的bank冲突</h3><p>共享内存在物理上被分为 32 个（恰好是线程束大小）个 bank，多个线程同时访问同一个 bank 会导致冲突；多个线程同时访问不同的 bank 能取得更高的性能。</p>
<p>除了开普勒架构（8 字节）外，每 4 个字节被划分到一个 bank。例如 <code>0000</code> 属于 bank0，<code>0004</code> 属于 bank1 …… <code>0128</code> 属于 bank0。可以看出，每个 bank 的相邻层的地址相差 128。</p>
<p>一个线程束试图同时访问同一个 bank 中的 n 层数据将导致 n 次 内存事务(memory transaction)。亦称为 n 路 bank 冲突。n 很大的 bank 冲突是要尽量避免的。</p>
<p>在矩阵转置中，写入共享内存时易产生 bank 冲突，可以通过修改数组大小解决。</p>
<p>记得双精度浮点数占 8 字节。</p>
<h2 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h2><p>例如在数组归约（加法）中，要令GPU完成求和，需要使用原子操作。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>原子函数在全局内存和共享内存上体现原子性。</p>
<p>原子函数不依赖内存栅栏，不需要线程同步或顺序约束（参考<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomic-functions">官方文档</a>）。</p>
<p>原子函数只能用于设备函数。</p>
<h3 id="原子性粒度"><a href="#原子性粒度" class="headerlink" title="原子性粒度"></a>原子性粒度</h3><p>系统原子性：在任意 CPU 和 GPU 的任意线程上保持原子性。函数名有后缀<code>_system</code>，如<code>atomicAdd_system</code>。</p>
<p>设备原子性：在当前 GPU 的任意线程上保持原子性。函数名无附加后缀。</p>
<p>线程块原子性：在当前 GPU 的同一线程块中的任意线程上保持原子性。函数名有后缀<code>_block</code>，如<code>atomicAdd_block</code>。</p>
<h3 id="原子函数速查"><a href="#原子函数速查" class="headerlink" title="原子函数速查"></a>原子函数速查</h3><p><strong>注意：所有的函数都返回旧值</strong></p>
<p>支持的类型可参考书第 92 页。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T in &#123;int, unsigned int, unsigned long long int&#125;</span></span><br><span class="line"><span class="keyword">using</span> UI = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">T <span class="title">atomicAdd</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 加法，支持浮点</span></span><br><span class="line"><span class="function">T <span class="title">atomicSub</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 减法，支持浮点</span></span><br><span class="line"><span class="function">T <span class="title">atomicExch</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// new = val，支持float</span></span><br><span class="line"><span class="function">T <span class="title">atomicMin</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 最小值</span></span><br><span class="line"><span class="function">T <span class="title">atomicMax</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 最大值</span></span><br><span class="line"><span class="function">UI <span class="title">atomicInc</span><span class="params">(UI *address, UI val)</span></span>; <span class="comment">// new = (old &gt;= val) ? 0 : (old+1)</span></span><br><span class="line"><span class="function">UI <span class="title">atomicDec</span><span class="params">(UI *address, UI val)</span></span>; <span class="comment">// new = ((old == 0) || (old &gt; val)) ? val : (old-1)</span></span><br><span class="line"><span class="function">T <span class="title">atomicAnd</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位与</span></span><br><span class="line"><span class="function">T <span class="title">atomicOr</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位或</span></span><br><span class="line"><span class="function">T <span class="title">atomicXor</span><span class="params">(T *address, T val)</span></span>; <span class="comment">// 按位异或</span></span><br><span class="line"><span class="function">T <span class="title">atomicCAS</span><span class="params">(T *address, T compare, T val)</span></span>; <span class="comment">// new = old == compare ? val : old。支持unsigned short int</span></span><br></pre></td></tr></table></figure>

<h2 id="线程束与协作组"><a href="#线程束与协作组" class="headerlink" title="线程束与协作组"></a>线程束与协作组</h2><h3 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h3><p>单指令-多线程（single instruction multiple thread, SIMT）：不同线程共享同一个 PC。SIMT 的通病是分支发散（branch divergence），所有的分支会产生串行的时间开销。</p>
<p>在伏特架构之前，一个线程束共享一个 PC。不同线程束之间没有分支发散问题。</p>
<p>从伏特架构开始，引入了独立线程调度（independent thread scheduling）机制。每个线程有自己的 PC，使得需要用户自己控制线程束内的同步。另一个代价是每个线程需要用两个寄存器来做 PC。如果旧代码出现线程束内不安全的问题，可以指定虚拟架构为低于伏特架构的计算能力。</p>
<h3 id="线程束内的线程同步"><a href="#线程束内的线程同步" class="headerlink" title="线程束内的线程同步"></a>线程束内的线程同步</h3><p><code>__syncwarp()</code>比线程块同步函数<code>__syncthreads()</code>更加廉价。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">void</span> __syncwarp(<span class="type">unsigned</span> mask = <span class="number">0xffffffff</span>);</span><br></pre></td></tr></table></figure>

<p>其中掩码表示参与同步的线程，默认 32 个线程全部参与。</p>
<p>在分治时，当问题规模缩小到一个线程束内，可以不使用<code>__syncthreads</code>而用<code>__syncwarp</code>。</p>
<h3 id="更多线程束内的基本函数"><a href="#更多线程束内的基本函数" class="headerlink" title="更多线程束内的基本函数"></a>更多线程束内的基本函数</h3><p><strong>注意：若当前线程不参与，则函数的返回值是无定义的。</strong></p>
<p>线程束表决函数（warp vote functions）</p>
<p>线程束匹配函数（warp match functions）<em>待续</em></p>
<p>线程束洗牌函数（warp shuffle functions）</p>
<p>线程束矩阵函数（warp matrix functions）<em>待续</em></p>
<h4 id="线程束表决"><a href="#线程束表决" class="headerlink" title="线程束表决"></a>线程束表决</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __ballot_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步表决下一次参与意愿（当 predicate 非零，则令返回值对应位置 1， 否则置 0。）。相当于从旧掩码表决出一个新掩码。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __all_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步投票，一票否决，返回投票是否通过。所有参与线程都同意才通过。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __any_sync(<span class="type">unsigned</span> mask, <span class="type">int</span> predicate);</span><br><span class="line"><span class="comment">// 若当前线程参与，则同步投票，一票通过，返回投票是否通过。</span></span><br></pre></td></tr></table></figure>

<h4 id="线程束洗牌"><a href="#线程束洗牌" class="headerlink" title="线程束洗牌"></a>线程束洗牌</h4><p>定义“束内指标” <code>int lane_id = threadIdx.x % w</code>。</p>
<p><code>w</code> 是逻辑线程束大小，只能取 2、4、8、16、32 中的一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T __shfl_sync(<span class="type">unsigned</span> mask, T v, <span class="type">int</span> srcLane, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 参与线程返回标号为 srcLane 的变量 v 的值。这是一种广播式数据交换。 </span></span><br><span class="line"></span><br><span class="line">T __shfl_up_sync(<span class="type">unsigned</span> mask, T v, <span class="type">unsigned</span> d, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t - d 的线程中的 v 的值；若 t - d &lt; 0 则返回原来的 v。相当于数据向上平移。</span></span><br><span class="line"></span><br><span class="line">T __shfl_down_sync(<span class="type">unsigned</span> mask, T v, <span class="type">unsigned</span> d, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t + d 的线程中的 v 的值；若 t + d &gt;= w 则返回原来的 v。相当于数据向下平移。</span></span><br><span class="line"></span><br><span class="line">T __shfl_xor_sync(<span class="type">unsigned</span> mask, T v, <span class="type">int</span> laneMask, <span class="type">int</span> w=warpSize);</span><br><span class="line"><span class="comment">// 标号为 t 的参与线程返回标号为 t ^ laneMask 的线程中的 v 的值；相当于对应的两个线程交换数据。</span></span><br></pre></td></tr></table></figure>

<p>使用线程束洗牌优化数组归约：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> FULL_MASK = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">reduce_shfl</span><span class="params">(<span class="type">const</span> real *d_x, real *d_y, <span class="type">const</span> <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = bid * blockDim.x + tid;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ real s_y[];</span><br><span class="line">    s_y[tid] = (n &lt; N ? d_x[n] : <span class="number">0.0</span>);</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = blockDim.x &gt;&gt; <span class="number">1</span>; offset &gt;= <span class="number">32</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; offset) &#123;</span><br><span class="line">            s_y[tid] += s_y[tid + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real y = s_y[tid]; <span class="comment">// 寄存器优化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">16</span>; offset &gt; <span class="number">0</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        y +=  __shfl_down_sync(FULL_MASK, y, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">atomicAdd</span>(d_y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="协作组"><a href="#协作组" class="headerlink" title="协作组"></a>协作组</h3><p>协作组（cooperative groups）可以看作线程块和线程束同步机制的推广。范围涵盖线程块内部，线程块之间（网格级）及设备之间的同步与协作。</p>
<p>引入头文件和命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> cg = cooperative_groups; <span class="comment">// 仅供参考</span></span><br></pre></td></tr></table></figure>

<h4 id="线程块级别的协作组"><a href="#线程块级别的协作组" class="headerlink" title="线程块级别的协作组"></a>线程块级别的协作组</h4><p>基本类型<code>thread_group</code>。有如下成员：</p>
<ol>
<li><code>void sync()</code> 同步组内所有线程</li>
<li><code>unsigned size()</code> 返回组内总的线程数目</li>
<li><code>unsigned thread_rank()</code> 返回当前线程的组内标号</li>
<li><code>bool is_valid()</code> 检查定义的组是否违反 CUDA 的任何限制</li>
</ol>
<p>导出类型<code>thread_block</code>，额外函数：</p>
<ol>
<li><code>dim3 group_index()</code> 返回当前线程的线程块指标，相当于 blockIdx</li>
<li><code>dim3 thread_index()</code> 相当于 threadIdx</li>
</ol>
<p>于是可以抽象出当前线程块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">thread_block g = <span class="built_in">this_thread_block</span>();</span><br><span class="line">g.<span class="built_in">sync</span>(); <span class="comment">// 等价于 __syncthreads()</span></span><br></pre></td></tr></table></figure>

<p>可以将 <code>thread_block</code> 进行多次分割（但一组线程的数量只能是 2 的幂次）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">thread_group g32 = <span class="built_in">tiled_partition</span>(<span class="built_in">this_thread_block</span>(), <span class="number">32</span>); <span class="comment">// 相当于线程束</span></span><br><span class="line">thread_group g4 = <span class="built_in">tiled_partition</span>(g32, <span class="number">4</span>); <span class="comment">// 再次分割</span></span><br><span class="line"><span class="comment">// ---------- 模板化版本 ----------</span></span><br><span class="line">thread_block_tile&lt;<span class="number">32</span>&gt; g32 = <span class="built_in">tiled_partition</span>&lt;<span class="number">32</span>&gt;(<span class="built_in">this_thread_block</span>());</span><br></pre></td></tr></table></figure>

<p>这样的“线程块片”可以模仿线程束的一些行为，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __ballot_sync(<span class="type">int</span> predicate);</span><br><span class="line"><span class="type">int</span> __all_sync(<span class="type">int</span> predicate);</span><br><span class="line"><span class="type">int</span> __any_sync(<span class="type">int</span> predicate);</span><br><span class="line">T __shfl_sync(T v, <span class="type">int</span> srcLane);</span><br><span class="line">T __shfl_up_sync(T v, <span class="type">unsigned</span> d);</span><br><span class="line">T __shfl_down_sync(T v, <span class="type">unsigned</span> d);</span><br><span class="line">T __shfl_xor_sync(T v, <span class="type">int</span> laneMask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对线程束的不同点：1. 不允许掩码，所有线程必须参与 2. 洗牌函数不再需要宽度参数，宽度由线程块片大小确定</span></span><br></pre></td></tr></table></figure>

<h3 id="再次优化数组归约"><a href="#再次优化数组归约" class="headerlink" title="再次优化数组归约"></a>再次优化数组归约</h3><p>这次我们采用的技巧有：</p>
<ol>
<li>使用静态全局内存</li>
<li>调用两次核函数，舍弃原子加法函数（这会提高精确度）</li>
<li>提高线程利用率（在规约之前进行小部分求和）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;real.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;widgets.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> FULL_MASK = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">reduce_cp</span><span class="params">(<span class="type">const</span> real *d_x, real *d_y, <span class="type">const</span> <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ real s_y[];</span><br><span class="line"></span><br><span class="line">    real y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> stride = blockDim.x * gridDim.x; <span class="comment">// 以网格大小为跨度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = bid * blockDim.x + tid; n &lt; N; n += stride) &#123;</span><br><span class="line">        y += d_x[n]; <span class="comment">// 确保一个网格能覆盖所有数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    s_y[tid] = y;</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程块内，跨线程束折半归约</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = blockDim.x &gt;&gt; <span class="number">1</span>; offset &gt;= <span class="number">32</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; offset) &#123;</span><br><span class="line">            s_y[tid] += s_y[tid + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y = s_y[tid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">16</span>; offset &gt; <span class="number">0</span>; offset &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        y += __shfl_down_sync(FULL_MASK, y, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) &#123;</span><br><span class="line">        d_y[bid] = y; <span class="comment">// 返回线程块结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> GRID_SIZE = <span class="number">10240</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> BLOCK_SIZE = <span class="number">128</span>;</span><br><span class="line">__device__ real d_input[N];</span><br><span class="line">__device__ real d_output[GRID_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function">real <span class="title">reduce</span><span class="params">(<span class="type">const</span> real *d_x)</span> </span>&#123;</span><br><span class="line">    real *d_y;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaGetSymbolAddress</span>((<span class="type">void</span>**)&amp;d_y, d_output));</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> shared_size = <span class="built_in">sizeof</span>(real) * BLOCK_SIZE;</span><br><span class="line">    reduce_cp&lt;&lt;&lt;GRID_SIZE, BLOCK_SIZE, shared_size&gt;&gt;&gt;(d_x, d_y, N);</span><br><span class="line">    reduce_cp&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1024</span>, <span class="built_in">sizeof</span>(real) * <span class="number">1024</span>&gt;&gt;&gt;(d_y, d_y, GRID_SIZE);</span><br><span class="line"></span><br><span class="line">    real h_y[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpy</span>(h_y, d_y, <span class="built_in">sizeof</span>(real), cudaMemcpyDeviceToHost));</span><br><span class="line">    <span class="comment">// CHECK(cudaMemcpyFromSymbol(h_y, d_output, sizeof(real)));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h_y[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">static</span> real input[N];</span><br><span class="line">    std::<span class="built_in">fill_n</span>(input, N, <span class="number">1.23f</span>);</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaMemcpyToSymbol</span>(d_input, input, N * <span class="built_in">sizeof</span>(real)));</span><br><span class="line">    real *d_x;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaGetSymbolAddress</span>((<span class="type">void</span>**)&amp;d_x, d_input));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="built_in">reduce</span>(d_x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 123000064.000000</span></span><br><span class="line"><span class="comment">// 对比 CPU 裸归约方法的加速比：67</span></span><br></pre></td></tr></table></figure>

<h2 id="CUDA-流"><a href="#CUDA-流" class="headerlink" title="CUDA 流"></a>CUDA 流</h2><h3 id="核函数外部的并行"><a href="#核函数外部的并行" class="headerlink" title="核函数外部的并行"></a>核函数外部的并行</h3><p>主要有以下情形：</p>
<ol>
<li>核函数计算与数据传输之间的并行</li>
<li>主机计算与数据传输之间的并行</li>
<li>不同的数据传输之间的并行</li>
<li>核函数计算与主机计算之间的并行</li>
<li>不同核函数之间的并行</li>
</ol>
<p>若两个任务的运行时间相近，则尽量令他们并行。反之，则并行和串行的性能差距不大。</p>
<p>使用 CUDA 流的主要目的是尽量取得核函数外部的并行能力。</p>
<h3 id="使用-CUDA-流"><a href="#使用-CUDA-流" class="headerlink" title="使用 CUDA 流"></a>使用 CUDA 流</h3><p>CUDA 流的使用相对简单，只要记住一些规则就好。</p>
<ol>
<li><p>CUDA 程序有一个默认流。若 API 不需要指定流句柄，可推测它用于默认流。</p>
</li>
<li><p>创建、销毁 CUDA 流</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaStream_t stream[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : stream) &#123;</span><br><span class="line">    <span class="built_in">cudaStreamCreate</span>(&amp;s); <span class="comment">// 创建流，获得句柄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : stream) &#123;</span><br><span class="line">    <span class="built_in">cudaStreamDestroy</span>(s); <span class="comment">// 销毁流，句柄不抹除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测 CUDA 流是否空闲 </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaStreamSynchronize</span><span class="params">(cudaStream_t stream)</span></span>; <span class="comment">// 阻塞主机，直到 CUDA 流完成所有操作</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaStreamQuery</span><span class="params">(cudaStream_t stream)</span></span>; <span class="comment">// 返回 cudaSuccess（已完成）/ cudaErrorNotReady（未完成）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cudaMemcpy</code> 会阻塞主机。但是核函数的调用总是异步的。应该尽量早地调用核函数，随后再进行主机的计算任务。</p>
</li>
<li><p>在核函数配置中指派 CUDA 流：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">my_kernel&lt;&lt;&lt;N_grid, N_block, N_shared, stream_id&gt;&gt;&gt;(...); <span class="comment">// 四个模板参数必须齐全</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步的数据传输需要：</p>
<ol>
<li>使用 <code>cudaMemcpyAsync</code> 函数。</li>
<li>涉及的主机内存必须是不可分页的，否则 API 将会退化为同步版本。</li>
</ol>
<p> 异步传输的过程将由 GPU 的 DMA（direct memory access）接管。</p>
</li>
<li><p>可以用 CUDA 运行时 API 来申请不可分页的内存（non-pageable memory），又称固定内存（pinned memory）。不可分页意味着操作系统无权修改虚拟地址所对应的物理地址。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocHost</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaHostAlloc</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> flags)</span></span>;</span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaFreeHost</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>良好的 CUDA 流指派会从流水线重叠中获得并行加速。但是 CUDA 流是有启动开销，且硬件环境有限，过多的 CUDA 流会拉低性能。</p>
</li>
</ol>
<h2 id="指令速查"><a href="#指令速查" class="headerlink" title="指令速查"></a>指令速查</h2><h3 id="编译器选项"><a href="#编译器选项" class="headerlink" title="编译器选项"></a>编译器选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--ptxas-options=-v <span class="comment"># 报道每个核函数的寄存器使用数量</span></span><br><span class="line">--maxrregcount= <span class="comment"># 限制所有核函数的寄存器使用量</span></span><br></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__global__ <span class="comment"># 核函数修饰符</span></span><br><span class="line">__device__ <span class="comment"># 设备函数、变量修饰符</span></span><br><span class="line">__host__ <span class="comment"># 主机函数修饰符，一般只与__device__同时出现</span></span><br><span class="line">__noinline__ <span class="comment"># 建议函数非内联</span></span><br><span class="line">__forceinline__ <span class="comment"># 建议函数内联</span></span><br><span class="line">__launch_bounds__() <span class="comment"># 修饰核函数，限制寄存器使用量</span></span><br><span class="line">__shared__ <span class="comment"># 修饰全局变量，使它成为共享内存</span></span><br><span class="line">__managed__ <span class="comment"># 修饰全局变量，使它成为统一内存，必须与__device__同时出现</span></span><br></pre></td></tr></table></figure>

<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="CMake模板"><a href="#CMake模板" class="headerlink" title="CMake模板"></a>CMake模板</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2021/08/02</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello LANGUAGES CUDA VERSION <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(USE_DOUBLE <span class="string">&quot;Use real as double, otherwise float&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(CUDAToolkit REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set(CMAKE_CUDA_COMPILER_ID NVIDIA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set(ENV&#123;PATH&#125; &quot;C:/Program\ Files\ (x86)/Microsoft\ Visual\ Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64:$ENV&#123;PATH&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># report registers used in each core function</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(--ptxas-options=-v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(./<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute capability, see https://developer.nvidia.com/zh-cn/cuda-gpus#compute</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> hello PROPERTY CUDA_ARCHITECTURES <span class="number">86</span>)</span><br><span class="line"><span class="comment"># set_property(TARGET hello PROPERTY CUDA_ARCHITECTURES 75)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install(TARGETS hello DESTINATION .)</span></span><br></pre></td></tr></table></figure>

<h3 id="报错、计时工具"><a href="#报错、计时工具" class="headerlink" title="报错、计时工具"></a>报错、计时工具</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// widgets.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(callee)                                            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                         \</span></span><br><span class="line"><span class="meta">        const cudaError_t err = callee;                          \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (err == cudaSuccess) break;                           \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;CUDA error at %s(%d)\n&quot;</span>, __FILE__, __LINE__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Function:   %s\n&quot;</span>, __FUNCTION__);            \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Error code: %d\n&quot;</span>, err);                     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;    Error hint: %s\n&quot;</span>, cudaGetErrorString(err)); \</span></span><br><span class="line"><span class="meta">        exit(1);                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cudaTiming</span><span class="params">(<span class="type">const</span> F &amp;func)</span> </span>&#123;</span><br><span class="line">    cudaEvent_t start, stop;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventCreate</span>(&amp;start));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventCreate</span>(&amp;stop));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventRecord</span>(start));</span><br><span class="line">    <span class="built_in">cudaEventQuery</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventRecord</span>(stop));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventSynchronize</span>(stop));</span><br><span class="line">    <span class="type">float</span> elapsed_time;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventElapsedTime</span>(&amp;elapsed_time, start, stop));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CUDA Time = %g ms.\n&quot;</span>, elapsed_time);</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventDestroy</span>(start));</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="built_in">cudaEventDestroy</span>(stop));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hostTiming</span><span class="params">(<span class="type">const</span> F &amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt; duration = end - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host Time = %g ms.\n&quot;</span>, duration.<span class="built_in">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="精度控制模板"><a href="#精度控制模板" class="headerlink" title="精度控制模板"></a>精度控制模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// real.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_DOUBLE</span></span><br><span class="line"><span class="keyword">using</span> real = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">constexpr</span> real EPS = <span class="number">1e-15</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> real = <span class="type">float</span>;</span><br><span class="line"><span class="keyword">constexpr</span> real EPS = <span class="number">1e-6</span>f;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>GPGPU</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法笔记</title>
    <url>/2019/10/11/java/</url>
    <content><![CDATA[<p>Since 2018&#x2F;07&#x2F;12</p>
<span id="more"></span>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>与C++不同,Java在新建变量时,不允许其名称与其上一级作用域的变量名相同.</li>
<li>若某一时刻某一作用域中,某个名字的变量被销毁,则该名字可以再次使用.</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>整数默认为int, 小数默认为double(8字节), 字面值不能大于类型最大值.</li>
<li>数字可以加后缀指定类型, long为<code>L</code>, double为<code>d</code>, float为<code>f</code>.</li>
<li>缩窄转换会报错,除非强制类型转换(前置括号). 类型提升不会报错(如int-&gt;double)</li>
<li>short是16位有符号类型, char是16位<strong>无符号</strong>类型.</li>
<li>非基础的数据类型只有引用数据类型,像阉割的指针,使用点号时自动解引用.</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><code>int[] array = new int[n];       //    array.length 为数组长度, 越界会报错</code></li>
<li><code>int[] array = new int[] &#123;2, 0, 4, 1&#125;;  //array长度为4, 仅分配内存可初始化</code></li>
<li><code>T[][] array = &#123; &#123;new T(), new T()&#125;,  &#123;new T()&#125; &#125;  //低维长度不定</code></li>
<li><code>int[][] array = new int[n1][];   array[1] = new int[n2]; //低维长度不定</code></li>
<li>凡是new生成的东西都在堆内存中, 只有array作为一个引用存在于栈内存中</li>
<li>与C++不同, 已有数组名(引用)可以赋值给另一个已有数组名(引用), 允许变动.</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(value) &#123;  <span class="comment">//value范围在int内,且不为boolean</span></span><br><span class="line"><span class="keyword">case</span> value1:</span><br><span class="line">    <span class="keyword">do</span> sth;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:        <span class="comment">//default可以放在前面,程序保证入口挑选正确且唯一.</span></span><br><span class="line">    <span class="keyword">do</span> sth;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><ul>
<li>类中用<code>&#123;&#125;</code>包裹的代码块，将在每次构造函数调用时执行</li>
<li>构造对象触发的动作：初始化（静态代码块）-&gt;super()-&gt;构造代码块-&gt;构造函数剩余部分</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>构造函数的第一行可以用<code>this(...)</code>调用其它构造函数. 编译器会检测递归构造器调用并报错</li>
<li>编译器保证若有父类,构造方法一定会调用父类构造方法,故<code>this(...)</code>意味着会调用<code>super(....)</code></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>只允许一个父类<code>class Son extends Father &#123;...&#125;</code></li>
<li>当前对象的父类指针为<code>ThisClass.super</code> <strong>?</strong>,</li>
<li>子类的构造函数的第一行都有隐式的<code>super()</code>调用,可以替换为各种显式调用</li>
<li><strong>重写</strong> <em>针对成员方法</em><ul>
<li>继承中当函数名, 参数列表(即特征标)相同时发生重写</li>
<li>访问限制级别必须相同或放宽</li>
<li>若父类函数返回类型为基础类型,则子类重写返回类型必须相同</li>
<li>若父类返回引用类型, 则子类返回相同或其子类类型</li>
<li>重写方法不能抛出新异常, 只可以抛出相同&#x2F;更少异常</li>
<li>抽象方法必须在具体类中被重写</li>
<li>父类引用指向子类对象时,会动态绑定子类重写函数</li>
</ul>
</li>
<li><strong>隐藏</strong> <em>针对所有成员变量和静态成员方法</em><ul>
<li>成员变量类型可以改变</li>
<li>父类引用指向子类对象时,静态绑定父类被隐藏成员.(由对象调用的静态方法将被翻译为由类调用的静态方法。因此是隐藏而不是重写)</li>
<li>为什么是隐藏？因为子类的构造函数总会调用父类的构造函数。若一个变量被两次修改，可能产生隐患。</li>
</ul>
</li>
<li><strong>向上转型</strong><ul>
<li>成员方法<ol>
<li><pre><code>编译时**检查声明类型类**中是否含有被调用的成员方法,而不检查子类对象
</code></pre>
<ol start="2">
<li><pre><code>运行时**根据对象**调用最后重写的成员方法,而不依赖与声明类型类
</code></pre>
<ol start="3">
<li><pre><code>被重写的方法没有丢失,但仅能通过类方法中super访问.
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>成员变量<ol>
<li><pre><code>编译时**检查声明类型类**中是否含有被访问的成员变量, 而不检查子类对象
</code></pre>
<ol start="2">
<li><pre><code>运行时**访问声明类型类**中的成员变量, 而不访问子类对象所重写的
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><code>instanceof</code><ul>
<li>判断一个对象是否为某个类的实例或是否实现了某个接口.</li>
<li>若判断是否类的实例, 则编译器要求引用类型和类有关联(至少有父子关系)</li>
<li>常用于强制类型转换前.</li>
</ul>
</li>
</ul>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><ul>
<li>静态代码块在程序生命周期中最多执行一次</li>
<li>执行静态代码块的行为叫做<strong>初始化</strong></li>
<li>能触发初始化的动作是<strong>主动引用</strong><ol>
<li>创建类的实例</li>
<li>访问类的静态变量(常量除外, 因为常量在代码中被直接替换, 不会新开内存)</li>
<li>访问类的静态方法</li>
<li>反射</li>
<li>当子类被初始化时, 父类还没初始化, 那么先执行父类初始化</li>
<li>虚拟机启动时, 先初始化含main()定义的类</li>
<li>接口(禁止了static代码块)不要求父类初始化,直到真正引用父接口</li>
</ol>
</li>
<li>不会触发初始化的动作是<strong>被动引用</strong><ol>
<li>子类调用父类静态变量或父类静态方法, 只初始化父类</li>
<li>访问类的常量</li>
<li>声明对象数组(因为声明的是数组头引用和引用数组, 实际不含任何访问)</li>
<li>访问静态内部类的任何组份</li>
</ol>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>final修饰变量: 声明常量, 其内容不可修改<ul>
<li>对于基本数据类型, 其值不可修改</li>
<li>对于引用数据类型, 指向不能更换, 但所指向的内容仍可修改</li>
<li>常量和普通变量一样可以重写&#x2F;隐藏.</li>
<li>每个对象都包含各自的final变量, 在构造其中初始化</li>
</ul>
</li>
<li>final修饰类: 定义不可被继承类<ul>
<li>一般出于安全性原因才会考虑final修饰类</li>
<li>因为不可被继承, 所以类不可能为abstract, 方法不含abstract</li>
</ul>
</li>
<li>final修饰方法: 定义不可被重写方法</li>
</ul>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><ul>
<li>abstract修饰类: 指明类是抽象类, 不能实例化. 含抽象方法的类必须用abstract修饰.<ul>
<li>抽象类不可能含final方法, 但无其他限制, 可像普通类一样编写.</li>
</ul>
</li>
<li>abstract修饰方法: 指明方法是抽象方法, 原型后加分号, 而不能写方法体.</li>
</ul>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul>
<li>对应关键字 <code>implements</code> 实现</li>
<li>接口是对行为的抽象, 方便描述类的共同行为.</li>
<li>接口的变量默认且仅限于<code>public static final</code>(意味着在接口外能访问)</li>
<li>接口的方法默认且仅限于<code>public abstract</code></li>
<li>新接口可以继承(extends)多个旧接口.</li>
<li>类实现(implements)接口后必须重写接口方法, 否则必须定义为abstract类.</li>
<li>类可以实现多个方法, 即使这些方法有同名常量或同一函数.<ul>
<li>若实现多个方法后有同名常量, 则尝试访问它们时会产生编译时二义性错误.</li>
</ul>
</li>
<li>接口作为一种数据类型, 可以引用, 可以向上转型以实现多态.</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul>
<li>访问不同包中的类需要加上<code>包名.</code>, 或者使用import <code>包名.类名</code>或<code>包名.*</code></li>
<li>包是开放的(可以跨单元). 一个包可拥有多个public类, 但一个单元最多拥有一个public类, 且必须与单元名相同(大小写敏感).</li>
<li>同一包中的类可以互相访问非private成员.</li>
<li>继承另一个包的类后, 继承所得成员所属包不变.</li>
</ul>
<h2 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h2><ul>
<li>类中数据权限修饰符<ol>
<li><code>private</code> : 数据能在本类中访问.</li>
<li><code>(空, 即默认修饰符)</code> : 数据能在同包中访问.</li>
<li><code>protected</code> : 当类为public时有意义, 数据能在包外继承类中访问.</li>
<li><code>public</code> : 当类为public时有意义, 数据能在包外访问.</li>
</ol>
<ul>
<li>同类对象可以互相访问本类的private成员.</li>
<li>重写方法时, 权限不能降低, 否则会影响多态.</li>
</ul>
</li>
<li>类权限修饰符<ol>
<li><code>(空, 即默认修饰符)</code> : 本类能在同包中访问.</li>
<li><code>public</code> : 本类能在包外访问. 一个单元最多拥有一个public类, 且必须与单元名相同(大小写敏感).</li>
</ol>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>成员内部类<ul>
<li>在类中以成员形式定义的另一个类, 称为成员内部类.</li>
<li>内部类是外部类的成员, 依赖于外部对象的存在,因此不能含有静态方法或静态变量(常量除外).</li>
<li>其他类中声明示例  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">p2</span> <span class="operator">=</span> p1.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure></li>
<li>因为是成员之一, 可以访问任何外部类成员, 存在引用<code>OuterClass.this</code></li>
</ul>
</li>
<li>静态内部类<ul>
<li>在类中以静态成员形式定义的另一个类, 称为静态内部类.</li>
<li>静态内部类的外部类一定全是静态的.&#x3D;&#x3D;?_?&#x3D;&#x3D;</li>
<li>静态内部类可以访问外部类的静态成员.</li>
<li>静态内部类可以定义静态成员变量,静态成员方法和静态内部类.</li>
<li>初始化某个静态内部类不会触发外部类的初始化.</li>
</ul>
</li>
<li>局部类<ul>
<li>定义在方法中的, 有类名的类, 称为局部类.</li>
<li>局部类依赖于方法的运行, 因此本身不是静态的, 不能含有静态成员(常量除外). </li>
<li>局部类可以访问方法中的局部变量(jr8之前只能访问final).</li>
<li>若方法是成员方法, 则能访问外部类的所有成员, 存在引用<code>OuterClass.this</code></li>
<li>若方法是静态方法, 则只能访问外部类的静态成员.</li>
</ul>
</li>
<li>匿名类<ul>
<li>匿名类是没有类名的子类, 使用格式: <code>new FatherClassOrInterface() &#123;...&#125; ;</code></li>
<li>匿名类通常意味着向上转型, 并即时生成一个实例, 因此本身不是静态的.</li>
<li>匿名类可以出现在成员变量中&#x2F;方法中.</li>
<li>匿名类不能定义新的构造方法&#x2F;实现新的接口&#x2F;派生出子类.</li>
<li>匿名类若出现在成员变量中, 则类似于成员内部类; 若出现在方法中, 则类似于局部类.</li>
</ul>
</li>
</ul>
<h2 id="回调（思想）"><a href="#回调（思想）" class="headerlink" title="回调（思想）"></a>回调（思想）</h2><ul>
<li>某个对象A引发另一对象B的行为，同时使B持有A的引用。B在行为过程中再引发A的行为，此谓回调。</li>
<li>A的引用，可能是直接引用，也可能是接口引用等</li>
<li>令B持有A的引用，可能通过方法参数传递，也可能通过set成员变量引用</li>
<li>在多线程中，回调尤为常用</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>Throwable的直接子类有Error（JVM错误用），Exception（异常类）。Exception的直接子类有RuntimeException（算术异常，丢失资源，找不到类，空指针，非法参数，数组越界，未知异常），IOException（EOF异常，找不到文件）</li>
<li>运行时异常无需手动管理，所有过程隐式进行。IOException需要显式处理。</li>
<li>当程序发生异常时，需要手写<code>throw new XXException(..)</code>，则方法会抛出一个异常。在异常被抛出的地方，必须被处理。</li>
<li>处理异常：<ul>
<li>用<code>try&#123;&#125;</code>包括可能会抛出异常的代码块，后接<code>catch (XXExcepetion e)&#123;&#125; catch (BiggerException e)&#123;&#125;... finally&#123;&#125;</code>代码块。或在方法声明中注明<code>throws XXException</code>(则调用此方法的方法必须处理此异常)</li>
<li>若<code>try&#123;&#125;</code>代码块中确实抛出异常，则程序跳至catch代码块，并用e接收异常实例以供分析。</li>
<li>无论在<code>try&#123;&#125;</code>,<code>catch()&#123;&#125;</code>中有无遇到异常，程序必定执行<code>finally&#123;&#125;</code>，一般在其中回收资源。在<code>finally&#123;&#125;</code>中引发的异常会中止余下代码的执行。</li>
<li>需要同一时间分别处理多个异常时（比如关闭多个流），常用try嵌套。注意在finally中判断引用是否为空。</li>
</ul>
</li>
</ul>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li>抽象父类：InputStream，OutputStream（抽象方法是read(), write()）</li>
<li>文件字节流：FileInputStream，FileOutputStream<ul>
<li>构造方法（常用的）有(String name)， (File file), OutputStream还有(File file, boolean append), 若append，则文件写入在末尾</li>
<li><code>int read()</code> 用int返回下一字节byte（无输入则返回-1）,对文件单个字节操作.</li>
<li><code>int read(byte b[])</code> 将最多b.length的字节读入到b[]，返回实际读入的字节数。只遇到EOF则返回-1</li>
<li><code>int read(byte b[], int off, int len)</code> 将最多len的字节读入到b[off]或以后，返回实际读入的字节数。只遇到EOF则返回-1</li>
<li><code>void write(int b)</code> 写一个字节b（抛弃高位）</li>
<li><code>void write(byte b[], int off, int len)</code> 从<code>b[off]</code>开始写出len个字节</li>
<li><code>void write(byte b[])</code> 写出b.length个字节</li>
<li></li>
</ul>
</li>
<li><code>BufferedInputStream(InputStream)</code> 利用内置的缓冲数组加速读取</li>
<li><code>BufferedOutputStream(OutputStream)</code> 加速写出</li>
</ul>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li>抽象父类：Reader, Writer</li>
<li>文件字符流：FileReader, FileWriter(使用默认字符集)</li>
<li>若要指定字符编码和字节缓冲区大小，应该构造InputStreamReader(FileInputStream in, String charsetName);</li>
<li><code>BufferedReader(Reader in)</code>, <code>(Readerin int sz)</code> 加速读入</li>
<li><code>BufferedWriter(Writer out)</code>, <code>(Writer out, int sz)</code> 加速写出</li>
<li><code>PrintWriter(File file)</code> <code>(String fileName)</code>, <code>(OutputStream out)</code>, <code>(Writer out)</code>有格式的输出流</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul>
<li>可以定义泛型类<code>class&lt;T&gt; &#123;&#125;</code></li>
<li>不能调用泛型参数的构造方法</li>
<li>可以指定泛型类上界，以使用其成员<code>class&lt;T extends K&gt;</code>，编译器静态地禁止代码越过上界。泛型类在各处代码都能记住其上界。</li>
<li>声明一个泛型类对象时，省略尖括号表示<code>&lt;Object&gt;</code></li>
<li>在同一条声明语句中，后面的尖括号可以留空表示同上<code>&lt;&gt;</code></li>
<li>类型参数是运行时构造对象才能确定的，因此静态方法不能使用类型参数</li>
<li>泛型类是非协变的，<code>A&lt;Person&gt;</code>与<code>A&lt;Student&gt;</code>没有关联</li>
<li>禁止声明类型为泛型类的数组(可以用arrayList代替)</li>
</ul>
<h3 id="将泛型类用作参数"><a href="#将泛型类用作参数" class="headerlink" title="将泛型类用作参数"></a>将泛型类用作参数</h3><ul>
<li>使用通配符<code>&lt;?&gt;</code>, 此时可以指定泛型参数的下界（super）或更严格的上界（无视变得宽松的上界）</li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li>可以定义泛型方法<code>public static &lt;T&gt; T func()&#123; return null; &#125; </code></li>
<li>不能调用泛型参数的构造方法</li>
<li>可以指定泛型参数上界，以使用其成员<code>public static &lt;T extends K&gt; T func() &#123; return null; &#125;</code>，编译器静态地禁止代码越过上界</li>
<li>类型参数视为方法接受的实数，因此可以用于定义静态方法</li>
<li></li>
<li>编译实现将把泛型改写成Object，并在适当的时候向下转型。因此，</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>接受泛型参数</li>
<li><code>boolean add(E e)</code></li>
<li><code>boolean addAll(Collention&lt;? extends E&gt; c)</code></li>
<li><code>boolean contains(Object o), containsAll(Collect&lt;?&gt; c)</code></li>
<li><code>boolean equals(Object o)</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>Iterator&lt;E&gt; iterator()</code></li>
<li><code>boolean remove(Object o)</code> 删除成功返回ture</li>
<li><code>boolean removeAll(Collenton&lt;?&gt; c)</code></li>
<li><code>int size()</code></li>
<li><code>Object[] toArray()</code></li>
<li><code>&lt;T&gt; T[] toArray(T[])</code></li>
</ul>
<h3 id="Collections-由静态方法构成的类"><a href="#Collections-由静态方法构成的类" class="headerlink" title="Collections 由静态方法构成的类"></a>Collections 由静态方法构成的类</h3><ul>
<li><code>void sort(Collection&lt;?&gt; c)</code></li>
</ul>
<h2 id="list-允许重复的列表"><a href="#list-允许重复的列表" class="headerlink" title="list 允许重复的列表"></a>list 允许重复的列表</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><code>void add(int index, E element)</code></li>
<li><code>void add(int index, Collection&lt;? extends E&gt; c)</code></li>
<li>常用<code>void ensureCapacity(int minCapacity)</code>可以优化新开内存的耗时</li>
<li><code>int indexOf(Object o)</code> 返回第一次出现的位置，无则-1</li>
<li><code>int lastIndexOf(Object o)</code></li>
<li><code>E remove(int index)</code> 删除指定位置的元素</li>
<li><code>E set(int index, E element)</code> 替换指定位置的元素</li>
<li><code>void sort(Comparator&lt;? super E&gt; c)</code> 排序</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li>同ArrayList</li>
<li><code>void addFirst(E e)</code></li>
<li><code>void addLast(E e)</code></li>
<li><code>E getFirst()</code></li>
<li><code>E getLast</code></li>
<li><code>Iterator&lt;E&gt; descendingIterator()</code> 逆序迭代器</li>
<li><code>E pop()</code></li>
<li><code>void push(E e) == addFirst(E e)</code></li>
</ul>
<h2 id="set-不允许重复的集合"><a href="#set-不允许重复的集合" class="headerlink" title="set 不允许重复的集合"></a>set 不允许重复的集合</h2><ul>
<li><code>boolean(如果集合发生改变) remainAll(Collection&lt;?&gt; c), removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>void clear()</code> 清空</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>依赖于<code>HashCode()</code>判断元素是否相同</li>
<li>基于Object的<code>HashCode()</code>会将地址纳入计算，可以覆写<code>HashCode()</code>以忽略地址差异</li>
<li>若<code>HashCode()</code>相同，则调用<code>equals()</code>判断。基于Object的<code>equals()</code>仅比较地址（String类已覆写好）。</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul>
<li>依赖于接口Comparable的<code>compareTo()</code>或者比较类的<code>compare(,)</code>比较大小。优先使用比较类。小在前，大在后。</li>
<li>比较类需要实现接口Comparator,并<code>@Override compare(,)</code></li>
<li><code>Iterator&lt;E&gt; descendingIterator()</code> 逆序迭代器</li>
<li><code>Comparator &lt;? super E&gt; comparator()</code> 返回比较器，或null</li>
<li><code>E ceiling(E e)</code> 返回最小的大于等于e的元素，或null</li>
<li><code>E floor(E e)</code> 返回最大的小于等于e的元素，或null</li>
<li><code>E higher(E e)</code> 返回最小的大于e的元素，或null</li>
<li><code>E lower(E e)</code> 返回最大的小于e的元素，或null</li>
</ul>
<h2 id="Map-键值绑定"><a href="#Map-键值绑定" class="headerlink" title="Map 键值绑定"></a>Map 键值绑定</h2><ul>
<li><code>static interface Map.Entry&lt;K, V&gt;</code></li>
<li><code>int size()</code></li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>允许键值为null</li>
<li><code>HashMap()</code> 默认容量为16，负载因子为0.75</li>
<li><code>HashMap(int intialCapacity)</code></li>
<li><code>HashMap(int intialCapacity, float loadFactor)</code></li>
<li><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
<li><code>boolean containsKey(Object key)</code></li>
<li><code>boolean containsValue(Object value)</code></li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></li>
<li><code>V get(Object key)</code></li>
<li><code>Set&lt;K&gt; keySet()</code></li>
<li><code>V put(K key, V value)</code> 返回上一个值或null</li>
<li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code> 复制映射</li>
<li><code>V remove(Object key)</code></li>
<li><code>boolean remove(Object key, Object value)</code></li>
<li><code>V replace(K key, V value)</code> 如果有键则替换</li>
<li><code>boolean replace(K key, V oldValue, V newValue)</code> 如果键key映射到oldValue则替换</li>
<li><code>Collection&lt;V&gt; values()</code>返回值的Collection</li>
</ul>
]]></content>
      <tags>
        <tag>语法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin语法笔记</title>
    <url>/2019/10/12/kotlin/</url>
    <content><![CDATA[<p>Since 2019&#x2F;10&#x2F;12</p>
<span id="more"></span>

<h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><code>val a: Int = 10 // 声明常量</code></li>
<li><code>var b = 6.99 // 声明变量</code></li>
</ol>
<table>
<thead>
<tr>
<th>Java</th>
<th>Kotlin</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Int</td>
<td>整型</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>长整型</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>短整型</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>单精度</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>双精度</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>布尔型</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
<td>字符型</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>字节型</td>
</tr>
</tbody></table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myIntMax</span><span class="params">(p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(p1, p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单表达式化简-&gt;</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myIntMax</span><span class="params">(p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(p1, p2)</span><br></pre></td></tr></table></figure>

<p>类型推导化简-&gt;</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myIntMax</span><span class="params">(p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span> = max(p1, p2)</span><br></pre></td></tr></table></figure>

<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>用 if 实现max()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myIntMax</span><span class="params">(p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &gt; p2) &#123;</span><br><span class="line">        value = p1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = p2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 if 的返回值-&gt;</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (p1 &gt; p2) &#123;</span><br><span class="line">    p1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单表达式化简-&gt;</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myIntMax</span><span class="params">(p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (p1 &gt; p2) p1 <span class="keyword">else</span> p2</span><br></pre></td></tr></table></figure>

<h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>带参数的 when，参数类型没有限制</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以按类型选择</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123; <span class="comment">// Number 是数字数据类型的父类</span></span><br><span class="line">    <span class="keyword">when</span> (num) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;num is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;num is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带参数的 when，更加灵活</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    name.startWith(<span class="string">&quot;Tom&quot;</span>) -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span> <span class="comment">// 不需要显式equals()</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>和 Java 相同。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>取消了 for-i 循环。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span> <span class="comment">// 创建一个左闭右闭区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123; <span class="comment">// 左闭右闭区间</span></span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span>) &#123; <span class="comment">// 左闭右开区间</span></span><br><span class="line">	    println(i)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">3</span>) &#123; <span class="comment">// 左闭右闭降序</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// 默认public，且不可继承</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span> <span class="comment">// 默认public</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot; is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person() <span class="comment">// 不需要new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承与构造函数"><a href="#继承与构造函数" class="headerlink" title="继承与构造函数"></a>继承与构造函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// open，允许继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grage: <span class="built_in">Int</span>): Person(<span class="comment">/*调用父构造函数*/</span>) &#123;</span><br><span class="line">    <span class="comment">// sno, grage自动成为类成员</span></span><br><span class="line">    <span class="comment">// 如果不想自动成为类成员，则不要加val或var修饰符</span></span><br><span class="line">    <span class="comment">/* 向主构造函数加逻辑</span></span><br><span class="line"><span class="comment">    init &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;sno is &quot; + sno)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">this</span>(<span class="string">&quot;dzf&quot;</span>, <span class="number">100</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅有次构造函数</span></span><br><span class="line"><span class="comment">// 则声明处不需要声明调用父构造函数了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>: <span class="type">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 没有了主构造函数，这里就不能this()，只能super()</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>): <span class="keyword">super</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> <span class="comment">// 可以不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 也可以提供默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>(): Person(), Study &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123; <span class="comment">// 覆盖实现</span></span><br><span class="line">        println(<span class="string">&quot;reading.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>Java</th>
<th>Kotlin</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>所有类可见</td>
<td>所有类可见（默认）</td>
</tr>
<tr>
<td>private</td>
<td>当前类可见</td>
<td>当前类可见</td>
</tr>
<tr>
<td>protected</td>
<td>当前类、子类、同一包下的类可见</td>
<td>当前类、子类可见</td>
</tr>
<tr>
<td>default</td>
<td>同一包下的类可见</td>
<td>无</td>
</tr>
<tr>
<td>internal</td>
<td>无</td>
<td>同一模块下的类可见</td>
</tr>
</tbody></table>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>类修饰符<code>data</code>，自动生成各种方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cellphone</span>(<span class="keyword">val</span> brand:String, <span class="keyword">val</span> number:<span class="built_in">Int</span>) <span class="comment">// 没有代码，省略大括号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">Boolean</span> equals(Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">Int</span> hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> String toString()</span><br></pre></td></tr></table></figure>

<h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>类修饰符<code>object</code>，使类名成为全局唯一对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123; <span class="comment">// 注意没有class</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.test() <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<h3 id="伴生单例"><a href="#伴生单例" class="headerlink" title="伴生单例"></a>伴生单例</h3><p>包裹在 <code>companion object &#123;&#125;</code> 内部即可。性质类似静态成员。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// @JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">factory</span><span class="params">()</span></span>: Util &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="真正的静态成员"><a href="#真正的静态成员" class="headerlink" title="真正的静态成员"></a>真正的静态成员</h4><p>在伴生单例内加入 <code>@JvmStatic</code> 注解，或者，顶层方法是静态成员方法。</p>
<p>在 Java 中，将 kt 的文件名看作类名，即可调用 kotlin 顶层方法。</p>
<h2 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>列表</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;() <span class="comment">// 可变</span></span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>)</span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>) <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">val</span> list2 = mutableListOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>) <span class="comment">// 可变</span></span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(fruit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = setOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>) <span class="comment">// HashSet</span></span><br></pre></td></tr></table></figure>
<p>Map</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>)</span><br><span class="line">map[<span class="string">&quot;Banana&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// --------------------------------</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>) <span class="comment">// to 是 infix函数</span></span><br><span class="line"><span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(fruit + <span class="string">&quot; is &quot;</span> + number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a>集合的函数式API</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> maxLengthFruit: String = list.maxBy&#123; it.length &#125;</span><br><span class="line"><span class="keyword">val</span> newList = list.filter&#123; it.length &lt; <span class="number">5</span> &#125;.map &#123; it.toUpperCase() &#125;</span><br><span class="line"><span class="keyword">val</span> isOk: <span class="built_in">Boolean</span> = newList.all&#123; it.length &lt; <span class="number">5</span> &#125;</span><br><span class="line"><span class="keyword">val</span> isFault: <span class="built_in">Boolean</span> = newList.any&#123; it.length &gt;= <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式语法结构：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;v1: Type, v2: Type -&gt; body&#125;</span><br><span class="line"><span class="comment">// 返回值是body的最后一行代码</span></span><br></pre></td></tr></table></figure>
<p>Lambda表达式举例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lambda = &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(lambda)</span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(&#123; fruit: String -&gt; fruit.length &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda是最后一个参数</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy()&#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda是唯一一个参数</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推导参数类型</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; fruit -&gt; fruit.length &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda内只有一个参数</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy&#123; it.length &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java函数式API"><a href="#Java函数式API" class="headerlink" title="Java函数式API"></a>Java函数式API</h3><p>Java单抽象方法接口（例如Runnable）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span> : Runnable &#123; <span class="comment">// object 关键字，代表一个匿名对象</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Thread is running.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable只有一个抽象方法</span></span><br><span class="line">Thread(Runnale &#123;</span><br><span class="line">    println(<span class="string">&quot;Thread is running.&quot;</span>) <span class="comment">// Lambda表达式覆盖run()</span></span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread的参数列表中有且只有Runnable</span></span><br><span class="line">Thread(&#123;</span><br><span class="line">    println(<span class="string">&quot;Thread is running.&quot;</span>) <span class="comment">// Lambda表达式覆盖run()</span></span><br><span class="line">&#125;).start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda是唯一一个参数</span></span><br><span class="line">Thread &#123;</span><br><span class="line">    println(<span class="string">&quot;Thread is running.&quot;</span>)</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用标准函数"><a href="#常用标准函数" class="headerlink" title="常用标准函数"></a>常用标准函数</h3><ol>
<li><code>let</code> 返回最后一行 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">obj?.let &#123;</span><br><span class="line">    it.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>also</code> 返回本身 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">obj?.also &#123;</span><br><span class="line">    it.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>with</code> 返回最后一行 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>run</code> 返回最后一行 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">StringBuilder().run &#123;</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>apply</code> 返回本身 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
<h2 id="空类型系统"><a href="#空类型系统" class="headerlink" title="空类型系统"></a>空类型系统</h2><p>Kotlin默认编译器形参不可为空。</p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(a: <span class="type">Study</span>?, b: <span class="type">Study</span>)</span></span> &#123; <span class="comment">// 加问号，表示可空</span></span><br><span class="line">    a.readBooks() <span class="comment">// 编译错误，未处理空</span></span><br><span class="line">    a?.readBooks() <span class="comment">// 正确，若a为null则返回null</span></span><br><span class="line">    a!!.readBooks() <span class="comment">// 正确，向编译器保证a不为空。</span></span><br><span class="line">    <span class="keyword">val</span> c = a ?: b <span class="comment">// c = if (a!=null) a else b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(a: <span class="type">Study</span>?)</span></span> &#123; <span class="comment">// 简化版</span></span><br><span class="line">    a?.let &#123; <span class="comment">// 内置的let函数</span></span><br><span class="line">        it.readBooks()</span><br><span class="line">        it.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let</code>函数的优势是暂存了对象引用，不怕全局变量被多线程修改。相反，用<code>if</code>无法保证全局变量的非空。</p>
<h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello, <span class="subst">$&#123;obj.name&#125;</span>. Nice to meet you.&quot;</span> <span class="comment">// 表达式</span></span><br><span class="line"><span class="string">&quot;Hello, <span class="variable">$name</span>. Nice to meet you&quot;</span> <span class="comment">// 变量</span></span><br></pre></td></tr></table></figure>

<h2 id="绑定参数"><a href="#绑定参数" class="headerlink" title="绑定参数"></a>绑定参数</h2><p>通过绑定形参-实参，可以调换参数顺序</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">myfun(str = <span class="string">&quot;abc&quot;</span>, num = <span class="number">123</span>)</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>语法</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>.vimrc</title>
    <url>/2019/08/25/vimrc/</url>
    <content><![CDATA[<h2 id="vimrc-amp-Font"><a href="#vimrc-amp-Font" class="headerlink" title=".vimrc &amp; Font"></a>.vimrc &amp; Font</h2><p><a href="vimrc/null.vimrc">.vimrc</a></p>
<p><a href="vimrc/FiraCode-Retina.ttf">Fira Code Retina</a></p>
<span id="more"></span>


<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>For 8+ version.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span></span><br><span class="line"><span class="comment">&quot; the call to :runtime you can find below.  If you wish to change any of those</span></span><br><span class="line"><span class="comment">&quot; settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span></span><br><span class="line"><span class="comment">&quot; will be overwritten everytime an upgrade of the vim packages is performed.</span></span><br><span class="line"><span class="comment">&quot; It is recommended to make changes after sourcing debian.vim since it alters</span></span><br><span class="line"><span class="comment">&quot; the value of the &#x27;compatible&#x27; option.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; This line should not be removed as it ensures that various options are</span></span><br><span class="line"><span class="comment">&quot; properly set to work with the Vim-related packages available in Debian.</span></span><br><span class="line">runtime! debian.<span class="keyword">vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span></span><br><span class="line"><span class="comment">&quot; This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span></span><br><span class="line"><span class="comment">&quot; any settings in these files.</span></span><br><span class="line"><span class="comment">&quot; If you don&#x27;t want that to happen, uncomment the below line to prevent</span></span><br><span class="line"><span class="comment">&quot; defaults.vim from being loaded.</span></span><br><span class="line"><span class="comment">&quot; let g:skip_defaults_vim = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Uncomment the next line to make Vim more Vi-compatible</span></span><br><span class="line"><span class="comment">&quot; <span class="doctag">NOTE:</span> debian.vim sets &#x27;nocompatible&#x27;.  Setting &#x27;compatible&#x27; changes numerous</span></span><br><span class="line"><span class="comment">&quot; options, so any other options should be set AFTER setting &#x27;compatible&#x27;.</span></span><br><span class="line"><span class="comment">&quot;set compatible</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Vim5 and later versions support syntax highlighting. Uncommenting the next</span></span><br><span class="line"><span class="comment">&quot; line enables syntax highlighting by default.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;syntax&quot;</span>)</span><br><span class="line">  <span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; If using a dark background within the editing area and syntax highlighting</span></span><br><span class="line"><span class="comment">&quot; turn on this option as well</span></span><br><span class="line"><span class="keyword">set</span> background=dark</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Uncomment the following to have Vim jump to the last position when</span></span><br><span class="line"><span class="comment">&quot; reopening a file</span></span><br><span class="line"><span class="string">&quot;if has(&quot;</span><span class="keyword">autocmd</span><span class="comment">&quot;)</span></span><br><span class="line"><span class="string">&quot;  au BufReadPost * if line(&quot;</span><span class="string">&#x27;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;</span>\<span class="string">&quot;&quot;</span>) &lt;= <span class="built_in">line</span>(<span class="string">&quot;$&quot;</span>) | <span class="keyword">exe</span> <span class="string">&quot;normal! g&#x27;\&quot;&quot;</span> | <span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot;endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Uncomment the following to have Vim load indentation rules and plugins</span></span><br><span class="line"><span class="comment">&quot; according to the detected filetype.</span></span><br><span class="line"><span class="string">&quot;if has(&quot;</span><span class="keyword">autocmd</span><span class="comment">&quot;)</span></span><br><span class="line"><span class="comment">&quot;  filetype plugin indent on</span></span><br><span class="line"><span class="comment">&quot;endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; The following are commented out as they cause vim to behave a lot</span></span><br><span class="line"><span class="comment">&quot; differently from regular Vi. They are highly recommended though.</span></span><br><span class="line"><span class="keyword">set</span> showcmd		<span class="comment">&quot; Show (partial) command in status line.</span></span><br><span class="line"><span class="keyword">set</span> showmatch		<span class="comment">&quot; Show matching brackets.</span></span><br><span class="line"><span class="keyword">set</span> ignorecase		<span class="comment">&quot; Do case insensitive matching</span></span><br><span class="line"><span class="keyword">set</span> smartcase		<span class="comment">&quot; Do smart case matching</span></span><br><span class="line"><span class="string">&quot;set incsearch		&quot;</span> Incremental <span class="built_in">search</span></span><br><span class="line"><span class="keyword">set</span> autowrite		<span class="comment">&quot; Automatically save before commands like :next and :make</span></span><br><span class="line"><span class="keyword">set</span> hidden		<span class="comment">&quot; Hide buffers when they are abandoned</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span>		<span class="comment">&quot; Enable mouse usage (all modes)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> autoread</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Source a global configuration file if available</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">&quot;/etc/vim/vimrc.local&quot;</span>)</span><br><span class="line">  <span class="keyword">source</span> /etc/<span class="keyword">vim</span>/vimrc.local</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">call</span> CompileCPP()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! CompileCPP()</span><br><span class="line">	exec <span class="string">&quot;w&quot;</span></span><br><span class="line">	<span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">		exec <span class="string">&#x27;!g++ -Wall -DDEBUG % -o %&lt;&#x27;</span></span><br><span class="line">	<span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> RunOUT()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! RunOUT()</span><br><span class="line">	exec <span class="string">&#x27;!./%&lt;&#x27;</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ps-bashrc"><a href="#ps-bashrc" class="headerlink" title="ps. bashrc"></a>ps. bashrc</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">TEXT::</span><br><span class="line">terminal size : <span class="number">90</span> * <span class="number">34</span></span><br><span class="line"></span><br><span class="line">custom font Fira Code Retina <span class="number">14</span></span><br><span class="line">Cell spaceing <span class="number">1.00</span> <span class="number">1.00</span></span><br><span class="line"></span><br><span class="line">Cursor : Block, Default</span><br><span class="line"></span><br><span class="line">COLORS::</span><br><span class="line">Custom::</span><br><span class="line">	Default: <span class="meta">#D3D7CF, #020F20</span></span><br><span class="line">	Bold: disabled</span><br><span class="line">	Cursor: <span class="meta">#FFFFFF, #0350C9</span></span><br><span class="line">	Hightlight: disabled</span><br><span class="line">	palette: (Tango), blue: <span class="meta">#4A7DBE #7EA9D6</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>初等数论</title>
    <url>/2019/08/02/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="模方程"><a href="#模方程" class="headerlink" title="模方程"></a>模方程</h1><h2 id="基础性质"><a href="#基础性质" class="headerlink" title="基础性质"></a>基础性质</h2><h3 id="模的等价关系"><a href="#模的等价关系" class="headerlink" title="模的等价关系"></a>模的等价关系</h3><p><strong>自反性</strong><br>$$ a\equiv a \mod m $$<br><strong>对称性</strong><br>$$ a\equiv b \mod m\Leftrightarrow b\equiv a \mod m$$</p>
<span id="more"></span>
<p><strong>传递性</strong><br>$$<br>a\equiv c \mod m, c\equiv b\mod m \Rightarrow a\equiv b \mod m<br>$$</p>
<h3 id="等式的性质"><a href="#等式的性质" class="headerlink" title="等式的性质"></a>等式的性质</h3><p><strong>可加减性</strong><br>$$<br>模m意义下\<br>a\equiv b, c\equiv d \Rightarrow a+c\equiv b+d<br>$$<br><strong>可乘性</strong><br>$$<br>模m意义下\<br>a\equiv b, c\equiv d \Rightarrow ac\equiv bd<br>$$</p>
<blockquote>
<p>证明：设$a-b&#x3D;km$, $c-d&#x3D;lm$. 则$a&#x3D;b+km$, $c&#x3D;d+lm$, $ac&#x3D;klm^2+(bl+ck)m+bd$, 显然$m|(ac-bd)$</p>
<p>推论：模$m$意义下,$a\equiv b \Rightarrow an\equiv bn$, $n$是自然数</p>
</blockquote>
<p><strong>消去律</strong>（乘法逆元的充要条件）<br>$$<br>模m意义下\<br>ac\equiv bc, gcd(c,m)&#x3D;1 \Rightarrow a\equiv b<br>$$</p>
<blockquote>
<p>证明：m|c(a-b), 因为c,m公因子为1，所以m|(a-b).</p>
</blockquote>
<p><strong>幂保持恒等</strong><br>$$<br>模m意义下\<br>a\equiv b \Rightarrow a^n\equiv b^n<br>$$</p>
<p><strong>恒等的最大空间</strong><br>$$<br>a\equiv b \mod m_1\<br>a\equiv b \mod m_2\<br>\dotsm \<br>a\equiv b \mod m_n \<br>\Downarrow \<br>a\equiv b \mod lcm(m_1, m_2,\dotsm, m_n);<br>$$</p>
<blockquote>
<p>证明：(a-b)是$m_1,m_2,\dotsm,m_n$的倍数，而lcm包含了所有质因子的最大次幂。</p>
<p>推论：若$m_1,m_2,\dotsm,m_n$互质，则$a\equiv b \mod m_1m_2\dotsm m_n;$</p>
</blockquote>
<p><strong>换模的另一种途径</strong><br>$$<br>a\equiv b \mod c \<br>\Downarrow \<br>ad \equiv bd \mod cd<br>$$</p>
<blockquote>
<p>证明：$c|(a-b)\Rightarrow cd|d(a-b)$。</p>
</blockquote>
<h2 id="高级定理"><a href="#高级定理" class="headerlink" title="高级定理"></a>高级定理</h2><h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><p>$$<br>gcd(a,b)是a,b的线性组合。即存在整数x,y,使得xa+yb&#x3D;gcd(a,b).<br>$$</p>
<blockquote>
<p>证明：</p>
<p>当$a&#x3D;b$时结论显然成立。</p>
<p>当$a\neq b$时，不妨设$a\neq0$，取$d$为$a,b$的所有线性组合中最小的正整数。作带余除法$a&#x3D;qd+r$，则$0\leq r&lt;d$. 若$r\neq 0$,则$r&#x3D;a-qd$是比d更小的线性组合，与假设矛盾,所以$r&#x3D;0$,$d$是$a$的因子;同理可得$d$是$b$的因子,故$d$是$a,b$的公因子.取$c$为$a,b$的任意公因子,对$d&#x3D;(xa+yb)$提取$c$得$d&#x3D;c(xa&#39;+yb&#39;)$,可知$c$是$d$的因子,所以$|c|\leq d$,故$d&#x3D;gcd(a,b)$.</p>
</blockquote>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>$$<br>有线性同余方程组\<br>x\equiv a_1 \mod m_1\<br>x\equiv a_2 \mod m_2\<br>\dotsm \<br>x\equiv a_3 \mod m_n \<br>其中m_i两两互质，则在模M&#x3D;m_1m_2\dotsm m_n意义下解有且只有一个。\<br>构造方法如下：<br>设M_i为\frac{M}{m_i}，在模m_i意义下M_i的逆为t_i。则\<br>x&#x3D;\sum_{i&#x3D;1}^{n} a_it_iM_i<br>$$</p>
<blockquote>
<p>证明：</p>
<p>构造解$x$的正确性。对于方程$i$,$\quad t_iM_i\equiv 1 \mod m_i, M_j\equiv 0 \mod m_i$。所以解满足每一条方程式。</p>
<p>在模$M$意义下解的唯一性。令$x_1,x_2$为方程组的两个不同的解,则$(x_1-x_2)$分别是$m_1,m_2\dotsm m_n$的倍数，则$|(x_1-x_2)|\geq M$，则在模$M$意义下解是唯一的。</p>
</blockquote>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>m的化简剩余系（又称既约剩余系，缩系），<strong>本文记为$Z_m$</strong><br>$$<br>m的剩余系中与m互质的数构成的子集<br>$$</p>
<p>欧拉函数$\phi(n)$<br>$$<br>m的化简剩余系的元素个数，即|Z_m|<br>$$</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p>对于质数$p$，$\phi(p)&#x3D;p-1$ </p>
</li>
<li><p>对于质数$p$，$\phi(p^k)&#x3D;p^{k-1}(p-1)$</p>
<blockquote>
<p>证明：在$[1,p^k]$中，不与$p^k$互质的有${p,2p,3p,\dotsc,p^k}$共$\frac{p^k}{p}&#x3D;p^{k-1}$个数，则互质的有$p^k-p^{k-1}&#x3D;p^{k-1}(p-1)$个数。</p>
</blockquote>
</li>
<li><p><strong>欧拉函数是积性函数</strong>，即对于互质的两数$m_1,m_2$，有$\phi(m_1m_2)&#x3D;\phi(m_1)\phi(m_2)$</p>
</li>
</ol>
<blockquote>
<p>证明：设$a\in Z_{m_1}, b\in Z_{m_2}$，则有同余方程组<br>$$ N \equiv a \mod m_1\<br>N \equiv b \mod m_2\ $$<br>其中$a,m_1$互质，$b,m_2$互质，$m_1,m_2$互质。则N在模$m_1m_2$下有且仅有唯一解$N&#x3D;am_2^{-1}m_2+bm_1^{-1}m_1$，显然$N$与$m_1,m_2$都互质，故与$m_1m_2$互质，$N\in Z_{m_1m_2}$。对任意的$N\in Z_{m_1m_2}$，其对应的$(a,b)$也是唯一的。综上，映射$Z_{m_1m_2}\rightarrow Z_{m_1}\times Z_{m_2}$是满射也是单射，则此映射是双射，故$|Z_{m_1m_2}|&#x3D;|Z_{m_1}||Z_{m_2}|$，即$\phi(m_1m_2)&#x3D;\phi(m_1)\phi(m_2)$。</p>
</blockquote>
<ol start="4">
<li>对于质数$p$，且$p|a$，则$\phi(ap)&#x3D;\phi(a)p$</li>
</ol>
<blockquote>
<p>证明：提取$a$的所有p因子得$ap&#x3D;a&#39;p^xp&#x3D;a&#39;p^{x+1}$，由积性函数得<br>$$ \begin{aligned}<br>  \phi(ap)&#x3D;&amp;\phi(a&#39;)\phi(p^{x+1}) \<br>  &#x3D;&amp;\phi(a&#39;)p^x(p-1)\<br>  &#x3D;&amp;\phi(a&#39;)p^{x-1}(p-1)p\<br>  &#x3D;&amp;\phi(a&#39;)\phi(p^x)p\<br>  &#x3D;&amp;\phi(a&#39;p^x)p\<br>  &#x3D;&amp;\phi(a)p<br>\end{aligned} $$</p>
</blockquote>
<ol start="5">
<li>欧拉函数通项<br>$$<br>令{p_1,p_2,\dotsc,p_m}为n的所有质因子\<br>\phi(n)&#x3D;n\prod_{i&#x3D;1}^m(1-\frac{1}{p_i})<br>$$</li>
</ol>
<blockquote>
<p>证明：<br>$$\begin{aligned}<br>  设n&#x3D;&amp;\prod_{i&#x3D;1}^mp_i^{x_i}\<br>  由积性&amp;函数得\<br>  \phi(n)&#x3D;&amp;\prod_{i&#x3D;1}^{m}\phi(p_i^{x_i})\<br>  &#x3D;&amp;\prod_{i&#x3D;1}^{m}p_i^{x_i}(1-\frac{1}{p_i})\<br>  &#x3D;&amp;n\prod_{i&#x3D;1}^m(1-\frac{1}{p_i})<br>  \end{aligned}<br>$$</p>
</blockquote>
<ol start="6">
<li>$\phi(n)(n&gt;2)$是偶数</li>
</ol>
<blockquote>
<p>证明：由欧几里得算法可知$\forall i \in [1,n]$且$i$与n互质，则$(n-i)$也与$n$互质。并且$i \neq (n-i)$，这是因为若相等，有$2i&#x3D;n$，此时$i(i&gt;1)$不与$n$互质。所以与$n$互质的数成对出现，$\phi(n)(n&gt;2)$是偶数。</p>
</blockquote>
<ol start="7">
<li><strong>质因子的次数不超过欧拉函数值</strong><br>$$<br>设n&#x3D;p^xs，其中gcd(p,s)&#x3D;1，则x\leq \phi(n)<br>$$</li>
</ol>
<blockquote>
<p>证明：<br>$$<br>\begin{aligned}<br>\phi(n)&#x3D;&amp;\phi(p^x)\phi(s) \<br>\geq&amp; \phi(p^x) &#x3D; p^{x-1}(p-1)<br>\end{aligned}\<br>下面证明x\leq p^{x-1}(p-1)<br>$$<br>取$p&#x3D;2$，验证得当$x&#x3D;1,2,3$时不等式都成立。由归纳法可知$p&#x3D;2$时不等式成立。取$p&gt;2$，等式左边不变，右边变大，不等式仍成立。</p>
</blockquote>
<ol start="8">
<li>$\sum\limits_{d|n}\phi(d) &#x3D; n$</li>
</ol>
<blockquote>
<p>证明：$\forall k \in [1,n]$，对应有一个$d&#x3D;gcd(k,n)$。所有可能的$d$取遍了$n$的所有因子。对$d|n$，考虑其对应的$k$，不妨设$k&#x3D;k_1d,n&#x3D;k_2d，且gcd(k_1,k_2)&#x3D;1,那么k_1\leq k_2$。显然$k_2&#x3D;\frac{n}{d}$是固定的，那么可能的$k_1$的取值有$\phi(k_2)&#x3D;\phi(\frac{n}{d})$种。所以<br>$$<br>n&#x3D;\sum\limits_{d|n}\phi(\frac{n}{d})&#x3D;\sum\limits_{d|n}\phi(d)<br>$$</p>
</blockquote>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>$$<br>对于互质的两个数a,n有\<br>a^{\phi(n)} \equiv 1 \mod n<br>$$</p>
<blockquote>
<p>证明：设$Z_n&#x3D;{x_1,x_2,\dotsc,x_{\phi(n)}}$，因$a,n互质$，则$ax_i \mod n \in Z_n$；而对$x_i\neq x_j$，由消去律有$ax_i\neq ax_j \mod n$。故模n意义下$Z_n&#x3D;{ax_1,ax_2,\dotsc,ax_{\phi(n)}}$。</p>
<p>故<br>$$<br>\prod_{i&#x3D;1}^{\phi(n)}x_i \equiv \prod_{i&#x3D;1}^{\phi(n)}ax_i \mod n\<br>$$<br>由消去律得<br>$$<br>a^{\phi(n)} \equiv 1 \mod n<br>$$</p>
<p>推论：<strong>费马小定理</strong>。</p>
</blockquote>
<h3 id="扩展欧拉定理（欧拉降幂）"><a href="#扩展欧拉定理（欧拉降幂）" class="headerlink" title="扩展欧拉定理（欧拉降幂）"></a>扩展欧拉定理（欧拉降幂）</h3><p>$$<br>模m意义下\<br>a^c\equiv<br>\begin{cases}<br>    a^{c \mod \phi(m)}, \qquad &amp;a,m互质\<br>    a^c, \qquad &amp;a,m不互质，c&lt;\phi(m)\<br>    a^{c \mod \phi(m)+\phi(m)}, \qquad &amp;a,m不互质，c\geq \phi(m)<br>\end{cases}<br>$$</p>
<blockquote>
<p>证明：$当a,m互质时$，由欧拉定理知$a^{\phi(m)}\equiv 1 \mod m$，定理显然成立。</p>
<p>$当a,m不互质，c&lt;\phi(m)时$，定理显然成立。</p>
<p>$当 a,m不互质，c\geq \phi(m)时$，取$a$的任意质因子$p$，即$a&#x3D;p^xs且gcd(p,s)&#x3D;1$，由欧拉定理知<br>$$p^{\phi(s)}\equiv 1 \mod s$$<br>由积性函数知$\phi(s)|\phi(m)$，故<br>$$p^{\phi(m)}\equiv 1 \mod s$$<br>同余方程同乘$p^x$(<strong>换模的另一种途径</strong>)得<br>$$<br>p^{\phi(m)+x} \equiv p^x \mod m<br>$$<br>由<strong>欧拉函数的性质7</strong>知$x\leq \phi(m)$，已知$\phi(m)\leq c$，所以<br>$$<br>x \leq \phi(m) \leq c\<br>p^c\equiv p^{x+(c-x)}\equiv p^{\phi(m)+x+(c-x)}\equiv p^{\phi(m)+c} \mod m<br>$$<br>由$c(c\geq \phi(m))$的任意性和数学归纳法得<br>$$<br>p^c\equiv p^{c \mod \phi(m) + \phi(m)} \mod m \<br>$$<br>对$p$的幂$p^k$，易得<br>$$<br>(p^k)^c\equiv p^{kc}\equiv p^{kc \mod \phi(m)+\phi(m)}\<br>\equiv p^{kc\mod \phi(m)+k\phi(m)}\equiv (p^k)^{c \mod \phi(m)+\phi(m)} \mod m<br>$$<br>对$a&#x3D;\prod\limits_{i&#x3D;1}^np_i^{x_i}$，得<br>$$ \begin{aligned}<br>  a^c\equiv &amp; \prod\limits_{i&#x3D;1}^n(p_i^{x_i})^c \<br>  \equiv &amp; \prod\limits_{i&#x3D;1}^n(p_i^{x_i})^{c \mod \phi(m)+\phi(m)} \<br>  \equiv &amp; a^{c \mod \phi(m) + \phi(m)} \mod m<br>\end{aligned}<br>$$</p>
</blockquote>
<hr>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="线性筛质数"><a href="#线性筛质数" class="headerlink" title="线性筛质数"></a>线性筛质数</h2><p>求$[1,n]$内的所有素数。</p>
<ol>
<li>算法核心是<strong>每个合数只被其最小质因子筛到</strong>。</li>
<li>当前判断完$i$是否质数。接下来筛去i的倍数。枚举已知质数$p_j$，筛去$p_j*i$。若$p_j$是$i$的最小质因子则break。这是因为i以后筛的数都以$p_j$为最小质因子，这些数肯定能被其他的$i$枚举$p_j$筛去，不必重复筛。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// memset(vis, 0, sizeof(vis));</span></span><br><span class="line">    pcnt = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[pcnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;pcnt &amp;&amp; prime[j]*i&lt;=n; ++j) &#123;</span><br><span class="line">            vis[prime[j]*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h2><p>求$[1,n]$内所有欧拉函数值</p>
<ol>
<li>算法核心是<strong>积性函数</strong>和<strong>欧拉函数性质4</strong></li>
<li>在线性筛的同时完成欧拉函数计算。当前判断完$i$是否质数，若是合数，则函数值在前面计算过了；若是质数，直接赋值$\phi(i)&#x3D;i-1$。枚举已知质数$p_j$时，若$p_j$不是$i$的因子，由积性函数可知$\phi(i\cdot p_j)&#x3D;\phi(i)\cdot \phi(p_j)&#x3D;\phi(i)\cdot (p_j-1)$ ; 若$p_j$是$i$的因子，由<strong>性质4</strong>得$\phi(i\cdot p_j)&#x3D;\phi(i)\cdot p_j$，然后break。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPhi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// memset(phi, 0, sizeof(phi));</span></span><br><span class="line">    pcnt = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            prime[pcnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;pcnt &amp;&amp; i*prime[j]&lt;=n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a><strong>欧几里得算法</strong>（辗转相除法）</h2><p>求$gcd(a,b)$。</p>
<ol>
<li>$gcd(a, 0)$的结果显然等于$a$。</li>
<li>当$a，b$全不为零，则$gcd(a,b) &#x3D; gcd(b, a \mod b )$使问题规模减小。<blockquote>
<p>证明：令$c&#x3D;a\mod b$,则$a&#x3D;kb+c$.设$r$是$a,b$的公约数，则$r|a-kb$即$r|c$.设$r$是$b,c$的公约数,则$r|kb+c$即$r|a$.可见$a,b$的公约数和$b,a\mod b$的公约数完全相同，则最大公约数也必然相同。</p>
<p>应用：从$1$到$n(n&gt;2)$中与$n$互质的数成对出现，每一对和为$n$</p>
</blockquote>
</li>
</ol>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a><strong>扩展欧几里得算法</strong></h2><p>求$ax+by&#x3D;gcd(a,b)$的一组整数解$x,y$。</p>
<ol>
<li>直接由<strong>贝祖定理</strong>可知整数解一定存在。（贝祖定理：存在整数$s，t$使得$sa+tb&#x3D;gcd(a,b)$）</li>
<li>由辗转相除法知$bx&#39;+(a%b)y&#39;&#x3D;gcd(b,a%b)&#x3D;gcd(a,b)$的解也存在。由整数除法得<br>$$\begin{aligned}<br> bx&#39;+(a%b)y&#39;&#x3D;&amp;bx&#39;+(a-\frac{a}{b}b)y&#39;\<br> &#x3D;&amp;b(x&#39;-\frac{a}{b}y&#39;)+ay&#39;&#x3D;gcd(a,b)<br>\end{aligned}<br>$$</li>
<li>递归进行求解，直到$b&#x3D;0$，显然有解$1a+0b&#x3D;gcd(a,b)$，令$x&#x3D;1, y&#x3D;0$，回溯，得解$x&#x3D;y&#39;, y&#x3D;x&#39;-\frac{a}{b}y&#39;$</li>
<li>实际写代码时用引用，减少临时变量。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;d, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        d = a;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a%b, d, y, x); <span class="comment">// x和y完成了交换</span></span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a><strong>类欧几里得算法</strong></h2><p>求等差数列对每一项做整数除法的和，即<br>$$<br>lgcd(a, b, c, n) &#x3D; \sum_{i&#x3D;0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor<br>$$</p>
<ol>
<li><p>首先标准化$a,b$，使满足$a\geq 0, b\geq 0$，在答案中预先减去补上的$c$即可。</p>
</li>
<li><p>把$a,b$中含$c$的贡献拆出来，使问题规模变小。答案加上$n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor$。即<br>$$<br>\sum_{i&#x3D;0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor &#x3D; \sum_{i&#x3D;0}^{n-1}\lfloor \frac{(a%c)i+(b%c)}{c}\rfloor + n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor<br>$$<br>现在可以令$a&#39;&#x3D;a%c,\quad b&#39;&#x3D;b%c$。</p>
</li>
<li><p>计算$\sum\limits_{i&#x3D;0}^{n-1}\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor$，得到的商肯定介于$[0,\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor]$，设某次除法得到的商是$x$，可以认为$[1,x]$中每一个数对答案贡献了$1$，考虑每个数的总贡献，则<br>$$<br>\sum\limits_{i&#x3D;0}^{n-1}\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor &#x3D; \sum_{j&#x3D;1}^{\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor} \sum_{i&#x3D;0}^{n-1} [\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor \geq j]<br>$$</p>
</li>
<li><p>接下来变换不等式$\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor \geq j$。 取整符号不影响大于等于号的判断，可直接去掉；可直接通分；移项得$a&#39;i\geq jc-b&#39;$。整数除法的同除会影响大于等于号的判断，但不影响大于号，于是右边减一，两边同除$a&#39;$得$i&gt;\frac{jc-b&#39;-1}{a&#39;}$。</p>
</li>
<li><p>为了方便统计合法的$i$，也为了转化形式满足递归，利用补集统计数量。对于固定的$j$，<br>$$ \begin{aligned}<br> \sum\limits_{i&#x3D;0}^{n-1} [i&gt;\frac{jc-b&#39;-1}{a&#39;}] &#x3D;&amp; n-\sum\limits_{i&#x3D;0}^{n-1} [i\leq\frac{jc-b&#39;-1}{a&#39;}] \<br> &#x3D;&amp; n-(\lfloor\frac{jc-b&#39;-1}{a&#39;}\rfloor+1)<br>\end{aligned}<br>$$</p>
</li>
<li><p>套上前一层Sigma，得到递归形式（<strong>注意j变成从0开始</strong>）<br>$$<br>令m&#x3D;{\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor} \<br>\sum_{j&#x3D;0}^{m-1}[n-(\lfloor\frac{(j+1)c-b&#39;-1}{a&#39;}\rfloor+1)] &#x3D; (n-1)m-lgcd(c, c-b&#39;-1,a&#39;,m)<br>$$</p>
</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum&#123;(ai+b)/c&#125; for i=0..n-1</span></span><br><span class="line"><span class="function">LL <span class="title">lgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL res = n*(b/c) + (n<span class="number">-1</span>)*n/<span class="number">2</span>*(a/c);</span><br><span class="line">	a = a % c; b = b % c;</span><br><span class="line">	LL m = (a*(n<span class="number">-1</span>)+b)/c;</span><br><span class="line">	<span class="keyword">return</span> (n<span class="number">-1</span>)*m - <span class="built_in">lgcd</span>(c, c-b<span class="number">-1</span>, a, m) + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>质因数分解时，质因数要么小于等于$\sqrt{n}$，要么等于$n$。不要漏掉等于$n$的情况。</li>
<li>1e8+7以内的质数<br>有5761456个，约为6e6，约为范围的1&#x2F;15。<br><strong>范围越大，质数的占比越小</strong></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈</title>
    <url>/2019/07/08/%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h1 id="组合游戏"><a href="#组合游戏" class="headerlink" title="组合游戏"></a>组合游戏</h1><ol>
<li>两个游戏者轮流操作</li>
<li>游戏的状态集有限，每种状态最多出现一次（游戏可以结束）</li>
<li>无法操作的输，另一个获胜（游戏必有胜负）</li>
<li>公平游戏。两个游戏者面对相同的状态允许有相同的操作。</li>
</ol>
<span id="more"></span>

<h3 id="状态判定"><a href="#状态判定" class="headerlink" title="状态判定"></a>状态判定</h3><ol>
<li>一个状态是必胜状态(N)当且仅当它至少有一个后继是必败状态。</li>
<li>一个状态是必败状态(P)当且仅当它的所有后继都是必胜状态。</li>
<li>特别地，没有后继的状态是必败状态。</li>
</ol>
<h3 id="后手必胜的必要条件"><a href="#后手必胜的必要条件" class="headerlink" title="后手必胜的必要条件"></a>后手必胜的必要条件</h3><p>如果后手有必胜策略，则无论先手怎么取，都会存在后继可导致必败状态（即先手的所有后继都是必胜）。若先手能直接到达必败状态，则后手必输。</p>
<p>如Chomp!游戏（m*n棋盘，每次取某个点的所有右上格子，取到最后一个输）中，只要格子大于1，先手取最右上的一个格子，若后手能导致必败状态，则开局先手模仿后手的策略即可。故格子大于1时后手必败。</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>设有状态x，令SG(x) &#x3D; mex(S), S为x的所有后继状态的SG值的集合，mex(S)为不在集合中的最小非负整数。对于没有后继的状态，SG&#x3D;0，因为S是空集。其余的SG值可由递推得到。<br>当且仅当SG(x) &#x3D;&#x3D; 0, x是必败状态。</p>
<h2 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h2><p>一个总游戏的SG值等于子游戏的SG值的Nim和（异或和）</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol>
<li>证明P状态的所有后继都是N状态<ol>
<li>异或和为零，对转移任意一状态，则异或和必不为零（新状态异或旧状态不为零），即后继必为N</li>
</ol>
</li>
<li>证明N状态的后继存在P状态<ol>
<li>异或和不为零，</li>
</ol>
</li>
</ol>
<h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>有n堆火柴，每堆有ai根火柴。每次选择一堆取走任意根，不能取的游戏者输。</p>
<p>考虑只有一堆的情况，设剩余火柴数为x。若x&#x3D;&#x3D;0，没有后继状态，SG(0) &#x3D; 0; 若x&#x3D;&#x3D;1，所有后继状态的SG集合{0}，则SG(1) &#x3D; 1; 若x&#x3D;&#x3D;2，对应的S&#x3D;&#x3D;{0，1}，SG(2) &#x3D; 2; 归纳法证明SG(x) &#x3D; x;</p>
<p>应用SG定理，对于多堆游戏，总游戏SG值为所有子游戏的SG值的Nim和，即所有堆火柴数的异或和。当且仅当异或和为0，先手必败。</p>
<h2 id="组合游戏题解法"><a href="#组合游戏题解法" class="headerlink" title="组合游戏题解法"></a>组合游戏题解法</h2><p>小范围内暴力计算子游戏SG值，找规律找到SG公式。</p>
<h1 id="博弈搜索"><a href="#博弈搜索" class="headerlink" title="博弈搜索"></a>博弈搜索</h1><p>CF ROUND 460 DIV2 F</p>
<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><ol>
<li>圆桌放圆盘<ol>
<li>对称性。先手占领圆心，后面被一步都模仿另一方。</li>
</ol>
</li>
<li>硬币环取1-K连续<ol>
<li>分类讨论K</li>
</ol>
</li>
<li>威佐夫博弈：两堆石子，取任意个时可对两堆同时操作<ol>
<li>记结论(x0&#x3D;0, y0&#x3D;0),(xk&#x3D;mex{xi,yi}, yk&#x3D;xk+k)必败</li>
<li>$a_k&#x3D;\frac{\sqrt{5}+1}{2}k$</li>
<li>扩展：三堆，可同时操作两堆<ol>
<li>必败态少，跳过必胜态</li>
</ol>
</li>
</ol>
</li>
<li>每次一堆分别成异或加数两堆（每堆小于源堆）</li>
<li>反NIM游戏，先手必胜条件<ol>
<li>每堆石子只有一个，NIM和为零</li>
<li>有一堆石子多于一个，NIM和不为零</li>
</ol>
</li>
<li>SJ定理（泛化反NIM游戏）先手必胜条件<ol>
<li>每个子游戏SG值&lt;&#x3D;1，SG异或和为零</li>
<li>存在一个子游戏SG&gt;1，SG异或和不为零</li>
</ol>
</li>
<li>Every-SG策略<ol>
<li>必胜态使步骤尽量长</li>
<li>必败态使步骤尽量短</li>
<li>先手获胜充要条件：所有单一游戏SG值最大值是奇数</li>
</ol>
</li>
<li>有根无向图删边游戏<ol>
<li>若无环，Colon定理</li>
<li>可能有环，Fushion等价缩环变树</li>
</ol>
</li>
<li>齐肯多夫定理：任何正整数可以唯一的表示为若干个不连续的斐波那契数之和</li>
<li>动态减法游戏（一倍，两倍，k倍）</li>
<li>翻硬币，最右必须由正变反<ol>
<li>多种扩展</li>
<li>打表吧</li>
<li>tartan定理<ol>
<li>二维硬币分解成一维硬币的积，logn2求nim积。这种积有结合律，可扩展到更高维</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分学备忘录</title>
    <url>/2019/02/03/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%AD%A6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<!-- 今日立志，做一个对数学敏感的大学生！ -->

<span id="more"></span>

<h1 id="均值不等式"><a href="#均值不等式" class="headerlink" title="均值不等式"></a>均值不等式</h1><h2 id="四种均值"><a href="#四种均值" class="headerlink" title="四种均值"></a>四种均值</h2><ol>
<li>平方平均值 $Q_n&#x3D;\sqrt{ \frac{\sum_{i&#x3D;1}^n x_i^2}{n} }$</li>
<li>算术平均值 $A_n&#x3D;\frac{\sum_{i&#x3D;1}^n x_i}{n}$</li>
<li>几何平均值 $G_n&#x3D;\sqrt[n]{x_1 x_2 \cdots x_n}$</li>
<li>调和平均值 $H_n&#x3D;\frac{1}{\sum_{i&#x3D;1}^n {\frac{1}{x_i}}}$</li>
</ol>
<h2 id="四种均值的大小关系"><a href="#四种均值的大小关系" class="headerlink" title="四种均值的大小关系"></a>四种均值的大小关系</h2><p>$$ Q_n \geq A_n \geq G_n \geq H_n $$</p>
<h3 id="证明-G-n-leq-A-n"><a href="#证明-G-n-leq-A-n" class="headerlink" title="证明$G_n \leq A_n$"></a>证明$G_n \leq A_n$</h3><ul>
<li><p>分析: 采用数学归纳法. 易证$n&#x3D;2$的情况. 令$a&#x3D;A_n$. 要从n-1推出n, 先让开n次方转为幂次. 左端设法变为$a_1a_2\cdots a_n$, 右端设法变为$a^{n-1}\times a$. 原右边是n-1个数求均, 要变成n个数求均, 需要修改第一项以加入$a_n$. 令$\frac{a_2+\cdots +a_{n-1}+x}{n-1}&#x3D;a$, 左边只能平分n-1份, 少了一份恰为a, 则$x&#x3D;a_1+a_n-a$. 原左边对应地要将$a_1$替换成$a_1+a_n-a$, 且最后补乘了$a$, 所以应该建立关系$a_1a_n$~$a(a_1+a_n-a)$. 从不等式$(a-a_1)(a-a_n)\leq 0$可以获得这个关系.</p>
</li>
<li><p>证明:<br>  不妨设$a_1, a_2$为所有项中的最小,最大值.  $a&#x3D;\frac{a_1+\cdots +a_n}{n}$, 则$a_1\leq a\leq a_n$.<br>  $$(a-a_1)(a-a_n)\leq 0 \Rightarrow a_1a_n \leq a(a_1+a_n-a)$$<br>  易证n&#x3D;2时成立.<br>  假设当n-1时成立,即<br>  $$\sqrt[n-1]{a_2+\cdots +a_{n-1}+(a_1+a_n-a)}\leq \frac{a_2+\cdots +a_{n-1}+(a_1+a_n-a)}{n-1}&#x3D;a$$<br>  $$a_1a_2\cdots a_n\leq a2+\cdots +a_{n-1}+a(a_1+a_n-a)\leq a^{n-1}\cdot a&#x3D;a^n $$<br>  $$\therefore\sqrt[n]{a_1\cdots a_n}\leq a&#x3D;\frac{a_1+\cdots +a_n}{n}$$</p>
</li>
</ul>
<h1 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h1><h2 id="收敛数列定义"><a href="#收敛数列定义" class="headerlink" title="收敛数列定义"></a>收敛数列定义</h2><p>$设数列a_n及常数a, 若\forall \epsilon &gt; 0, \exists N \in Z^+,当n&gt;N时, 总有|a_n-a|&lt;\epsilon, 则称数列{a_n}的极限为a, 记作$<br>$$\lim\limits_{n\to \infty}a_n&#x3D;a或a_n \to a(n\to \infty)$$<br>$此时也称数列收敛, 否则称数列发散.$</p>
<h2 id="收敛数列的性质"><a href="#收敛数列的性质" class="headerlink" title="收敛数列的性质"></a>收敛数列的性质</h2><ul>
<li>收敛数列的极限唯一<ul>
<li>证法: 反证法.取$\epsilon &#x3D; \frac{b-a}{2}$, 当$n&gt;max{N_1, N_2}, \frac{a+b}{2} &lt; a_n &lt; \frac{a+b}{2}$, 矛盾.</li>
</ul>
</li>
<li>收敛数列必有界<ul>
<li>$\epsilon 取1, n&gt;N_1时, a-1&lt;a_n&lt;a+1. 再考虑前N_1有限项, 可知有界$</li>
<li>函数收敛无法保证前有限项</li>
<li>推论: 无界数列发散.</li>
<li>有界不一定收敛(跳跃型)</li>
<li>发散不一定无界(跳跃型)</li>
</ul>
</li>
<li>收敛数列的不等式性质<ul>
<li>$\lim a_n &lt; \lim b_n, 则\exists N, 当n&gt;N, a_n&lt;b_n$</li>
<li>反之不一定成立, 极限可能相等</li>
<li>推论: 若$a_n \geq b_n,$则$a \geq b$</li>
</ul>
</li>
<li>保号性<ul>
<li>若极限值非零, 则有连续无穷多项的符号和极限值相同</li>
<li>保号性是不等式性质的推论</li>
<li>推论: 若有连续无穷多项非负(非正), 则极限值非负(非正) (极限值可能为0).</li>
</ul>
</li>
<li>两数列极限的四则运算<ul>
<li>条件是两数列极限存在. 作为除数的极限非零.</li>
<li>推广: 有限项数列极限可进行四则运算.<ul>
<li>条件: 各项数列极限存在, 作为除数的极限非零.</li>
<li>对于分式, 调整分子分母使上下极限存在, 套用四则运算化出分子分母极限.</li>
<li>对于$\infty -\infty$型, 通分或有理化成分式.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><blockquote>
<p>改变数列的有限项, 数列的收敛性和极限不变</p>
</blockquote>
<ul>
<li>若收敛数列被改变, 设被改变的最后一项是k, 取$N&#x3D;\max(k, N_1)$, 就能维持$\epsilon-N$定义.</li>
<li>若发散数列改变有限项, 变为收敛数列, 则与上矛盾.</li>
</ul>
<h2 id="lim-limits-n-rightarrow-infty-a-n-x3D-a-epsilon-N-定义"><a href="#lim-limits-n-rightarrow-infty-a-n-x3D-a-epsilon-N-定义" class="headerlink" title="$\lim\limits_{n\rightarrow\infty} a_n&#x3D;a$ $\epsilon-N$定义"></a>$\lim\limits_{n\rightarrow\infty} a_n&#x3D;a$ $\epsilon-N$定义</h2><blockquote>
<p>$\forall \epsilon &gt;0, \exists N\in Z^*, 当n&gt;N时, 总有|a_n-a|&lt;\epsilon.$</p>
</blockquote>
<h2 id="常见数列极限"><a href="#常见数列极限" class="headerlink" title="常见数列极限"></a>常见数列极限</h2><ul>
<li>$\lim\limits_{n\rightarrow\infty} \sqrt[n]{n}&#x3D;1$<ul>
<li>分析: 令$h_n&#x3D;\sqrt[n]{n}-1&gt;0$, 难以直接由$h_n-0&lt;\epsilon$推算出$N$, 应当适当放大$h_n$. 变形得$n&#x3D;(h_n+1)^n$, 应令右边缩小并抛弃n次方. 用二项式定理展开, 最终得到$h_n&lt;某个值$.</li>
<li>证明:<br>  令$h_n&#x3D;\sqrt[n]{n}-1&gt;0$, 则<br>  $$n&#x3D;(h_n+1)^n&#x3D;1+nh_n+\frac{n(n-1)}{2}h_n^2+\cdots+h_n^n&gt;1+\frac{n(n-1)}{2}h_n^2$$<br>  $$\Rightarrow n&gt;1+\frac{n(n-1)}{2}h_n^2\Rightarrow h_n&lt;\sqrt{\frac{2}{n}}$$<br>  令$\sqrt{\frac{2}{n}}&lt;\epsilon$, 得$n&gt;\frac{2}{\epsilon^2}$<br>  $\therefore \forall \epsilon &gt;0, 取N&gt;\frac{2}{\epsilon^2}, 则当n&gt;N时,总有|\sqrt[n]{n}-1|&lt;\epsilon$.<br>  $\therefore \lim\limits_{n\rightarrow\infty} \sqrt[n]{n}&#x3D;1$</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{k\frac{1}{n}} &#x3D; 1(k&gt;0)$</li>
<li>$q^n \to 0(|q|&lt;1, n \to \infty)$<ul>
<li>分析: 若q&#x3D;0... 若q!&#x3D;0, 取n &gt; $[\frac{\ln \epsilon}{\ln |q|}]$.</li>
</ul>
</li>
<li>$\lim\limits_{n \to \infty} \sqrt[n]{a}&#x3D;1$<ul>
<li>分析: 若a&#x3D;1... 若a&gt;1, 强行$\log_a$. 若a&lt;1, 倒数.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \sqrt{n+1}-\sqrt{n} &#x3D; 0$<ul>
<li>分析: 分子有理化后, 分母缩小(适当放大法).</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{1}{n^k} &#x3D; 0(k&gt;0)$</li>
<li>$\lim\limits_{n\to \infty} \frac{n^k}{a^n} &#x3D; 0$<ul>
<li>分析: 单调有界. 求一下$\lim\limits_{n\to\infty} \frac{x_{n+1}}{x_n}$. 证明收敛后对递推式两边求极限.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{a^n}{n!} &#x3D; 0$</li>
<li>$\lim\limits_{n\to\infty} 分式: 观察最高次$</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{a_1^n+\cdots+a_m^n} &#x3D; max(a_1,\cdots,a_m), a_i&gt;0$ 下文分析</li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^k &#x3D; 1, k是任意常数$ 下文分析. <strong>这意味着不对接下来一个极限造成影响</strong></li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^n&#x3D;e(e的一个定义)$ 收敛性在下文分析</li>
<li>$\lim\limits_{n\to\infty} \frac{1}{0!}+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\cdots + \frac{1}{n!} &#x3D; e$ 夹逼准则, 课件1_2-3 22页</li>
</ul>
<h2 id="无穷大数列定义"><a href="#无穷大数列定义" class="headerlink" title="无穷大数列定义"></a>无穷大数列定义</h2><blockquote>
<p>$设数列a_n及常数a, 若\forall M &gt; 0, \exists N \in Z^+,当n&gt;N时, 总有|a_n| &gt;M, 则称数列{a_n}是无穷大数列, 或称{a_n}趋于无穷大, 记作$<br>$$\lim\limits_{n\to \infty}a_n&#x3D;\infty或a_n \to \infty(n\to \infty)$$<br>$特别地, 有正无穷大数列和负无穷大数列, 记作.\lim\limits_{n\to \infty}a_n&#x3D;+\infty或\lim\limits_{n\to \infty}a_n&#x3D;-\infty$</p>
</blockquote>
<ul>
<li>无穷大数列是发散数列(极限不存在), 是无界数列</li>
<li>发散数列不一定是无穷大数列</li>
<li>无界数列不一定是无穷大数列</li>
</ul>
<h2 id="数列极限存在的准则"><a href="#数列极限存在的准则" class="headerlink" title="数列极限存在的准则"></a>数列极限存在的准则</h2><h3 id="夹逼定理"><a href="#夹逼定理" class="headerlink" title="夹逼定理"></a>夹逼定理</h3><ol>
<li>$\lim\limits_{n\to\infty}a_n&#x3D;\lim\limits_{n\to\infty}b_n&#x3D;a$</li>
<li>$a_n\leq c_n\leq b_n(n&gt;N_0)$</li>
<li>$\Rightarrow \lim\limits_{n\to\infty}c_n&#x3D;a$</li>
</ol>
<ul>
<li>分析: 取$n&gt;max {N_0,N_1,N_2}$, 此时a_n, b_n都在邻域内, 所以夹着的c_n也在邻域内.</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$\lim\limits_{n\to\infty} n(\frac{1}{n^2+\pi}+\cdots+\frac{1}{n^2+n\pi})$<ul>
<li>分析: 分别放大缩小分母.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{a_1^n+\cdots+a_m^n} &#x3D; max(a_1,\cdots,a_m), a_i&gt;0$<ul>
<li>分析: 常数在开无穷次方根时可以忽略, 因此只挑出最大的, 缩小系数为1, 放大系数为m即可.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \frac{1}{2}\frac{3}{4}\frac{5}{6}\cdots\frac{2n-1}{2n} &#x3D; 0$<ul>
<li>分析: 大于零是显然的, 将分子平方再开方, 利用$1\cdot 3&lt;2^2$形式放大分子约分.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^k &#x3D; 1, k是任意常数$<ul>
<li>分析: k&#x3D;0时显然. k为正整数时由有限项极限四则运算可得, k为负整数时倒数. 一般地, 另m&#x3D;k向下取整, $(1+\frac{1}{n})^m \leq (1+\frac{1}{n})^k \leq (1+\frac{1}{n})^{m+1})$, 夹逼.</li>
</ul>
</li>
<li>已知$|a_{n+1}|\leq q|a_n|(n&gt;N, 0&lt;q&lt;1)$,证明数列极限为0.<ul>
<li>分析:$n\to\infty$,考虑第N+n项, 此时$0\leq|a_{N+n}|\leq q^{n-1}|a_{N+1}|\to 0$</li>
</ul>
</li>
</ul>
<h3 id="数列收敛充要条件-任一子数列都收敛且极限相等"><a href="#数列收敛充要条件-任一子数列都收敛且极限相等" class="headerlink" title="数列收敛充要条件: 任一子数列都收敛且极限相等"></a>数列收敛充要条件: 任一子数列都收敛且极限相等</h3><h4 id="子数列"><a href="#子数列" class="headerlink" title="子数列"></a>子数列</h4><ul>
<li>原数列中取无穷多项并按原有的次序排列.</li>
<li>一般约定$子数列n_k\geq k原数列$</li>
</ul>
<h4 id="充要证明"><a href="#充要证明" class="headerlink" title="充要证明"></a>充要证明</h4><ul>
<li>分析:<ul>
<li>充分性. 原数列n&gt;N时在邻域内, 则子数列取K使$n_K&gt;N$, 当k&gt;K时, $n_k&gt;n_K&gt;N$在邻域内.</li>
<li>必要性. 原数列是原数列的子数列.</li>
</ul>
</li>
</ul>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><blockquote>
<p>数列发散的充要条件是两个子数列极限存在但不相等, 或一个子数列发散.</p>
</blockquote>
<ul>
<li>设法构造易于证明的子数列. 常和三角函数周期性有关系.</li>
</ul>
<blockquote>
<p>若几个子数列的极限存在且相同, 包含的项的并集等于原数列的所有项, 则可得原数列的极限.</p>
</blockquote>
<ul>
<li>分析: 取N&gt;max{N1, N2, ...}, 任意项都在邻域内.</li>
</ul>
<h3 id="单调有界准则-单调有界数列必有极限"><a href="#单调有界准则-单调有界数列必有极限" class="headerlink" title="(单调有界准则)单调有界数列必有极限"></a>(单调有界准则)单调有界数列必有极限</h3><ul>
<li>区分严格单调和不严格单调.</li>
<li>统称单调数列.</li>
<li>分析: 由确界原理得待证极限a.</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$数列:(1+\frac{1}{n})^n收敛$<ul>
<li>分析: 单调性.均值不等式$\sqrt[n+1]{(1+\frac{1}{n})^n\cdot 1}&lt;\frac{n(1+\frac{1}{n})+1}{n+1}&#x3D;1+\frac{1}{n+1}$, 故$a_n&lt;a_{n+1}$. 有界性. 二项式展开, 各项放大剩分母阶乘, 阶乘放大到分母为2的幂, 等比求和.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{n^k}{a^n} &#x3D; 0$<ul>
<li>分析: 单调有界. 求一下$\lim\limits_{n\to\infty} \frac{x_{n+1}}{x_n}$. 证明收敛后对递推式两边求极限.</li>
</ul>
</li>
</ul>
<h4 id="单调常用方法"><a href="#单调常用方法" class="headerlink" title="单调常用方法"></a>单调常用方法</h4><ul>
<li>递推式直接看出, 或求两边极限后看出</li>
<li>作差法&#x2F;作商法, 结合上下界看出</li>
</ul>
<h4 id="有界常用方法"><a href="#有界常用方法" class="headerlink" title="有界常用方法"></a>有界常用方法</h4><ul>
<li>递推式放缩&#x2F;均值不等式, 得到界</li>
<li>符号显然</li>
</ul>
<h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>余切 $\cot x &#x3D; \frac{\cos x}{\sin x} &#x3D; \frac{1}{\tan x}$</li>
<li>正割 $\sec x &#x3D; \frac{1}{\cos x}$</li>
<li>余割 $\csc x &#x3D; \frac{1}{\sin x}$</li>
</ul>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="弦和公式"><a href="#弦和公式" class="headerlink" title="弦和公式"></a>弦和公式</h3><ul>
<li>$\sin^2 x + \cos^2 x &#x3D; 1$</li>
<li>$1 + \cot^2 x &#x3D; \csc^2 x$</li>
<li>$\tan^2 x + 1 &#x3D; \sec^2 x$</li>
</ul>
<h3 id="诱导公式"><a href="#诱导公式" class="headerlink" title="诱导公式"></a>诱导公式</h3><ul>
<li>半周期性<ul>
<li>$\sin(x+\pi) &#x3D; -\sin(x)$</li>
<li>$\cos(x+\pi) &#x3D; -\cos(x)$</li>
<li>$\tan x, \cot x最小正周期是\pi$</li>
</ul>
</li>
<li>奇偶性<ul>
<li>$\sin(-x) &#x3D; -\sin(x) 奇函数$</li>
<li>$\cos(-x) &#x3D; \cos(x) 偶函数$</li>
<li>$\tan(-x) &#x3D; -\tan(x) 奇函数$</li>
<li>$\cot(-x) &#x3D; -\cot(x) 奇函数$</li>
</ul>
</li>
<li>圆关于y轴对称性<ul>
<li>$\sin(\pi-x) &#x3D; \sin(x)$</li>
<li>$\cos(\pi-x) &#x3D; -\cos(x)$</li>
<li>$\tan, \cot的周期是\pi, 套用奇函数性质$</li>
</ul>
</li>
<li>直角加<ul>
<li>$\sin(\pi&#x2F;2+x) &#x3D; \cos x$</li>
<li>$\cos(\pi&#x2F;2+x) &#x3D; -\sin x$</li>
<li>$\tan(\pi&#x2F;2+x) &#x3D; -\cot x$</li>
<li>$\cot(\pi&#x2F;2+x) &#x3D; -\tan x$</li>
</ul>
</li>
<li>直角减(余角)<ul>
<li>$\sin(\pi&#x2F;2-x) &#x3D; \cos x$</li>
<li>$\cos(\pi&#x2F;2-x) &#x3D; \sin x$</li>
<li>$\tan(\pi&#x2F;2-x) &#x3D; \cot x$</li>
<li>$\cot(\pi&#x2F;2-x) &#x3D; \tan x$</li>
</ul>
</li>
<li>倍角公式<ul>
<li>$\sin2x &#x3D; 2\sin x\cos x$</li>
<li>$\cos2x &#x3D; \cos^2 x - \sin^2 x$</li>
<li>$\tan2x &#x3D; \frac{2\tan x}{1-\tan^2x}$</li>
</ul>
</li>
<li>半角公式<ul>
<li>来源<br>  $$ \cos 2x &#x3D; 2 \cos^2 x-1 &#x3D; 1-2\sin^2 x $$</li>
<li>$\cos^2 \frac{x}{2} &#x3D; \frac{1+\cos x}{2}$</li>
<li>$\sin^2 \frac{x}{2} &#x3D; \frac{1-\cos x}{2}$</li>
<li>$\tan \frac{x}{2} &#x3D; \frac{\sin \frac{x}{2}}{\cos \frac{x}{2}}_{(同乘凑倍角)} &#x3D;\frac{\sin x}{1+ \cos x} &#x3D; \frac{1-\cos x}{\sin x}$</li>
</ul>
</li>
<li>万能公式<ul>
<li>$\sin x &#x3D; \sin(2\frac{x}{2}) &#x3D; 2\sin\frac{x}{2}\cos\frac{x}{2} &#x3D; \frac{2\tan \frac{x}{2}}{\sec^2\frac{x}{2}}&#x3D;\frac{2\tan \frac{x}{2}}{1+\tan^2 \frac{x}{2}}$</li>
<li>$\cos x &#x3D; \sin(2\frac{x}{2}) &#x3D; \cos^2\frac{x}{2} - \sin^2\frac{x}{2} &#x3D; \frac{1-\tan^2\frac{x}{2}}{1+\tan^2\frac{x}{2}}$</li>
<li>$\tan x &#x3D; \frac{2\tan\frac{x}{2}}{1-\tan^2\frac{x}{2}}$</li>
</ul>
</li>
<li>积化和差<ul>
<li>用$\sin(a \pm b)$凑$\sin\cdot \cos$</li>
<li>用$\cos(a \pm b)$凑$\sin \cdot\sin, \cos\cdot \cos.$</li>
<li>$\sin a \cos b &#x3D; \frac{1}{2}(\sin(a+b)+\sin(a-b))$</li>
<li>$\cos a \sin b &#x3D; \frac{1}{2}(\sin(a+b)-\sin(a-b))$</li>
<li>$\cos a \cos b &#x3D; \frac{1}{2}(\cos(a+b)+\cos(a-b))$</li>
<li>$\sin a \sin b &#x3D; -\frac{1}{2}(\cos(a+b)-\cos(a-b))$</li>
</ul>
</li>
<li>和差化积<ul>
<li>$a&#x3D;\frac{a+b}{2}+\frac{a-b}{2}$</li>
<li>$b&#x3D;\frac{a+b}{2}-\frac{a-b}{2}$</li>
<li>$\sin a + \sin b &#x3D; 2\sin\frac{a+b}{2}\cos\frac{a-b}{2}$</li>
<li>$\sin a - \sin b &#x3D; 2\cos\frac{a+b}{2}\sin\frac{a-b}{2}$</li>
<li>$\cos a + \cos b &#x3D; 2\cos\frac{a+b}{2}\cos\frac{a-b}{2}$</li>
<li>$\cos a - \cos b &#x3D; -2\sin\frac{a+b}{2}\sin\frac{a-b}{2}$</li>
<li>帅+帅&#x3D;帅哥</li>
<li>帅-帅&#x3D;哥帅</li>
<li>哥+哥&#x3D;哥哥</li>
<li>哥-哥&#x3D;负嫂嫂</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="无穷小量"><a href="#无穷小量" class="headerlink" title="无穷小量"></a>无穷小量</h2><ul>
<li>对任意eps&gt;0, 存在delta去心邻域, 使$|f(x)|&lt;eps$. 无穷小量是一个变量 </li>
<li>无穷小是极限为零的函数</li>
<li>无穷小可能在某邻域为0</li>
<li>0是唯一一个可视作无穷小的常熟</li>
</ul>
<h3 id="函数极限与无穷小量"><a href="#函数极限与无穷小量" class="headerlink" title="函数极限与无穷小量"></a>函数极限与无穷小量</h3><ul>
<li>（定理）$x \to x_0$,f(x)极限为A$\Leftrightarrow f(x)&#x3D;A+a(x)$, a(x)为无穷小量</li>
</ul>
<h3 id="无穷小阶的比较"><a href="#无穷小阶的比较" class="headerlink" title="无穷小阶的比较"></a>无穷小阶的比较</h3><ul>
<li>$\lim\limits_{x \to x_0^+} \frac{f(x)}{(x-x_0)^k} &#x3D; c \neq 0$,则当$x \to x_0$时,f(x)是$(x-x_0)$的k阶无穷小.</li>
<li>特殊的无穷小量<ul>
<li>$x \to 0, f(x),g(x)是无穷小量,且f(x)&#x3D;(x+1)g(x), 则f(x) \sim g(x)$, 尽管他们最高次数不相同</li>
<li>最高次数不同而等价, 意味着相乘不改变等价性, 但相加会改变等价性.</li>
<li>具体例子:$f(x)&#x3D;x^3-x \sim x^2-x, g(x)&#x3D;x, f(x)+g(x)&#x3D;x^3, 但x^2-x+x&#x3D;x^2不等价于x^3$</li>
<li>同阶与否与最高次数无关, 一切判定以比值为准.</li>
</ul>
</li>
</ul>
<h3 id="常用的等价无穷小量"><a href="#常用的等价无穷小量" class="headerlink" title="常用的等价无穷小量"></a>常用的等价无穷小量</h3><h4 id="x-to-0-时"><a href="#x-to-0-时" class="headerlink" title="$x \to 0$时"></a>$x \to 0$时</h4><ul>
<li>$\sin x \sim x$</li>
<li>$\tan x \sim x$</li>
<li>$1 - \cos x \sim \frac{1}{2}x$</li>
<li>$\sqrt[n]{1+x}-1 \sim \frac{1}{n}x$ (n为正整数)(注意是加号)</li>
<li>$\arcsin x \sim x, (u&#x3D;\arcsin x)$</li>
<li>$\arctan x \sim x$</li>
<li>$\ln(1+x) \sim x, (\lim \ln(1+x)^{\frac{1}{x}})$</li>
<li>$e^x-1 \sim x, (u&#x3D;e^x-1, \lim \frac{u}{\ln(1+u)})$</li>
<li>$a^x-1 \sim x\ln a, (\lim \frac{e^{x\ln a}-1}{x}&#x3D;\lim \frac{x\ln a}{x} &#x3D; \ln a), a &gt; 0$</li>
<li>$(1+x)^a-1 \sim ax, (\lim \frac{(1+x)^a-1}{x}&#x3D;\lim \frac{e^{a \ln (1+x)}-1}{x} &#x3D; \lim \frac{a \ln (1+x)}{x} &#x3D; a), a \neq 0$</li>
<li>x可以用其他函数替代，只要趋向于0即可</li>
</ul>
<h3 id="常用变换"><a href="#常用变换" class="headerlink" title="常用变换"></a>常用变换</h3><ul>
<li>$\lim \limits_{x \to 0} (1-x)^{\frac {1}{x}} &#x3D; \frac{1}{e}$</li>
<li>$\sin x + x^2&#x3D;x(\frac{\sin x}{x} + x)$</li>
<li>$\tan x - \sin x &#x3D; \tan x(1- \cos x)$</li>
<li>$a^x &#x3D; e^{x \ln a}$ (留意后面有没有-1配合等价无穷小替换)</li>
<li>$x^a &#x3D; e^{a \ln x}$</li>
<li>在$x \to \infty, 求\lim e^{f(x)g(x)}, 留意最高次相同\Rightarrow 系数比$</li>
<li>$\lim \limits_{n \to \infty} (\frac{\sqrt[n]{a_1}+\cdots +\sqrt[n]{a_m}}{m}-1)n &#x3D; \lim \limits_{x \to 0} (\frac{a_1^x+\cdots + a_m^x}{m}-1)\frac{1}{x} &#x3D; \lim \limits_{x \to 0} \frac{x\ln a_1 + \cdots + x\ln a_m}{mx} &#x3D; \ln \sqrt[m]{a_1 \cdots a_m}, m是正整数, 归结准则$</li>
<li>次方相同, 底数不同,强行同除?!<blockquote>
<p>求$\lim \limits_{x \to 0} \frac{(1+x)^\frac{1}{x}+(1+2x)^\frac{1}{2x}}{\sin x} &#x3D; \frac{e}{2}$</p>
</blockquote>
</li>
<li>求极限的最后, 有界量(尤其与$\sin\infty$,$\cos \infty$有关)乘无穷小量等于无穷小量</li>
</ul>
<h3 id="无穷小量阶数的性质"><a href="#无穷小量阶数的性质" class="headerlink" title="无穷小量阶数的性质"></a>无穷小量阶数的性质</h3><ul>
<li>$o(x^n)+o(x^m) &#x3D; o(x^m), x \to 0, n&gt;m&gt;0$</li>
<li>$o(x^n) \cdot o(x^m) &#x3D; o(x^{n+m}), x \to 0$</li>
<li>无穷小量相加，高阶丢失，保留低阶.</li>
<li>无穷小量相乘，阶数相加.</li>
<li>无穷小量$o(高阶)&#x3D;o(低阶)$是正确的.</li>
<li>无穷小量可以写成$f(x)&#x3D;g(x)+o(x^2)$, 求极限时设法出现$\frac {o(x^2)}{kx^2}$即可消去</li>
</ul>
<h2 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h2><ul>
<li>证明$x \to 0, f(x) &#x3D; g(x)+o(h(x))$<blockquote>
<p>计算$\lim\limits_{x \to 0}\frac{f(x)-g(x)}{h(x)} &#x3D; 0$</p>
</blockquote>
</li>
<li>证明函数是无穷小量<blockquote>
<p>证明函数极限为0</p>
</blockquote>
</li>
<li>证明函数是无节量<blockquote>
<p>对任意M&gt;0,找到$|f(x)| &gt; M$</p>
</blockquote>
</li>
</ul>
<h2 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h2><ul>
<li>对任意M&gt;0，存在空心邻域(x0, $\delta$), 使$|f(x)| &gt;M$, 则f(x)是在$x \to x0$时的无穷大量</li>
<li>无穷大量不是一个很大的数</li>
<li>无穷大量的极限不存在</li>
</ul>
<h3 id="无穷大量与无穷小量的关系"><a href="#无穷大量与无穷小量的关系" class="headerlink" title="无穷大量与无穷小量的关系"></a>无穷大量与无穷小量的关系</h3><ul>
<li>无穷大量的倒数量是无穷小量</li>
<li>若无穷小量恒不为零,则该无穷小量的倒数量为无穷大量</li>
</ul>
<h2 id="等价量"><a href="#等价量" class="headerlink" title="等价量"></a>等价量</h2><ul>
<li>不论无穷大或无穷小, 只要$\lim\limits_{x \to x_0} \frac{f(x)}{g(x)}&#x3D;1$, 就称$当x \to x_0时,f(x)与g(x)是等价的量, 记作f(x) \sim g(x), (x \to x_0)$</li>
<li>g(x)可以是不为零的常数.故可以有$f(x)~A, (A \neq 0)$</li>
<li>函数等价于零无意义</li>
<li>极限相等是等价的非必要非充分条件(可能两函数的极限都不存在, 另外还需要同阶)</li>
</ul>
<h3 id="等价量替换定理"><a href="#等价量替换定理" class="headerlink" title="等价量替换定理"></a>等价量替换定理</h3><ul>
<li>若函数分别等价,且$\lim \frac{f&#39;(x)g&#39;(x)}{h&#39;(x)}&#x3D;A$, 则$\lim \frac{f(x)g(x)}{h(x)} &#x3D; \lim \frac{f&#39;(x)g&#39;(x)}{h&#39;(x)}&#x3D;A$<ul>
<li>两项相加不能直接使用等价量替换</li>
<li>可以使用$\lim f(x)+g(x) &#x3D; \lim f(x) + \lim g(x) &#x3D; \lim f&#39;(x) + \lim g&#39;(x) &#x3D; \lim f&#39;(x)+g&#39;(x)$, 这里要求各函数极限都存在.</li>
<li>常用极限值(常数)可以代入, 但不保证顺利计算出极限.</li>
</ul>
</li>
</ul>
<h2 id="给函数极限-求参数"><a href="#给函数极限-求参数" class="headerlink" title="给函数极限, 求参数"></a>给函数极限, 求参数</h2><ul>
<li>求等价量,确定参数</li>
<li>直接移项得出$常数&#x3D;\lim g(x)&#x3D;A$</li>
</ul>
<h1 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>设$y&#x3D;f(x)$在$x$的某邻域$U(x)$内有定义，若$\Delta y &#x3D; f(x+ \Delta x)-f(x)$可表示为<br>$$<br>\Delta y &#x3D; A\Delta x + o(\Delta x) \quad (\Delta \rightarrow 0),<br>$$<br>其中$A$是与$\Delta x$无关的量，则称$y&#x3D;f(x)$在点$x$处可微. $A\Delta x$是$\Delta y$的线性主部，并称其为$y&#x3D;f(x)$在点$x$处的微分，记为$dy, dy &#x3D; A\Delta x$。</p>
</blockquote>
<h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1><h2 id="变上下限积分的求导公式"><a href="#变上下限积分的求导公式" class="headerlink" title="变上下限积分的求导公式"></a>变上下限积分的求导公式</h2><p>d s^b(y)_a(y) &#x3D;  f(b(y))b&#39;(y) - f(a(y))a&#39;(y)</p>
<p>[toc]</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2019/08/20/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="求-L-R-中满足-y-geq-x-且y-mod-x-x3D-x-oplus-y-的数对-x-y-的个数"><a href="#求-L-R-中满足-y-geq-x-且y-mod-x-x3D-x-oplus-y-的数对-x-y-的个数" class="headerlink" title="求$[L,R]$中满足$y\geq x,且y\mod x&#x3D;x\oplus y$的数对$(x,y)$的个数"></a>求$[L,R]$中满足$y\geq x,且y\mod x&#x3D;x\oplus y$的数对$(x,y)$的个数</h2><span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>题目涉及位操作，对所有数以二进制看待。x和y的最高位应相同，这是因为$y\mod x&lt;x$，其二进制最高位有限制。</li>
<li>两数最高位相同，则y不超过x的两倍。$y\mod x &#x3D; y-x &#x3D; y\oplus x$。</li>
<li>$y-x$不可能退位。由$y\geq x$找到两者不同的最高位（y一定是1，x一定是0），这一位异或和为1，若低位退位，则差为0，矛盾，故低位不能退位。由低位不能退位，分类讨论$1-0, 1-1, 0-0$三种情况，发现更低位也不能退位，由归纳法可知$y-x$不可能退位。</li>
<li>综上，以bitset看待，$x\subseteq y$。</li>
<li>考虑记忆化搜索。$x,y$都受到上下界限制，且$y\geq x$，故分别dp枚举$x,y$的合法取值。另外要记录状态保证$x,y$的最高位相同。</li>
</ol>
<p>$$<br>设f[pos][xDown][xUp][yUp][lead]\<br>表示第pos位之后，x是否压下界，x是否压上界，y是否压上界，xy是否取过最高位时的合法方案数<br>$$</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ULL <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> xDown, <span class="type">bool</span> xUp, <span class="type">bool</span> yUp, <span class="type">bool</span> lead)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ULL &amp;res = ans[pos][xDown][xUp][yUp][lead];</span><br><span class="line">	<span class="keyword">if</span> (res != <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> xLow = xDown ? L[pos] : <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> xHigh = xUp ? R[pos] : <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> yHigh = yUp ? R[pos] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=xLow; i&lt;=xHigh; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;=yHigh; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lead &amp;&amp; i!=j) <span class="keyword">continue</span>;</span><br><span class="line">			res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>, xDown&amp;&amp;i==xLow, xUp&amp;&amp;i==xHigh, yUp&amp;&amp;j==yHigh, lead&amp;&amp;i==<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res %= MOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化DP</title>
    <url>/2019/08/25/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="单状态的斜率优化"><a href="#单状态的斜率优化" class="headerlink" title="单状态的斜率优化"></a>单状态的斜率优化</h2><p>写出状态转移方程，形如：<br>$$ f[j]&#x3D;\max_{i&#x3D;1}^{j-1} { F_1(j)+F_2(i)+F_3(i,j)} $$<br>由于$F_3$涉及i和j，若枚举两个变量会超时。</p>
<p>化简方程，得到</p>
<span id="more"></span>
<p>$$ f[j]&#x3D;\max_{i&#x3D;1}^{j-1} {F_2(i)+F_4(j)*F_5(i) } + const(j) $$</p>
<p>这里涉及的每个函数都能事先算出。于是求最大值转化为线性规划：将$f[j]$看作b，$F_2(i)$看作y，$-F_4(j)$看作k，$F_5(i)$看作x，则形式可转化为$b&#x3D;y-kx$，求b的最大值。维护可能的点队列，则这是一条上凸线，用二分找到最相近斜率的线段的对应点即可。</p>
<p>某些题目的$F_4(j)$具有单调性，即目标直线的斜率有单调性，则可用朴素单调队列代替二分。</p>
<p>也可以将max改成min，这时求最小的b，维护下凸线即可。</p>
<h2 id="双状态的斜率优化"><a href="#双状态的斜率优化" class="headerlink" title="双状态的斜率优化"></a>双状态的斜率优化</h2><p>拓展单状态下的方程，形如：<br>$$ f(j,k]&#x3D;\max_{i&#x3D;1}^{j} { F_1(j,k]+F_2(i,j]+F_3(i,j,k)} $$<br>同样化简方程，得到<br>$$ f(j,k]&#x3D;\max_{i&#x3D;1}^{j} { F_2(i,j]+F_4(i)*F_5(j,k]} + const(j,k]$$<br>类似地令$F_4(i)$为横坐标x，待求的$f(j,k]$看作截距b，$F_2(i,j]$看作纵坐标y构建线性规划。之后的步骤同上。</p>
<p>斜率优化的目的是减少枚举前驱状态的时间，用O(1)或O(log n)完成状态转移。这将要求在完成状态计算后，将新获得的点加入凸线中。加点后，视情况选择是否维护凸性。<br>对于双状态的题目，不同的j对应不同的凸线（这是因为$F_2(i,j]$会随j变化，即点的坐标会变化）。应当判断对于同一个j、不同的k，能否从同一条凸线得到答案。</p>
<p>如果加点操作的横坐标具有非单调性，可能需要数据结构支持二分查找、中间加点、中间删点的操作。如果不需要即时维护，可以用排序完成维护。</p>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>在ACM中使用C++</title>
    <url>/2019/08/28/%E5%9C%A8ACM%E4%B8%AD%E4%BD%BF%E7%94%A8C/</url>
    <content><![CDATA[<p>今天又双叒叕来水博客了……（不务正业）</p>
<h1 id="令人尖叫的STL"><a href="#令人尖叫的STL" class="headerlink" title="令人尖叫的STL"></a>令人尖叫的STL</h1><h2 id="algorithm-系列"><a href="#algorithm-系列" class="headerlink" title="algorithm 系列"></a><strong>algorithm</strong> 系列</h2><h3 id="fill-fill-n-填充数组"><a href="#fill-fill-n-填充数组" class="headerlink" title="fill, fill_n 填充数组"></a><strong>fill</strong>, <strong>fill_n</strong> 填充数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a, a+n, INF);</span><br><span class="line"><span class="built_in">fill_n</span>(a, n, INF);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="unique-unique-copy-对排序后数组去重"><a href="#unique-unique-copy-对排序后数组去重" class="headerlink" title="unique, unique_copy 对排序后数组去重"></a><strong>unique</strong>, <strong>unique_copy</strong> 对排序后数组去重</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a+n);</span><br><span class="line"><span class="built_in">unique_copy</span>(a, a+n, b, 重载==);</span><br><span class="line"><span class="built_in">unique</span>(a, a+n, 重载==);</span><br></pre></td></tr></table></figure>

<h3 id="reverse-reverse-copy-镜像翻转数组"><a href="#reverse-reverse-copy-镜像翻转数组" class="headerlink" title="reverse, reverse_copy 镜像翻转数组"></a><strong>reverse</strong>, <strong>reverse_copy</strong> 镜像翻转数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse_copy</span>(a, a+n, b);</span><br><span class="line"><span class="built_in">reverse</span>(a, a+n);</span><br></pre></td></tr></table></figure>

<h3 id="rotate-rotate-copy-数组轮换"><a href="#rotate-rotate-copy-数组轮换" class="headerlink" title="rotate, rotate_copy 数组轮换"></a><strong>rotate</strong>, <strong>rotate_copy</strong> 数组轮换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">rotate_copy</span>(a, a+<span class="number">2</span>, a+<span class="number">6</span>, b); <span class="comment">// b == &#123;3, 4, 5, 6, 1, 2&#125;</span></span><br><span class="line"><span class="built_in">rotate</span>(a, a+<span class="number">5</span>, a+<span class="number">6</span>); <span class="comment">// a == &#123;6, 1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle-随机打乱数组"><a href="#random-shuffle-随机打乱数组" class="headerlink" title="random_shuffle 随机打乱数组"></a><strong>random_shuffle</strong> 随机打乱数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">random_shuffle</span>(a, a+n);</span><br></pre></td></tr></table></figure>

<h3 id="partial-sort-数组一次性取前k小"><a href="#partial-sort-数组一次性取前k小" class="headerlink" title="partial_sort 数组一次性取前k小"></a><strong>partial_sort</strong> 数组一次性取前k小</h3><p>时间复杂度$n \log m$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(a, a+k, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="partition-partition-copy-元素分成两组"><a href="#partition-partition-copy-元素分成两组" class="headerlink" title="partition, partition_copy 元素分成两组"></a><strong>partition</strong>, <strong>partition_copy</strong> 元素分成两组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point* mid = <span class="built_in">partition</span>(p, p+n, [o1, o2](<span class="type">const</span> Point&amp; a) &#123;</span><br><span class="line">        <span class="built_in">return</span> (o2-o1).<span class="built_in">det</span>(a-o1) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 以直线(o1, o2)为界将平面上的点划分成两组</span></span><br></pre></td></tr></table></figure>
<p>还有<code>stable_partition</code>版本</p>
<h3 id="merge-inplace-merge-归并数组"><a href="#merge-inplace-merge-归并数组" class="headerlink" title="merge, inplace_merge 归并数组"></a><strong>merge</strong>, <strong>inplace_merge</strong> 归并数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求分别有序</span></span><br><span class="line"><span class="built_in">merge</span>(a, a+aLen, b, b+bLen, c, 重载&lt;); <span class="comment">// 非原地合并</span></span><br><span class="line"><span class="built_in">inplace_merge</span>(a, a+mid+<span class="number">1</span>, a+aLen, 重载&lt;); <span class="comment">// 原地合并</span></span><br></pre></td></tr></table></figure>

<h3 id="equal-range-找到存在区间"><a href="#equal-range-找到存在区间" class="headerlink" title="equal_range 找到存在区间"></a><strong>equal_range</strong> 找到存在区间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a+n);</span><br><span class="line"><span class="comment">// 等价于使用lower_bound和upper_bound</span></span><br><span class="line">pair&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; bounds = <span class="built_in">equal_range</span>(a, a+n, <span class="number">10</span>, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="make-heap-O-n-建堆"><a href="#make-heap-O-n-建堆" class="headerlink" title="make_heap O(n)建堆"></a><strong>make_heap</strong> O(n)建堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_heap</span>(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="sort-heap-对堆排序"><a href="#sort-heap-对堆排序" class="headerlink" title="sort_heap 对堆排序"></a><strong>sort_heap</strong> 对堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_heap</span>(a, a+n, 重载&lt;);</span><br><span class="line"><span class="built_in">sort_heap</span>(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="push-heap-堆加入一个元素"><a href="#push-heap-堆加入一个元素" class="headerlink" title="push_heap 堆加入一个元素"></a><strong>push_heap</strong> 堆加入一个元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[n++] = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">push_heap</span>(a, a+n, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="pop-heap-堆删除顶端元素"><a href="#pop-heap-堆删除顶端元素" class="headerlink" title="pop_heap 堆删除顶端元素"></a><strong>pop_heap</strong> 堆删除顶端元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pop_heap</span>(a, a+n--, 重载&lt;);</span><br></pre></td></tr></table></figure>

<h3 id="lexicographical-compare-字典序小于"><a href="#lexicographical-compare-字典序小于" class="headerlink" title="lexicographical_compare 字典序小于"></a><strong>lexicographical_compare</strong> 字典序小于</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">lexicographical_compare</span>(s1, s1+len1, s2, s2+len2))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="next-permutation-prev-permutation-求下一排列"><a href="#next-permutation-prev-permutation-求下一排列" class="headerlink" title="next_permutation, prev_permutation 求下一排列"></a><strong>next_permutation</strong>, <strong>prev_permutation</strong> 求下一排列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">prev_permutation</span>(a, a+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">next_permutation</span>(a, a+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Containers-系列"><a href="#Containers-系列" class="headerlink" title="Containers 系列"></a><strong>Containers</strong> 系列</h2><p><em>用到烂的知识点就不多提了。这里只写容易忘的。</em></p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a><strong>bitset</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>bitset&lt;size_t N&gt; foo(int);</code></li>
<li><code>bitset&lt;size_t N&gt; foo(std::string);</code></li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>长度在编译期确定</li>
<li>高位在左，低位在右</li>
<li>重载的方括号可以直接读取、操作位</li>
</ol>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li><code>size_t count()</code> 返回1的个数</li>
<li><code>bool test(size_t pos)</code> 返回非引用的<code>foo[pos]</code></li>
<li><code>bool any()</code> 是否有1</li>
<li><code>bool none()</code> 是否全0</li>
<li><code>bool all()</code> 是否全1</li>
<li><code>bitset&amp; set()</code>  全部位设置为1</li>
<li><code>bitset&amp; set(size_t pos, bool val=true)</code> 设置某个位</li>
<li><code>bitset&amp; reset()</code> 全部设置为0  （也可有参数pos）</li>
<li><code>bitset&amp; flip()</code> 反转全部位  （也可有参数pos）</li>
<li><code>string to_string(char zero, char one)</code> 按要求转化为string</li>
<li><code>unsigned long to_ulong()</code> 转化为UL</li>
<li><code>ULL to_ullong</code> 转化为ULL （C++11）</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>map&lt;type1, type2&gt; mymap;</code></li>
<li><code>map&lt;type1, type2&gt; mymap(&#123;&#125;)</code></li>
</ol>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部用平衡树实现</li>
<li>不允许重复的Key</li>
<li>访问必须用迭代器 <code>map&lt;type1, type2&gt;::iterator it;</code></li>
<li><code>it-&gt;first</code> 是Key，不可更变，<code>it-&gt;second</code> 是Value，可以修改。</li>
<li>查找元素必须用<code>it = mymap.find(Key)</code>，失败则返回<code>mymap.end();</code></li>
</ol>
<h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>重载方括号，若Key不存在则建立Key对应的默认构造Value。返回Value的引用。</li>
<li><code>insert()</code> 比较复杂，常用例子：<code>mp.insert(pair&lt;char, int&gt;(&#39;a&#39;, 1));</code></li>
<li><code>iterator begin()</code> 指向头元素的迭代器 （rbegin()指向最后一个元素）</li>
<li><code>iterator end()</code> 指向尾元素的后一个迭代器（rend()指向头元素的前一个迭代器）</li>
<li><code>iterator find(Key)</code> 返回Key对应的迭代器，失败则返回end()。</li>
<li><code>clear()</code> 清空所有键值对，size归零。</li>
<li><code>size_type erase (const key_type&amp; k);</code> 删除Key对应的键值对，返回删除个数</li>
<li><code>iterator erase (const_iterator position);</code> 删除迭代器指向的键值对，返回紧接下一个键值对的迭代器。</li>
<li><code>iterator erase (const_iterator first, const_iterator last);</code> 删除迭代器指向的左闭右开区间的键值对，返回紧接着下一个键值对的迭代器（或<code>end()</code>）。</li>
<li>注意，C++98中<code>erase()</code>不会返回迭代器，而是返回void</li>
<li><code>iterator lower_bound (const key_type&amp; k);</code> 所在上界迭代器</li>
<li><code>iterator upper_bound (const key_type&amp; k);</code> 所在下界迭代器</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><p>结点只有一个元素，不允许重复的红黑树。</p>
<h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>迭代器begin(), end(), rbegin(), rend().</li>
<li>容量empty(), size();</li>
<li>插入<ul>
<li><code>pair&lt;iterator, bool&gt; insert(const value_type&amp; val);</code> 同时有非const的右值引用版本。</li>
<li>返回的pair包括一个指向被插入值的迭代器，bool指明是否真的发生了插入操作。（如果元素被来就存在，就为false）</li>
</ul>
</li>
<li>删除<ul>
<li><code>iterator erase(const_iterator position);</code> 删除指定迭代器位置的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>iterator erase(const_iterator first, cosnt_iterator last);</code> 删除指定迭代器的左闭右开区间的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>size_type erase(const value_type&amp; val);</code> 删除指定的值。 返回被删除的元素个数（0或1）。</li>
</ul>
</li>
<li>交换 <code>swap(set&amp; x);</code> 交换两个类型相同的set。</li>
<li>清空 <code>clear();</code></li>
<li>查找 <code>iterator find(const value_type&amp; val);</code></li>
<li>计数 <code>size_type count(const value_type&amp; val) const;</code></li>
<li>上下界（左闭右开）<ul>
<li><code>iterator lower_bound (const value_type&amp; val);</code></li>
<li><code>iterator upper_bound (const value_type&amp; val);</code></li>
<li><code>pair&lt;iterator,iterator&gt; equal_range (const value_type&amp; val);</code> 包括了下界和上界。</li>
</ul>
</li>
</ol>
<h2 id="C标准库-系列"><a href="#C标准库-系列" class="headerlink" title="C标准库 系列"></a><strong>C标准库</strong> 系列</h2><h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a><strong>assert</strong> 断言</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;ch[<span class="number">0</span>]-&gt;fa == <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;ch[<span class="number">1</span>]-&gt;fa == <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="comment">// NDEBUG 标记可删除assert</span></span><br></pre></td></tr></table></figure>

<h3 id="isdigit-判断字符是否十进制数"><a href="#isdigit-判断字符是否十进制数" class="headerlink" title="isdigit 判断字符是否十进制数"></a><strong>isdigit</strong> 判断字符是否十进制数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=<span class="built_in">getchar</span>()))</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) minus = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h1 id="泯灭人性的数据类型"><a href="#泯灭人性的数据类型" class="headerlink" title="泯灭人性的数据类型"></a>泯灭人性的数据类型</h1><h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节数</th>
<th align="center">估计范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">±2e9</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">±3e4</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">1</td>
<td align="center">保有127</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">37数量级，7位</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">307数量级，15位</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">16</td>
<td align="center">4931数量级，20位</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">8</td>
<td align="center">9e18</td>
</tr>
<tr>
<td align="center">__int128_t</td>
<td align="center">16</td>
<td align="center">8.5e37</td>
</tr>
</tbody></table>
<blockquote>
<p>计算struct内存时要小心！最好使用<code>sizeof</code>的方式计算内存。</p>
</blockquote>
<h2 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf"></a>scanf和printf</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unsigned int</td>
<td align="center">%u %o(8进制) %x(16进制)</td>
</tr>
<tr>
<td align="center">unsigned long long</td>
<td align="center">%llu</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">入%lf，出%f</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">%Lf</td>
</tr>
<tr>
<td align="center">__int128_t</td>
<td align="center">不可用</td>
</tr>
</tbody></table>
<h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><p>gets()已经被删除。</p>
<p>读入int之类的操作不会吃掉行末，这会导致下一个<code>getline(st, size)</code>得到空串。</p>
<p>保险起见，应当自定义读入行。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-树形结构区分</title>
    <url>/2016/06/15/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%8C%BA%E5%88%86/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><ul>
<li>每个结点有随机的优先级，使树满足优先级树（堆）的性质，其余是普通排序二叉树</li>
<li>旋转：<ul>
<li><strong>参数是子树根(引用子树根的儿子指针，否则要改一系列父子指针)</strong> ，旋转 即是 <strong>沉降</strong>，另一边的孩子上升，但该孩子可能丢失一个子树。</li>
<li><strong>引用原子树根</strong>可方便修改父亲指向自己的指针。</li>
<li>总是<strong>因为查找才会引发旋转</strong>，所以旋转参数总是引用。</li>
<li>没有返回值，因为新子树根就是父亲的儿子指针。</li>
<li>记得维护其他数据域。</li>
</ul>
</li>
<li>插入：<ul>
<li><strong>自带查找</strong></li>
<li>新结点分配随机优先级，像排序二叉树一样<strong>插到一个叶子</strong>上（每个结点有计数器，可节省插入相同结点），然后旋转维护优先级树。</li>
<li>递归地写，<strong>insert()后判断</strong>一下是否需要leftRotate() &#x2F; rightRotate()。</li>
</ul>
</li>
<li>删除：<ul>
<li><strong>自带查找</strong></li>
<li>找到待删除结点，<strong>修改计数器（当且仅当计数器大于1！）</strong>。如果计数器就是1，就要将自己旋到外结点（没有儿子或有一个儿子），轻松自杀。</li>
<li><strong>引用root</strong>可以方便删掉父亲指向自己的指针。</li>
<li>另一种删除方法：参考普通排序二叉树的删除，但优先级不能被拷贝。非递归地写能优化时间。</li>
</ul>
</li>
<li>查找：<ul>
<li>和一般的二叉排序树一样。</li>
<li>返回值可以写成<strong>地址引用？</strong></li>
</ul>
</li>
<li>分离：<ul>
<li>依赖于size，将树分离为两个指定大小的树。</li>
<li>先找到割边，强行加入一个虚拟结点（优先级为无限大），旋转到根，这时左右子树已经被分离。</li>
</ul>
</li>
<li>合并：<ul>
<li>合并和分离相反。要求其中一棵treap的所有结点小于另一棵。</li>
<li>强行加入一个虚拟结点作为根（优先级为无限小），连接两棵treap，然后删除虚拟结点。</li>
</ul>
</li>
</ul>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><ul>
<li>拥有将某一个结点旋转到根的操作Splay(&amp;root, const x)，并在大多数操作中主动调用splay()</li>
<li>新建结点newNode(const v, const father &#x3D; 0)<ul>
<li>返回地址</li>
</ul>
</li>
<li>旋转：<ul>
<li>因为splay()旋转涉及很多代结点，不能用引用简化代码，必须存父亲指针。对应的孩子指针、父亲指针必须成对修改。</li>
<li><strong>参数是被旋转子树根的孩子</strong>，先处理祖先的孩子指针，再处理孩子的父亲指针，最后处理被旋转的两个结点的指针。“上有老 下有小 求放过...”</li>
<li>可能会导致<strong>splay树根的改变</strong>，但是只有splay()导致旋转，splay()中自带根的记录。</li>
<li>没有返回值，因为地址对应的内容没有变。</li>
</ul>
</li>
<li>Splay(&amp;root, const x)：<ul>
<li>参数root是splay树根，x是结点地址。<strong>root必须引用</strong>，因为splay操作会更改树根。</li>
<li><strong>所有包含splay()的函数</strong>都要引用root</li>
<li>依赖于祖先两代。若x仅有父亲而没有祖父，相应地旋转就好了。<strong>如果x有祖父，而且三点“共线”，就要先旋转父亲</strong>，后旋转x；如果三点不“共线”，正常地做就好。</li>
</ul>
</li>
<li>插入(&amp;root, const v)<ul>
<li><strong>自带查找</strong></li>
<li>先判根，然后开始循环</li>
<li>保存父亲y，引用孩子x，若x&#x3D;&#x3D;0 则 x&#x3D;newNode</li>
<li>因为插入包含了splay()，所以要带引用root。</li>
</ul>
</li>
<li>删除(&amp;root, const v)：<ul>
<li><strong>自带查找</strong></li>
<li>因为删除包含了splay()，所以要带<strong>引用root</strong>。</li>
<li>如果被删结点是<strong>外结点</strong>，轻松自杀，splay()替身或者splay()父亲。</li>
<li>如果被删结点不是外结点，那么被删结点肯定有前驱和后继<strong>在子树上</strong>，任取一个代替自己，然后splay()自己</li>
</ul>
</li>
<li>前驱后继(&amp;root const v) &#x2F; (&amp;root const x)<ul>
<li><strong>将x旋到根</strong>，前驱就是左子树的最右结点，后继就是右子树的最左结点。</li>
<li>因为包含了splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li>有序合并join(&amp;s1, s2)：<ul>
<li>将s1的最大元素splay到根，然后将s2设为s1的右子树</li>
<li>因为含有splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li>无序合并Merge(s1, s2)：<ul>
<li><strong>依赖于额外数据域size</strong></li>
<li>遍历size小的splay树，逐个插入到另一颗splay树上</li>
</ul>
</li>
<li>划分split(&amp;root, const v)<ul>
<li><strong>自带查找</strong></li>
<li>将关键字为v的结点splay到根，左右子树分开即可。</li>
<li>因为含有splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li><strong>splay树应用区间操作</strong><ul>
<li><strong>关键字将是下标，或者没有关键字</strong>。在一些下标可能集体移动的场合，宜不设关键字。</li>
<li><strong>结点记录子树的总体信息</strong>，类似线段树，可包含延迟标记。</li>
<li>对区间[a,b]操作：将a-1旋到根，切掉右子树(b+1在其中)，再将b+1旋转到根，重新连接两棵树。这时<strong>b+1的左子树就是[a,b]</strong> 。</li>
<li>在[a,a+1]中间插入一些数：将被插入的数构建成splay树。将a旋到根，a+1旋到根的右孩子。将新建的splay树挂成a+1的左孩子。</li>
<li>重要的事情说n遍也不嫌多：小心root被更改。具体地说就是splay()要换根，只有splay()才能使用旋转。</li>
</ul>
</li>
</ul>
<h2 id="普通排序二叉树"><a href="#普通排序二叉树" class="headerlink" title="普通排序二叉树"></a>普通排序二叉树</h2><ul>
<li>重点是前驱和后继</li>
<li>前驱(const v)<ul>
<li><strong>必须自带查找</strong></li>
<li>在查找成功之前，<strong>记录最后一个往右走的结点</strong>，因为它可能是前驱</li>
<li>查找成功之后，如果结点有左子树，那么左子树的最大结点一定是前驱</li>
<li>如果一个结点是整棵树的最左（最小）结点，那么它没有前驱。</li>
</ul>
</li>
<li>后继(const v)<ul>
<li>同前驱</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-分治最小割</title>
    <url>/2016/04/27/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%88%86%E6%B2%BB%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    <content><![CDATA[<p>对于询问网络图中每个点对的最大流（最小割容量），总是可以将图简化成n个点n-1条边的树型图，边上标有一些容量，使得在树上询问每个点对的最大流等价于原问题。</p>
<span id="more"></span>

<p>上文提到的树叫作Gomory–Hu tree，其构造方法是：</p>
<ol>
<li>将所有点的放在一个集合中。</li>
<li>选一个元素个数至少为2的集合（不妨设其为集合R）中任取两个点作为原图的源点和汇点，跑一次最大流，就会将原图上的所有点分割为两部分，要么与S联通，要么与T联通。</li>
<li>在残余图中，对于每个节点v∈R，若v与S联通，则v留在集合R，否则将v移除并放置于新集合R&#39;中。在Gomory–Hu tree中，有边(R,R&#39;)，边权（容量）是2.中最大流的值。</li>
<li>还原原网络图，重复2，3，4至所有集合有且仅有一个元素。此时Gomory–Hu tree建图完毕。</li>
</ol>
<p>询问网络图中每个点对的最大流，等价于询问Gomory–Hu tree上对应点路径边权的最小值，可以用树链剖分维护。</p>
<h1 id="bzoj4519-不同的最小割"><a href="#bzoj4519-不同的最小割" class="headerlink" title="bzoj4519 不同的最小割"></a>bzoj4519 不同的最小割</h1><h2 id="cuts"><a href="#cuts" class="headerlink" title="cuts"></a>cuts</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成<br>两个部分，如果结点 s,t 不在同一个部分中，则称这个划分是关于 s,t 的割。对于带权图来说，将<br>所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 s,t 的最小割指的是在<br>关于 s,t 的割中容量最小的割。<br>而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把<br>视野放宽，考虑有 N 个点的无向连通图中所有点对的最小割的容量，共能得到 N ( N ? 1)<br>2 个数值。<br>这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件第一行包含两个数 N， M，表示点数和边数。接下来 M 行，每行三个数 u， v， w，表示<br>点 u 和点 v（从 1 开始标号）之间有条边权值是 w。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件第一行为一个整数，表示个数。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>4 4<br>1 2 3<br>1 3 6<br>2 4 5<br>3 4 4</p>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3</p>
<h4 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h4><p>? 对于 50% 的数据， N ≤ 200， M ≤ 2000<br>? 对于 100% 的数据， 1 ≤ N ≤ 850， 1 ≤ M ≤ 8500， 1 ≤ w ≤ 100000</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">860</span>, M = <span class="number">8510</span>*<span class="number">4</span>, INF = <span class="number">1</span>&lt;&lt;<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[M], nex[M], index[MAXN], mcap[M], cap[M], cur=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pn[MAXN], tmppn[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> cap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[MAXN], qh, qt, flag[MAXN], fa[MAXN], path[MAXN], FLOW[MAXN], cntf=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	qh = <span class="number">0</span>; qt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(flag, <span class="number">-1</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">3</span>));</span><br><span class="line">	flag[S] = <span class="number">1</span>;</span><br><span class="line">	q[<span class="number">0</span>] = S;</span><br><span class="line">	<span class="keyword">while</span> (qh &lt; qt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = q[qh++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=index[x]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (flag[to[i]]==<span class="number">-1</span> &amp;&amp; cap[i]&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				flag[to[i]] = flag[x]+<span class="number">1</span>;</span><br><span class="line">				q[qt++] = to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> depth;</span><br><span class="line">	<span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>(S, T)!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[depth=<span class="number">1</span>] = S;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">0</span> &lt; depth)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (fa[depth] == T)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> minc = INF, mink;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;depth; ++i)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (cap[path[i]] &lt; minc)</span><br><span class="line">					&#123;</span><br><span class="line">						minc = cap[path[i]];</span><br><span class="line">						mink = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				flow += minc;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;depth; ++i)</span><br><span class="line">				&#123;</span><br><span class="line">					cap[path[i]] -= minc;</span><br><span class="line">					cap[path[i]^<span class="number">1</span>]+= minc;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				depth = mink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">bool</span> alive = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=index[fa[depth]]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (flag[fa[depth]]+<span class="number">1</span>==flag[to[i]] &amp;&amp; cap[i]&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					path[depth] = i;</span><br><span class="line">					fa[++depth] = to[i];</span><br><span class="line">					alive = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!alive) &#123; flag[fa[depth]] = <span class="number">-1</span>; --depth; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FLOW[cntf++] = flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(cap, mcap, <span class="built_in">sizeof</span>(<span class="type">int</span>)*cur);</span><br><span class="line">	<span class="built_in">Dinic</span>(pn[l], pn[r]);</span><br><span class="line">	<span class="type">int</span> lpart = l<span class="number">-1</span>, rpart = r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=l; i&lt;=r; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag[pn[i]]!=<span class="number">-1</span>)</span><br><span class="line">			tmppn[++lpart] = pn[i];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmppn[--rpart] = pn[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=l; i&lt;=r; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pn[i] = tmppn[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(l, lpart);</span><br><span class="line">	<span class="built_in">dfs</span>(rpart, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cuts.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cuts.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="built_in">memset</span>(index, <span class="number">-1</span>, <span class="built_in">sizeof</span>(index));</span><br><span class="line">	<span class="built_in">ri</span>(n);</span><br><span class="line">	<span class="built_in">ri</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, a, b, c; i&lt;m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ri</span>(a); <span class="built_in">ri</span>(b); <span class="built_in">ri</span>(c);</span><br><span class="line">		<span class="built_in">addEdge</span>(a, b, c);</span><br><span class="line">		<span class="built_in">addEdge</span>(b, a, c);</span><br><span class="line"><span class="comment">//		assert(cur &lt; 8500*4);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) pn[i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(FLOW, FLOW+cntf);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;cntf; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (FLOW[i]!=FLOW[i<span class="number">-1</span>]) ++ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[cur] = b; mcap[cur] = c; nex[cur] = index[a]; index[a] = cur++;</span><br><span class="line">	to[cur] = a; mcap[cur] = <span class="number">0</span>; nex[cur] = index[b]; index[b] = cur++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span> || <span class="string">&#x27;9&#x27;</span>&lt;c);</span><br><span class="line">	x = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span>&lt;=(c=<span class="built_in">getchar</span>()) &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		x = <span class="number">10</span>*x + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//	cerr &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>朝花夕拾</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-桥与强连通分量</title>
    <url>/2015/11/06/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A1%A5%E4%B8%8E%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h1 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h1><ul>
<li>桥是在无向图中不在环上的边.</li>
<li>如果隔断桥，无向图将被分为两个不连通的子图.</li>
</ul>
<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><ul>
<li>如果删去一个点, 余下的点不连通, 则这个点是割点.</li>
<li>割点不依赖桥, 桥上也不一定存在割点.</li>
</ul>
<h1 id="如何找桥和割点"><a href="#如何找桥和割点" class="headerlink" title="如何找桥和割点"></a>如何找桥和割点</h1><ol>
<li>任选图上一点为根, dfs.<ul>
<li>记录每个节点首次被访问的次序, 记作dfn[x].</li>
<li>记录每个节点能连接或通过子节点连接到的最早节点的dfn, 且不能沿父亲边, 记作low[x].</li>
<li>dfs(x)将返回low[x].</li>
</ul>
</li>
<li>在每个dfs中, 设当前节点为x, 枚举边连到y.<ul>
<li>如果dfn[y]未定义, 则y是x在搜索树上的儿子. low[x] &#x3D; min(low[x], dfs(y)).</li>
<li>如果y &#x3D;&#x3D; fa[x], 则y是x在搜索树上的父亲, 不管此y</li>
<li>若dfn[y]有定义且y!&#x3D;fa[x], 则y即是x通过非父子边连到的节点, 尝试用dfn[y]更新low[x].</li>
</ul>
</li>
<li>利用桥和割点的性质判定.</li>
</ol>
<h2 id="性质-x2F-依据"><a href="#性质-x2F-依据" class="headerlink" title="性质&#x2F;依据"></a>性质&#x2F;依据</h2><h3 id="沿x的边找其他节点y"><a href="#沿x的边找其他节点y" class="headerlink" title="沿x的边找其他节点y."></a>沿x的边找其他节点y.</h3><ol>
<li>dfn[y]有定义 &lt;&#x3D;&#x3D;&gt; y是x在搜索树中的祖先<ul>
<li>充分性是显然的.</li>
<li>必要性: 若y不是祖先, 则y是兄弟或祖先的兄弟. 又因为dfn[y]有定义, 所以y一定完成了dfs的过程, 但x和y连接的边却没有处理, 矛盾.</li>
<li>尝试用dfn[y]更新low[x], 而不是用low[y]. (使回溯边不经过祖先点). 这样能保持算法的正确性. 否则因为回溯边经过割点在找割点时产生错误.</li>
</ul>
</li>
<li>若y是x在搜索树上的非第一个儿子:<ul>
<li>若x是根, 则y与之前的儿子以x为割点.</li>
<li>若x不是根, 则y与之前的儿子可能经过x的祖先联通.<ul>
<li>如果验证y与x的祖先不连通, 则x是两者的割点.</li>
<li>如果验证y与x的祖先不连通, 则x是y与其他儿子的割点(否则y已经被访问过, 不会是x的儿子.)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="桥的性质"><a href="#桥的性质" class="headerlink" title="桥的性质"></a>桥的性质</h3><ol>
<li>桥是一条边, 连接着在搜索树中的父亲和儿子&#x2F;祖先和儿子</li>
<li>设一条边连接着祖先节点u, 儿子节点v, 若dfn[u]&lt;low[v], 则若边删除, 祖先儿子无法连通, 即此边是桥. 反之亦然: 边(u, v)是桥 &lt;&#x3D;&#x3D;&gt; dfn[u]&lt;low[v] (u是v的祖先)</li>
</ol>
<h3 id="割点的性质"><a href="#割点的性质" class="headerlink" title="割点的性质"></a>割点的性质</h3><ol>
<li>割点是一个点, 它要么是根节点, 要么有一个父亲节点.</li>
<li>对于根节点, 若搜索树上根节点有多余一个儿子, 则任意两对儿子以根节点为割点.</li>
<li>对于非根节点, 设为u, 其父亲为fa, 儿子v(i), 若dfn[u] &lt;&#x3D; low[v], 则若u删除, fa&#x2F;v不连通, 即u是割点;  特别地, dfn[u] &lt;&#x3D; low[v1], 则v1与v2, v3....都以fa为割点.</li>
</ol>
<p>找桥：用dfs遍历图，记录结点访问次序；当某个结点有一条边通往已被访问过的结点时，代表找到了环；不在环上的边就是桥。</p>
<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><p>在有向图中两个顶点Vi，Vj之间有一条从Vi到Vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量（百度百科）</p>
<p>Kosaraju算法:</p>
<p>1、深搜遍历原图G图，记录每个结点离开时间（后序遍历）；</p>
<p>2、选择具有最晚离开时间的顶点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量。</p>
<p>3、如果还有点没有被删除，重复2，否则算法结束</p>
<p>Kosaraju算法性质：如果将求出来的强连通分量收缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的结点，那么这个顺序其实就是强连通分量收缩成点后形成的有向无环图的拓扑序列。</p>
]]></content>
      <tags>
        <tag>朝花夕拾</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-树链剖分</title>
    <url>/2016/04/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>树链剖分的名字非常高大上， 其实不难， 本质是将树分解成几条链， 映射在线段树（树状数组、Splay等）上， 当我们需要在树上的路径（题目通常给定两个结点，在他们的路径上操作）进行操作时， 就能转化成在线段树（等数据结构）上进行操作， 接下来以树转线段树为例。</p>
<span id="more"></span>

<p>树链剖分最重要的地方在于分解树的规则， 下面是一种通用的分解方法：对于每个结点，如果它有儿子，那么取其子树最重（子树结点最多）的儿子为“重儿子”， 重儿子与其父亲的连边称为“重边”。相对的，其余的儿子成为“轻儿子”，轻儿子与父亲的连边称为轻边 。连续的重边构成“重链”，在同一条重链上的点 在线段树中 按重链的顺序相邻。显然，非叶子结点都有重儿子， 它们必定能映射到唯一的重链上。对于多个同父亲的叶子结点，随便取一个作为重儿子就可以了。可以想象， 轻边连接着不相交的重链，树上的每个结点都能唯一的映射到线段的某一个点上。</p>
<p><img src="/2016/04/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E4%BE%8B%E5%AD%90.png" alt="树链剖分例子"></p>
<p>这样一来，一些数据结构就能够推广到树上。比如能求区间最值、区间求和的线段树，在映射做好后，就能套用在树上。<br>假如我们要求树上两点(u,v)之间的路径的权值和。例如上图求(11, 14)间路径权值和，分别从11和14往上跳，跳到重链的顶端，（为了不超过两点的最近公共祖先， 要选择更深的重链头跳），11跳到2，用线段树求出(2,11)的和（利用重链在映射线段上连续的特点），暴力加一下轻边(1,2)，此时两方面同时跳到重链头1，用线段树求出(1,14)的和，得到答案。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="主要数据"><a href="#主要数据" class="headerlink" title="主要数据"></a>主要数据</h2><ol>
<li>树<ul>
<li>这部分是由题目给出的数据</li>
<li>题目要求在树上的路径做段修改, 段询问.</li>
<li>如果树很大, 输入代价可能也很大, 应该考虑自定义输入. 字符串输入用scanf.</li>
</ul>
</li>
<li>高级树形数据结构<ul>
<li>能够满足题目要求的修改, 询问操作.</li>
<li>基础数据来自一段预处理序列, 而不是直接来自输入.</li>
</ul>
</li>
<li>输入树到自定义数据结构的映射<ul>
<li>简称树链剖分.</li>
<li>将输入树剪成若干条链, 作为高级数据结构的基础数据.</li>
</ul>
</li>
</ol>
<h2 id="剖分方法"><a href="#剖分方法" class="headerlink" title="剖分方法"></a>剖分方法</h2><p>在生成映射的过程中, 对于原树的每个节点, 有六个信息要处理.</p>
<ol>
<li>父亲节点 - 防止重复搜索</li>
<li>节点深度 - 防止越过最近公共祖先</li>
<li>子树大小 - 决定重儿子</li>
<li>重儿子 - 构成重链</li>
<li>链上编号 - 映射到序列</li>
<li>重链头 - 找到编号连续的段</li>
</ol>
<ul>
<li>1,2,5,6是自顶向下计算的, 3,4必须自底向上计算.</li>
<li>bfs计算1,2. 反向bfs计算3,4.</li>
<li>模拟栈(#define成队列数组)计算5,6. 为了保证重链编号连续, 重儿子后入栈.</li>
<li>如果值在边上, 将值放进子节点中. 询问时注意轻边的纳入.</li>
</ul>
<h2 id="映射询问"><a href="#映射询问" class="headerlink" title="映射询问"></a>映射询问</h2><ul>
<li>如果两点所在重链的重链头不同, 意味着两点不在同一条重链. 为了防止一条重链头已经越过最近公共祖先, 选择重链头深度大的计算. 询问映射段, 把轻边也算在内(轻边信息放在了重链头节点中). 计算后节点换成重链头的父亲.</li>
<li>如果两节点在同一条重链上, 首先把深度安排好, 特判两节点是否相同. 如果询问边, 这时候的计算与轻边无关, 注意把浅节点编号加一.</li>
</ul>
<h3 id="关于线段树延迟标记"><a href="#关于线段树延迟标记" class="headerlink" title="关于线段树延迟标记"></a>关于线段树延迟标记</h3><ul>
<li>pushDown意味着当前段有多余, 要分两半, 但不一定两半都继续递归. <strong>所以递归后两半都可能带有延迟标记</strong>. </li>
<li>pushUp在修改操作中出现, 且前面必有pushDown, 意味着当前段的延迟操作已经补好. pushUp结束后<strong>当前段一定不带延迟标记</strong>.</li>
</ul>
<p>求路径最值也如法炮制。<br>下面给出实现树上路径求最值、求和的代码，题目对应HYSBZ 1036。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mmst(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (root&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson ((root&lt;&lt;1)|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXE = MAXN&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[MAXE], nex[MAXE], Mindex[MAXN], cur=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN], top[MAXN], fa[MAXN], son[MAXN], siz[MAXN], depth[MAXN], z=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> SUM[MAXN&lt;&lt;<span class="number">2</span>], MAX[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	son[x] = <span class="number">0</span>;</span><br><span class="line">	siz[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=Mindex[x]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (to[i] != fa[x])</span><br><span class="line">		&#123;</span><br><span class="line">			fa[to[i]] = x;</span><br><span class="line">			depth[to[i]] = depth[x] + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(to[i]);</span><br><span class="line">			<span class="keyword">if</span> (siz[to[i]] &gt; siz[son[x]]) son[x] = to[i];</span><br><span class="line">			siz[x] += siz[to[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_tree</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top[x] = tp;</span><br><span class="line">	w[x] = ++z;</span><br><span class="line">	<span class="keyword">if</span> (son[x]!=<span class="number">0</span>) <span class="built_in">set_tree</span>(son[x], tp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=Mindex[x]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (to[i]!=fa[x] &amp;&amp; to[i]!=son[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">set_tree</span>(to[i], to[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> val, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123; SUM[root] = MAX[root] = val; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (p&lt;=mid) <span class="built_in">update</span>(l, mid, p, val, lson);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">update</span>(mid+<span class="number">1</span>, r, p, val, rson);</span><br><span class="line">	SUM[root] = SUM[lson] + SUM[rson];</span><br><span class="line">	MAX[root] = <span class="built_in">max</span>(MAX[lson], MAX[rson]);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> MAX[root];</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ref = -MAXN;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=mid) ref = <span class="built_in">qMax</span>(l, mid, L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;R) ref = <span class="built_in">max</span>(ref, <span class="built_in">qMax</span>(mid+<span class="number">1</span>, r, L, R, rson));</span><br><span class="line">	<span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> SUM[root];</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ref = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=mid) ref = <span class="built_in">qSum</span>(l, mid, L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;R) ref += <span class="built_in">qSum</span>(mid+<span class="number">1</span>, r, L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ref = -MAXN;</span><br><span class="line">	<span class="type">int</span> f1 = top[a], f2 = top[b];</span><br><span class="line">	<span class="keyword">while</span> (f1 != f2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (depth[f1] &lt; depth[f2]) &#123; <span class="built_in">swap</span>(a, b); <span class="built_in">swap</span>(f1, f2); &#125;</span><br><span class="line">		ref = <span class="built_in">max</span>(ref, <span class="built_in">qMax</span>(<span class="number">1</span>, z, w[f1], w[a], <span class="number">1</span>));</span><br><span class="line">		a = fa[f1];</span><br><span class="line">		f1 = top[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="built_in">max</span>(ref, v[a]);</span><br><span class="line">	<span class="keyword">if</span> (depth[a] &gt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(ref, <span class="built_in">qMax</span>(<span class="number">1</span>, z, w[a], w[b], <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ref = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> f1 = top[a], f2 = top[b];</span><br><span class="line">	<span class="keyword">while</span> (f1 != f2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (depth[f1] &lt; depth[f2]) &#123; <span class="built_in">swap</span>(a, b); <span class="built_in">swap</span>(f1, f2); &#125;</span><br><span class="line">		ref += <span class="built_in">qSum</span>(<span class="number">1</span>, z, w[f1], w[a], <span class="number">1</span>);</span><br><span class="line">		a = fa[f1];</span><br><span class="line">		f1 = top[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a == b) <span class="keyword">return</span> ref + v[a];</span><br><span class="line">	<span class="keyword">if</span> (depth[a] &gt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> ref + <span class="built_in">qSum</span>(<span class="number">1</span>, z, w[a], w[b], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;tes.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="built_in">mmst</span>(Mindex, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ri</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>, a, b; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">ri</span>(a); <span class="built_in">ri</span>(b);</span><br><span class="line">    	<span class="built_in">addEdge</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    	<span class="built_in">ri</span>(v[i]);</span><br><span class="line">    </span><br><span class="line">    siz[<span class="number">0</span>] = <span class="number">0</span>; depth[<span class="number">1</span>] = <span class="number">1</span>; fa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">set_tree</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    	<span class="built_in">update</span>(<span class="number">1</span>, z, w[i], v[i], <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ri</span>(q);</span><br><span class="line">    <span class="type">char</span> que[<span class="number">7</span>];</span><br><span class="line">    <span class="type">int</span> q1, q2;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, que);</span><br><span class="line">    	<span class="built_in">ri</span>(q1); <span class="built_in">ri</span>(q2);</span><br><span class="line">    	<span class="keyword">if</span> (que[<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findMax</span>(q1, q2));</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (que[<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findSum</span>(q1, q2));</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>, z, w[q1], v[q1]=q2, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[cur] = b; nex[cur] = Mindex[a]; Mindex[a] = cur++;</span><br><span class="line">	to[cur] = a; nex[cur] = Mindex[b]; Mindex[b] = cur++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> c; <span class="type">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span> || <span class="string">&#x27;9&#x27;</span>&lt;c) <span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) minus=<span class="literal">true</span>;</span><br><span class="line">	x = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span>&lt;=(c=<span class="built_in">getchar</span>()) &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		x = <span class="number">10</span>*x+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (minus) x = -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编程时有几点要留意：</p>
<ul>
<li>注意权值在树中摆放的位置， 在边上或者在结点上，通常可以转化成在结点上。</li>
<li>在一条重链上，深度小的点在线段树左边，深度大的在右边（相对而言）。</li>
<li>find()中当f1=&#x3D;f2后，路径a~b是尚未被计算的，特别是要留意if (a=&#x3D;b)，将其权值记上。</li>
<li>dfs()先解决深度、大小（轻重）、重儿子、父亲的问题。</li>
<li>set_tree()后解决top重链头标记、安排映射的问题。</li>
</ul>
<h4 id="2016-06-02新增"><a href="#2016-06-02新增" class="headerlink" title="2016.06.02新增"></a>2016.06.02新增</h4><p>改进两个初始化：</p>
<ul>
<li>第一个初始化先用宽搜解决深度计数和父亲指针的预处理，然后反向遍历队列，用改进的方式计算size和重儿子。</li>
<li>第二个初始化用粗略的模拟栈，重儿子优先做深搜，由浅到深计算id和top。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> GETMAX = <span class="literal">true</span>, GETSUM = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> SUM[MAXN&lt;&lt;<span class="number">2</span>], MAX[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> depth[MAXN], fa[MAXN], top[MAXN], wson[MAXN], siz[MAXN], id[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> to[MAXN&lt;&lt;<span class="number">1</span>], nex[MAXN&lt;&lt;<span class="number">1</span>], _index[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> v, <span class="type">int</span> root=<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryMAX</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root=<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querySUM</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root=<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qtree</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> <span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ref = (flag == GETMAX ? -MAXN : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (top[a]!=top[b])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (depth[top[a]] &lt; depth[top[b]]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">		<span class="keyword">if</span> (flag==GETMAX) ref = <span class="built_in">max</span>(ref, <span class="built_in">queryMAX</span>(<span class="number">1</span>, n, id[top[a]], id[a]));</span><br><span class="line">		<span class="keyword">else</span> ref += <span class="built_in">querySUM</span>(<span class="number">1</span>, n, id[top[a]], id[a]);</span><br><span class="line">		a = fa[top[a]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (depth[a]&gt;depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (flag == GETMAX) ref = <span class="built_in">max</span>(ref, <span class="built_in">queryMAX</span>(<span class="number">1</span>, n, id[a], id[b]));</span><br><span class="line">	<span class="keyword">else</span> ref += <span class="built_in">querySUM</span>(<span class="number">1</span>, n, id[a], id[b]);</span><br><span class="line">	<span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;tes.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(_index, <span class="number">-1</span>, <span class="built_in">sizeof</span>(_index));</span><br><span class="line">	<span class="built_in">memset</span>(wson, <span class="number">0</span>, <span class="built_in">sizeof</span>(wson));</span><br><span class="line">	<span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="built_in">sizeof</span>(siz));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">ri</span>(n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> u, v;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ri</span>(u); <span class="built_in">ri</span>(v);</span><br><span class="line">		<span class="built_in">addEdge</span>(u, v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ri</span>(val[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="built_in">dfs</span>();</span><br><span class="line">	<span class="built_in">build</span>(n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		<span class="built_in">update</span>(<span class="number">1</span>, n, id[i], val[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ri</span>(m);</span><br><span class="line">	<span class="type">char</span> rd[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, rd);</span><br><span class="line">		<span class="built_in">ri</span>(u); <span class="built_in">ri</span>(v);</span><br><span class="line">		<span class="keyword">if</span> (rd[<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">qtree</span>(u, v, GETMAX));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (rd[<span class="number">1</span>]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">qtree</span>(u, v, GETSUM));</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>, n, id[u], v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line">	q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	fa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	depth[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> x = q[head++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=_index[x]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (to[i] != fa[x])</span><br><span class="line">			&#123;</span><br><span class="line">				depth[to[i]] = depth[x] + <span class="number">1</span>;</span><br><span class="line">				fa[to[i]] = x;</span><br><span class="line">				q[tail++] = to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=tail<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> x = q[i], y = fa[x];</span><br><span class="line">		siz[y] += (++siz[x]);</span><br><span class="line">		<span class="keyword">if</span> (siz[wson[y]] &lt; siz[x]) wson[y] = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sta q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tail = <span class="number">1</span>;</span><br><span class="line">	sta[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (tail != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> x = sta[--tail];</span><br><span class="line">		id[x] = ++num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=_index[x]; i!=<span class="number">-1</span>; i=nex[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (to[i]!=fa[x] &amp;&amp; to[i]!=wson[x])</span><br><span class="line">			&#123;</span><br><span class="line">				top[to[i]] = to[i];</span><br><span class="line">				sta[tail++] = to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (wson[x] != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			top[wson[x]] = top[x];</span><br><span class="line">			sta[tail++] = wson[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (root&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson ((root&lt;&lt;1)|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> v, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		SUM[root] = MAX[root] = v;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (p&lt;=mid) <span class="built_in">update</span>(l, mid, p, v, lson);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">update</span>(mid+<span class="number">1</span>, r, p, v, rson);</span><br><span class="line">	SUM[root] = SUM[lson] + SUM[rson];</span><br><span class="line">	MAX[root] = <span class="built_in">max</span>(MAX[lson], MAX[rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	r &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=r; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		SUM[i] = <span class="number">0</span>;</span><br><span class="line">		MAX[i] = -MAXN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryMAX</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> MAX[root];</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ref = -MAXN;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=mid) ref = <span class="built_in">queryMAX</span>(l, mid, L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;R) ref = <span class="built_in">max</span>(ref, <span class="built_in">queryMAX</span>(mid+<span class="number">1</span>, r, L, R, rson));</span><br><span class="line">	<span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querySUM</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> SUM[root];</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ref = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=mid) ref = <span class="built_in">querySUM</span>(l, mid, L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;R) ref += <span class="built_in">querySUM</span>(mid+<span class="number">1</span>, r, L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[cur] = b; nex[cur] = _index[a]; _index[a] = cur++;</span><br><span class="line">	to[cur] = a; nex[cur] = _index[b]; _index[b] = cur++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ri</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">bool</span> mus = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span> || <span class="string">&#x27;9&#x27;</span>&lt;c) <span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) mus = <span class="literal">true</span>;</span><br><span class="line">	x = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span>&lt;=(c=<span class="built_in">getchar</span>()) &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		x = <span class="number">10</span>*x + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (mus) x = -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2019/09/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>不会汇编，强行刚软保，<del>瑟瑟发抖</del>稳得一匹</p>
<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="C语法"><a href="#C语法" class="headerlink" title="C语法"></a>C语法</h2><ol>
<li>指针作差得到区间元素个数。<strong>指针的类型参与计算！</strong></li>
<li>要动态改变函数体，需要在编译期赋予权限。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:test,RWE&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol>
<li><code>__asm int 3</code>加入汇编断点（OD）。要在OD中启用StrongOD，禁用跳过int3；并设置测试选项</li>
<li></li>
<li></li>
</ol>
<h2 id="Windows-exe结构"><a href="#Windows-exe结构" class="headerlink" title="Windows exe结构"></a>Windows exe结构</h2><ol>
<li>401000H这个内存地址对应的文件地址是1000H</li>
</ol>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Quickview：更改EXE数据"><a href="#Quickview：更改EXE数据" class="headerlink" title="Quickview：更改EXE数据"></a>Quickview：更改EXE数据</h2><ol>
<li>按<code>F5</code>可以按地址定位</li>
<li>提供三种模式：16进制格式，汇编格式，纯文本格式；按<code>F2</code>切换到32位模式</li>
<li>按<code>Alt+F9</code>保存</li>
<li>按<code>ins</code>选择块（开始和结束各按一次），选择后按<code>shift</code>底部出现块工具</li>
<li></li>
</ol>
<h2 id="OD：单步跟踪EXE"><a href="#OD：单步跟踪EXE" class="headerlink" title="OD：单步跟踪EXE"></a>OD：单步跟踪EXE</h2><ol>
<li>可以用来追踪去壳代码</li>
<li>可以dump数据块到文件</li>
<li>可以设置硬件断点，当某储存位置发生更改时中断</li>
<li><code>Alt+B</code>管理断点，<code>空格</code>切换</li>
<li></li>
</ol>
<h2 id="IDA：静态分析EXE"><a href="#IDA：静态分析EXE" class="headerlink" title="IDA：静态分析EXE"></a>IDA：静态分析EXE</h2><ol>
<li>按<code>G</code>定位</li>
<li>可通过加壳反抗静态分析。</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="面对加壳"><a href="#面对加壳" class="headerlink" title="面对加壳"></a>面对加壳</h2><ol>
<li>用OD动态追踪，尝试还原被加壳代码（等待去壳），再用QV还原EXE（用块复制的办法加快速度）</li>
</ol>
<h2 id="面对序列号"><a href="#面对序列号" class="headerlink" title="面对序列号"></a>面对序列号</h2><ol>
<li><p>观察到现象：弹框并消失。可行办法：跟踪CreateWindow&#x2F;ShowWindow&#x2F;DestoryWindow（推荐）</p>
</li>
<li><p>用OD动态追踪，尝试中断DestoryWindow，观察堆栈顶端找到出栈后的程序运行位置（或直接跑retn)</p>
</li>
<li><p>对不当场判断的场合（没有明显现象） 怀疑有文件&#x2F;注册表读写 <code>FileMon + RegMon = ProcMon</code></p>
<p> RegCreateKey()<br> RegQueryValue()<br> RegSetValue()</p>
<p> CreateFile<br> CreateFileEx<br> ReadFile<br> WriteFile</p>
</li>
<li><p>软件断点：当前断点指令的首字节改为<code>0xCC</code>（对应的汇编指令为int 3）。 可能被程序自检。</p>
</li>
<li><p>硬件断点：选中某条指令-&gt;断点-&gt;硬件执行。  检查已设置的断点：调试-&gt;硬件断点... 原理：CPU调试寄存器保存了断点地址和断点条件，每个周期都会检查条件。触发条件有<code>execute</code>，<code>read</code>, <code>write</code>。  要设置读&#x2F;写断点，选中变量的首字节-&gt;右键-&gt;断点-&gt;硬件写入-&gt;DWORD（对应的类型）。要设置DWORD断点对变量首字节有要求。读&#x2F;写完成后到达断点。<br>可以用<code>printf(&quot;%p&quot;,...)</code>知道要跟踪的变量的地址。</p>
</li>
<li><p>利用读&#x2F;写硬件断点，当操作序列号时就能断住。<code>Ctrl+B</code>搜索已输入的序列号找到内存地址。跳跃几次看到<code>rep movs</code>（字符串拷贝），此时取消断点，回到用户代码，跳出几次，看到getText</p>
</li>
<li><p>如果进入系统代码，则应跳出到用户代码<code>Alt+F9</code>，再按<code>Ctrl+F9</code>跳出一些函数。</p>
</li>
<li><p><code>CallWindowProcA</code>的作用是由系统内核来回调用户事先写的消息处理函数</p>
</li>
</ol>
<h1 id="汇编规则"><a href="#汇编规则" class="headerlink" title="汇编规则"></a>汇编规则</h1><ol>
<li>cdq edx:eax, idiv, edx &#x3D; edx:eax %n</li>
</ol>
<h1 id="逆向工程历史"><a href="#逆向工程历史" class="headerlink" title="逆向工程历史"></a>逆向工程历史</h1><ol>
<li>微软开发<code>debug</code>，<code>codeview</code>, 宝蓝开发<code>TurboDebug</code>;</li>
</ol>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ol>
<li><code>debug</code> 编程：a(assemble) 地址+汇编语言，偏移地址固定从100开始   (OD中改指令相当于a，若下一条语句实效，会有安全措施，改90NULL)。</li>
<li>u(unassemble) 反汇编，指定开始地址和末地址（l+长度亦可)，反汇编对应地址内的机器语言。</li>
<li>r(register) 查看寄存器 SF+PL-NG UP上DN下.  r + 寄存器名字, 修改内存</li>
<li>p (optional 地址) 单步前进，目标地址是执行完毕的</li>
<li>g (optional &#x3D;首地址 (optional) 末地址) (从csip)跳跃直到int 3(末地址是未执行的);</li>
<li>d(dump) 查看内存 可以指定(d cs:100 120 || d cs:100 l20)</li>
<li>e(edit) 修改内存 地址 + &quot;string&quot; || hex</li>
<li>t(track in)</li>
</ol>
<h2 id="加密软件"><a href="#加密软件" class="headerlink" title="加密软件"></a>加密软件</h2><ol>
<li><code>lock89</code>, <code>lockup</code>, 作者：杨道沅, 硬盘指纹加密技术</li>
<li><code>lock93</code>, <code>lock93NT</code>, 周辉</li>
<li><code>BitLock</code>, 雷军</li>
</ol>
<h1 id="驻留内存程序"><a href="#驻留内存程序" class="headerlink" title="驻留内存程序"></a>驻留内存程序</h1><h2 id="需要技术"><a href="#需要技术" class="headerlink" title="需要技术"></a>需要技术</h2><ol>
<li>驻留内存</li>
<li>中断</li>
</ol>
<p><code>es:[bx]</code> 0:32是一个中断向量的地址</p>
<p>0:0 ~ 0:3FF 是中断向量表，每个中断向量占用4字节。 例如<code>int 00h</code>的中断向量储存在0:0 ~ 0:3之间; <code>int 01h</code>的中断向量储存在0:4 ~ 0:7之间。</p>
<p>当cpu执行<code>int 00h</code>时：<br>pushf 保护当前标志位（flag）的状态<br>push cs 当前短地址<br>push 下条指令的偏移地址<br>cli<br>jmp 8756h:3412h</p>
<p>&#x2F;&#x2F; cli disable interrupt    (clear interrupt)<br>&#x2F;&#x2F; sti enable.              (set interrupt)</p>
<p>8756h:3412h 是中断服务程序的入口地址<br>    ……<br>    iret; 中断返回</p>
<p>当cpu执行<code>iret</code>时：<br>pop ip;<br>pop cs;<br>popf;       从而实现恢复现场。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 调换中断向量表</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[bx], offset int_8h</span><br><span class="line">mov es:[bx+2], cs</span><br><span class="line">sti</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp dword ptr cs:[old_8h] ; 中断链接   old_8h定义在code段内是必要的</span><br><span class="line">; iret 导致旧程序不再执行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int_8h:    ; 中断服务</span><br><span class="line">;;;;;;</span><br><span class="line">push ds</span><br><span class="line">push ax</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">;;;;;;</span><br><span class="line"></span><br><span class="line">inc [count]</span><br><span class="line">cmp [count], 18</span><br><span class="line"></span><br><span class="line">inc cs:[count]  ; count db 0 at the end  定义在code段内</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push ... ; 记忆所有寄存器   ax bx cb dx si di ds</span><br><span class="line"></span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line">push cs</span><br><span class="line">pop es</span><br><span class="line">mov al,4</span><br><span class="line">out 70,al</span><br><span class="line">in al,71h // hour</span><br><span class="line">call convert</span><br><span class="line">mov word ptr current_time[?], ax</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmp dword ptr cs:[old_8h]  ;返回旧程序</span><br></pre></td></tr></table></figure>


<p>驻留</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install:</span><br><span class="line">mov ah, 9</span><br><span class="line"></span><br><span class="line">; program segment prefix(PSP) 长度为100h，其中PSP:80h存放命令行参数，程序刚刚开始时 ds = es = psp，</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in al, 60h</span><br></pre></td></tr></table></figure>


<h1 id="gamebuster"><a href="#gamebuster" class="headerlink" title="gamebuster"></a>gamebuster</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount c:... d:\...</span><br><span class="line">gb</span><br><span class="line">pc</span><br><span class="line">[ctrl][ctrl]  分析&quot;/十进制&quot; &quot;十六进制&quot;</span><br><span class="line">[alt + 1]</span><br><span class="line">[shift + 1] 锁</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="dosboxdeb"><a href="#dosboxdeb" class="headerlink" title="dosboxdeb"></a>dosboxdeb</h2><p>dos mcbs 获得当前程序的PSP （memory control block)<br>u 01dd:1785  &#x2F;&#x2F; 查看反汇编</p>
<h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">or ax, 0100h</span><br><span class="line">push ax</span><br><span class="line">popf    ; 修改 TF = 1</span><br><span class="line"></span><br><span class="line">nop;    ; 当TF==1，执行一条指令后调用 int 1h</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="某种病毒"><a href="#某种病毒" class="headerlink" title="某种病毒"></a>某种病毒</h2><p>修改<code>int 21h</code>中断向量为<code>xxxx:yyyy</code>，原向量保存在内部变量<code>old_21h</code>中。新指令为<code>cmp ah 4Bh</code>，判断是否要执行程度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">je infect_exe</span><br><span class="line">jmp dword ptr cs:[old_21h]</span><br><span class="line"></span><br><span class="line">infect_exe:</span><br><span class="line">    mov ah, 3dh; AH==3DH 表示打开文件</span><br><span class="line">    mov al, 2; 读写方式</span><br><span class="line">    pushf</span><br><span class="line">    call dword ptr cs:[old_2h]; call 隐含push段地址、偏移地址 ..?</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>原始的<code>int 21h</code>中断向量的段地址&lt;&#x3D;70h</p>
<p>假装调用一个无用的<code>int 21h</code>功能，如获取dos版本号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah, 30h</span><br><span class="line">pushf</span><br><span class="line">置位TF ; 不能手动int 21h，因为系统将flag置零</span><br><span class="line">call dword ptr [current_21h]</span><br></pre></td></tr></table></figure>

<h2 id="EXE文件格式"><a href="#EXE文件格式" class="headerlink" title="EXE文件格式"></a>EXE文件格式</h2><p>+00 4D, 5A; EXE标志“MZ”<br>+02 50, 01; 最后一个扇区的字节数为150h （例外：如果是00 00则最后一个扇区是满载）<br>+04 02, 00; EXE占用的扇区数量（200字节&#x2F;一个扇区）<br>+06 02, 00; 重定位项数<br>+08 02, 00; 文件头的节长度&#x3D;20h，所以字节长度&#x3D;200h (20h x 10h)<br>+0A 00, 00; 至少内存   DOS是单任务的，所以内存限制没有太大意义<br>+0C FF, FF; 至多内存<br>+0E 05, 00; SS与程序首段地址的距离 （程序首段地址在运行时确定, &#x3D; psp+10h）<br>+10 00, 01; SP &#x3D; 100h</p>
<p>+12 E8, 20; EXE文件头的校验值<br>+14 28, 00; IP&#x3D;0028h            ; 注意此处先IP后CS   CS:IP第一句指令<br>+16 02, 00; CS与程序首段地址的距离<br>+18 1E, 00; 重定位表的偏移地址</p>
<p>; 下面是重定位表。每个重定位项4个字节。每两个字节为一个信息。<br>+1E 01, 00; 重定位的偏移地址&#x3D;0001h<br>+20 02, 00; Δ&#x3D;0002h,<br>; 首段地址+Δ&#x3D;重定位的段地址<br>;<br>+22 0D, 00; 重定位的偏移地址&#x3D;000Dh<br>+24 02, 00; Δ&#x3D;0002h,<br>; 首段地址+Δ&#x3D;重定位的段地址</p>
<p>DOS运行程序时，文件头不载入内存，所以内存头可认为是文件头长度</p>
<p>200h+2:1 &#x3D; 0:200h + 0:21 &#x3D; 0:211</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah, 2</span><br><span class="line">mov dl, &#x27;A&#x27;</span><br><span class="line">int 21h</span><br><span class="line">mov ah, 1</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax, ds</span><br><span class="line">add ax, 10</span><br><span class="line">add ax, 2</span><br><span class="line">push ax</span><br><span class="line">mov ax, 28h</span><br><span class="line">push ax</span><br><span class="line">retf ; pop ip, pop cs</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">assume cd:code</span><br><span class="line">shell:</span><br><span class="line">    call next</span><br><span class="line">next:</span><br><span class="line">    pop ax ; ax = ip = next的地址</span><br><span class="line">    sub ax, (offset next - offset shell)</span><br><span class="line">    mov bx, ax</span><br><span class="line">    </span><br><span class="line">    mov cs:[old_ds+bx], ds</span><br><span class="line">    mov cs:[old_es+bx], es</span><br><span class="line">    mov bp, ds ; psp</span><br><span class="line">    add bp, 10h; 首段段地址</span><br><span class="line">    mov cx, [reloc_count+bx]</span><br><span class="line">    push cs</span><br><span class="line">    pop ds</span><br><span class="line">    mov si, offset reloc_table</span><br><span class="line">    add si, bx</span><br><span class="line">    </span><br><span class="line">reloc_next_item:</span><br><span class="line">    mov ax, [si] ;lodsw ; ax = ds:[si] ; offset</span><br><span class="line">    mov dx, [si+2]                      ; delta segment</span><br><span class="line">    add dx, bp</span><br><span class="line">    mov es, dx</span><br><span class="line">    </span><br><span class="line">    add es:[di], bp</span><br><span class="line">    add si, 4</span><br><span class="line">    dec cx</span><br><span class="line">    jnz reloc_next_item</span><br><span class="line">    </span><br><span class="line">    mov ax, [csip+bx]</span><br><span class="line">    mov dx, [csip+bx+2]</span><br><span class="line">    add dx, bp</span><br><span class="line">    push dx</span><br><span class="line">    push ax</span><br><span class="line">    mov ds, cs:[bx+old_ds]</span><br><span class="line">    mov es, cs:[bx+old_es]</span><br><span class="line">    retf</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">old_ds dw 0</span><br><span class="line">old_es dw 0</span><br><span class="line">csip dw 0, 0</span><br><span class="line">reloc_count dw 0</span><br><span class="line">reloc_table db label byte ; 定义为db但不赋初值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end shell</span><br></pre></td></tr></table></figure>

<p>注意加密堆栈后引发的解密对新数据的影响的问题。</p>
<p>保存ss和sp，之后修改它为一段预留空间</p>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p><em>32位系统下</em></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">保护模式</th>
<th align="center">实模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最大段长度</td>
<td align="center">4G</td>
<td align="center">64K</td>
</tr>
<tr>
<td align="center">越界访问</td>
<td align="center">运行时错误</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">物理寻址</td>
<td align="center">查gdt表</td>
<td align="center">基址*10h+10h+偏移</td>
</tr>
</tbody></table>
<h2 id="查gdt表"><a href="#查gdt表" class="headerlink" title="查gdt表"></a>查gdt表</h2><p>设<code>ds=10h</code>，现通过查gdt表获得其物理地址。gdt表储存描述符，每个占8字节。表的首地址存在于<code>gdtr</code>寄存器。</p>
<p>gdt+10h xx xx xx xx xx xx xx xx</p>
<h2 id="idt中断描述符表"><a href="#idt中断描述符表" class="headerlink" title="idt中断描述符表"></a>idt中断描述符表</h2><p>首地址存在于<code>idtr</code>中。每项有8字节。基址2字节，偏移4字节，剩余2字节记录权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lgdt fword ptr gdt ; 把gdt表的首地址和长度载入到gdtr寄存器</span><br><span class="line"></span><br><span class="line">cli</span><br><span class="line">smsw ax</span><br><span class="line">and ax, 1Fh</span><br><span class="line">or al, 1</span><br><span class="line">lmsw ax; enable PE bit of MSW or CR0</span><br><span class="line">db 0EAh ; JMP FAR PTR</span><br><span class="line">dw 00h</span><br><span class="line">dw pseg_</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学随笔</title>
    <url>/2019/06/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="1-6-Rules-of-Inference"><a href="#1-6-Rules-of-Inference" class="headerlink" title="1.6 Rules of Inference"></a>1.6 Rules of Inference</h1><ol>
<li>Modus ponens 假言推理 p &amp; p-&gt;q &#x3D;&gt; q </li>
<li>Modus tollens 取拒式 !q &amp; p-&gt;q &#x3D;&gt; !p</li>
<li>Hypothetical syllogism &#x2F;,haɪpə&#39;θɛtɪk, &#39;sɪlə,dʒɪz(ə)m&#x2F; 假言三段论 p-&gt;q &amp; q-&gt;r &#x3D;&gt; p-&gt;r </li>
<li>Disjunctive syllogism 析取三段论 pVq &amp; !p &#x3D; p</li>
<li>Addtion 附加律 p &#x3D;&gt; pVq  （附加在析取式中）</li>
<li>Simplification 化简律 p&amp;&amp;q &#x3D;&gt; p （合取条件的拆分）</li>
<li>Resolution 消解律 pVq &amp; !pVr &#x3D;&gt; qVr 条件相斥必有一T</li>
<li>? Logical equivalence<span id="more"></span></li>
</ol>
<p>$$ \begin{aligned} Step &amp; Reason \ 1. xxx &amp; Premise \ 2. xxx &amp; Contrapositive,of,(1) \ 3. xxx &amp; XXrule,using,(n),and,(m) \end{aligned} $$</p>
<h2 id="Fallacies-谬误"><a href="#Fallacies-谬误" class="headerlink" title="Fallacies 谬误"></a>Fallacies 谬误</h2><ol>
<li>fallacy of affirming the conclusion 肯定结论的谬误 由结论推出条件</li>
<li>fallacy of denying the hypothesis  &#x2F;haɪ&#39;pɒθɪsɪs&#x2F; 否定假设的谬误 从否定条件推出否定结论</li>
</ol>
<h2 id="Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则"><a href="#Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则" class="headerlink" title="Rules of Inference for Quantified Statements 量化命题的推理规则"></a>Rules of Inference for Quantified Statements 量化命题的推理规则</h2><ol>
<li>Universal instantiation 全称实例 $\forall xP(x) \implies P(c)$</li>
<li>Universal generalization 全称引入 $P(c)$ for an arbitrary $c \implies \forall xP(x)$</li>
<li>Existential instantiaion 存在实例 $\exists xP(x) \implies P(c)$ for some element $c$</li>
<li>Existencial generalization 存在引入 $P(c)$ for some element $c \implies \exists xP(x)$</li>
</ol>
<h2 id="Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements"><a href="#Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements" class="headerlink" title="Combining Rules of Inference for Propositions and Quantified Statements"></a>Combining Rules of Inference for Propositions and Quantified Statements</h2><ol>
<li>Universal modus ponens 全称假言推理 对某个全称实例应用假言推理</li>
<li>Universal modus tollens 全称取拒式 对某个全称实例应用取拒式（否定结论推出否定条件）</li>
</ol>
<hr>
<h1 id="1-7-Introduction-to-Proofs"><a href="#1-7-Introduction-to-Proofs" class="headerlink" title="1.7 Introduction to Proofs"></a>1.7 Introduction to Proofs</h1><ol>
<li>theorem &#x2F;&#39;θɪərəm&#x2F; 定理 （定理的证明有定义、其他定理、公理、推断规则）</li>
<li>lemma &#x2F;&#39;lemə&#x2F; 引理 用于证明定理的其他定理</li>
<li>corollary &#x2F;kə&#39;rɒlərɪ&#x2F; 推论 定理下的直接结论</li>
<li>propositions 命题 偶尔用来称呼不重要的定理，或称事实、结论</li>
<li>conjecture &#x2F;kən&#39;dʒektʃə&#x2F; 猜想 一旦找到证明，猜想就变成定理；也有可能被证伪</li>
</ol>
<h2 id="To-Proof-p-gt-q-or-to-proof-p"><a href="#To-Proof-p-gt-q-or-to-proof-p" class="headerlink" title="To Proof p-&gt;q (or to proof p)"></a>To Proof p-&gt;q (or to proof p)</h2><ol>
<li>Trivial Proof : 平凡证明 if q is true then p-&gt;q is true.</li>
<li>Vacuous Proof : 空证明 if p is false then p-&gt;q is true.</li>
<li>Direct Proof : Assume p is true and show that q is true by using inferences, axioms, logical equivalences.</li>
<li>Indirect Proof : not begin with the premises and not end with the conclusion</li>
<li>Proof by contraposition 反证法 : Assume !q and show !p is true also. 直接证明法无效时尝试反证法</li>
<li>Proof by Contradiction 归谬证明法 : To proof p, first find a r such that !p -&gt; (r &amp;&amp; !r) is true, therefore !p is false and p is true. 假设结论的否定为真，引出一个矛盾</li>
<li>反例证明法 : 指明一个反例，从而证伪</li>
</ol>
<hr>
<h1 id="1-8-Proof-Methods-and-Strategy-证明的方法和策略"><a href="#1-8-Proof-Methods-and-Strategy-证明的方法和策略" class="headerlink" title="1.8 Proof Methods and Strategy 证明的方法和策略"></a>1.8 Proof Methods and Strategy 证明的方法和策略</h1><ol>
<li>Proof by cases 分情形证明法 tautology : (p1Vp2V...pn)-&gt;q &lt;-&gt; (p1-&gt;q)&amp;&amp;(p2-&gt;q)&amp;&amp;...(pn-&gt;q) 类似分类讨论</li>
<li>Exhaustive Proof 穷举证明法 当变量的取值比较少的时候，通过测试所有情形来证明。</li>
<li>Without loss of generality (WLOG) 不失一般性 省略非常类似的情形（证明过程几乎相同）的证明</li>
</ol>
<h2 id="Existence-Proof-存在性证明"><a href="#Existence-Proof-存在性证明" class="headerlink" title="Existence Proof 存在性证明"></a>Existence Proof 存在性证明</h2><p>To proof $\exists x P(x)$ :</p>
<ol>
<li>Constructive existence proof 构造性 : Find an explicit c, for which P(c) is true.</li>
<li>Nonconstructive existence proof 非构造性证明 ： 不直接构造例子，但说明多种情况之一必有符合的例子；或若不存在，就得到某些矛盾。</li>
</ol>
<h2 id="Uniqueness-Proof-唯一性证明"><a href="#Uniqueness-Proof-唯一性证明" class="headerlink" title="Uniqueness Proof 唯一性证明"></a>Uniqueness Proof 唯一性证明</h2><p>同时证明存在性和唯一性，即x符合某种期望，而若y!&#x3D;x，则y不符合这种期望。也可以等价地证明若y符合这种期望，则y&#x3D;x。</p>
<hr>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li>The cardinality of  a finite set A 集合的基数，|A|</li>
<li>finite 有限的 &#x2F;faɪnaɪt&#x2F;</li>
<li>infinite 无限的 &#x2F;&#39;ɪnfɪnət&#x2F;</li>
<li>Power Set 幂集 P(A) The set of all subsets of a set A. $|P(A)| &#x3D; 2^{|A|}$</li>
<li>Cartesian Product 笛卡尔积 A x B x C的意义和(A x B) x C不一样！</li>
<li>coordinate</li>
</ol>
<h2 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h2><ol>
<li>Union &#x2F;&#39;junɪən&#x2F;</li>
<li>Intersection</li>
<li>Complementation : complement 补集，必须有universal set U。A上一横杠</li>
<li>Difference 不满足交换律，A-B</li>
<li>Symmetric Difference 对称差 异或</li>
</ol>
<h3 id="Set-Identities-集合恒等式"><a href="#Set-Identities-集合恒等式" class="headerlink" title="Set Identities 集合恒等式"></a>Set Identities 集合恒等式</h3><ol>
<li>注意一下分配率，德摩根律（否定去括号）</li>
<li>其他不管啊太简单了</li>
<li>Membership Tables 成员表，枚举任意元素属于各个集合情况，从而验证恒等式（和真值表类似）</li>
</ol>
<h2 id="Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B"><a href="#Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B" class="headerlink" title="Funtion (f maps A to B) (f is a mapping from A to B)"></a>Funtion (f maps A to B) (f is a mapping from A to B)</h2><ol start="0">
<li>assignment 指派，分配。 指定f(a)&#x3D;b。</li>
<li>domain 定义域 A</li>
<li>codomain 陪域 B</li>
<li>image 像 b is an image of a under f</li>
<li>preimage 原像 可能是单个元素，也可能是一个集合。</li>
<li>f(A) range 值域</li>
<li>等价的函数具有相同的domain &amp; codomain &amp; map each element to the same element of the codomain</li>
<li>$f(S) &#x3D; {f(s)|s\in S}$</li>
<li>$(f_1+f_2)(x) &#x3D; f_1(x)+f_2(x)$</li>
<li>$(f_1*f_2)(x) &#x3D; f_1(x)*f_2(x)$</li>
<li>injection injective 单射 one-to-one 可在值域上定义反函数</li>
<li>surjection surjective (or onto) 满射 映上 陪域中每个元素都能找到原像</li>
<li>injective and surjective &#x3D;&gt; bijection or one-to-one correspondence 双射 一一对应</li>
<li>invertible 可逆的 Inverse Function 反函数</li>
<li>Composition 复合函数 $f \circ g &#x3D; f(g(x))$</li>
<li>Factorial&#x2F;fæk&#39;tɔrɪəl&#x2F; Function 阶乘函数</li>
<li>Partial Function 局部函数，对某个函数截取部分domain</li>
</ol>
<h2 id="Sequence-序列-a-n"><a href="#Sequence-序列-a-n" class="headerlink" title="Sequence 序列 ${a_n}$"></a>Sequence 序列 ${a_n}$</h2><p>A funtion from N or N+ to S<br>$$a_n &#x3D; f(n)$$</p>
<ol>
<li>term 项</li>
<li>Geometric Progression 几何级数 a*r^n, n&#x3D;0,1...  (a and r are real numbers)</li>
<li>Arithmetic Progression 算术级数 （等差数列）</li>
<li>Recurrence relation 递推关系 </li>
<li>a solution of a recurrence relation 满足递推关系的序列称为这个递推关系的一个解</li>
<li>initial conditions 初始条件 递推关系生效前的所有terms</li>
<li>solving the recurrence relation 找到通项公式 这样的公式叫closed formula闭公式</li>
<li>iteration 迭代法，正向替换 working upward； 反向替换 working downward。 用于猜测formula，然后用the method of induction数学归纳法证明。</li>
<li>Summation （序列的部分）总和</li>
<li>in lexicographic order &#x2F;,lɛksɪkə&#39;græfɪk&#x2F; 字典序</li>
</ol>
<h2 id="Matrices-矩阵"><a href="#Matrices-矩阵" class="headerlink" title="Matrices 矩阵"></a>Matrices 矩阵</h2><ol>
<li>Boolean Product 布尔积 类似矩阵乘法，各项求交之后求并</li>
<li>Boolean Powers 多次布尔积。 写作$A^{[n]}$, 记$A^{[n]}&#x3D;I$</li>
</ol>
<hr>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol>
<li>pseudocode &#x2F;&#39;sju:doˌkod&#x2F; 伪代码</li>
<li>Halt Problem 停机问题，无解</li>
<li>Big-O f(x) of big-O of g(x)</li>
<li>|f(x)| &lt; |c*g(x)| (x &gt; k) : the constants c and k are called witnesses. Only one pair of witnesses is needed.</li>
<li>if f &#x3D; O(g) &amp;&amp; g &#x3D; O(f), then the two functions are of the same order.</li>
<li>polynomial &#x2F;,pɒlɪ&#39;nəʊmɪəl&#x2F; 多项式</li>
<li>if |f(x)| &gt; |C*g(x)| (x &gt; k) : Big-Omega</li>
<li>if f &#x3D; O(g) &amp;&amp; g &#x3D; O(f), then f &#x3D; θ(g) : Big-Theta; f(x) is of order g(x).</li>
<li>brute-force 蛮力（算法）</li>
<li>Tractable Problem ：P类问题，多项式时间内解决</li>
<li>Intractable Problem</li>
<li>Unsolvable Problem 无解的问题，例如Halt Problem</li>
<li>Class NP: 可在多项式时间内验证一个解的问题</li>
<li>NP Complete Class: NPC问题，所有的NP问题都能约化为NPC问题。</li>
</ol>
<hr>
<h1 id="Number-Theory-and-Cryptography-数论和密码学"><a href="#Number-Theory-and-Cryptography-数论和密码学" class="headerlink" title="Number Theory and Cryptography 数论和密码学"></a>Number Theory and Cryptography 数论和密码学</h1><p>&#x2F;krɪp&#39;tɑgrəfi&#x2F;</p>
<ol>
<li>divisibility &#x2F;di,vizi&#39;biləti&#x2F; 可除性</li>
<li>hexadecimal &#x2F;,hɛksə&#39;dɛsɪml&#x2F; 十六进制（的）</li>
<li>modular &#x2F;&#39;mɑdjʊlɚ&#x2F; 模的</li>
<li>congruence 同余 &#x2F;&#39;kɑŋgrʊəns&#x2F;</li>
<li>a divides b  a除b， a is a factor or divisor of b, b is a multiple of a.</li>
<li>quotient &#x2F;&#39;kwoʃnt&#x2F;商; remainder &#x2F;rɪ&#39;mendɚ&#x2F;余数</li>
<li>-11 &#x2F; 3 &#x3D; -4 ... 1</li>
<li>The notation a  ≡  b (mod m)  says  that a is <strong>congruent</strong> to b modulo m.   a  ≡  b (mod m) is a congruence and that m is its modulus.</li>
<li>doing arithmatic modulo m: $a+_mb &#x3D; (a+b) \mod m; a*_mb &#x3D; (a*b) \mod m$</li>
</ol>
<h2 id="Zm-x3D-0-m-1"><a href="#Zm-x3D-0-m-1" class="headerlink" title="Zm &#x3D; {0...m-1}"></a>Zm &#x3D; {0...m-1}</h2><ol>
<li>Closure 封闭性</li>
<li>Associativity 结合律</li>
<li>Commutativity 交换律</li>
<li>Identity element 单位元 （加法0，乘法1）</li>
<li>Additive inverse 加法逆元</li>
<li>Distributivity 分配率</li>
<li>判定同余式，左边减右边是m的倍数。</li>
</ol>
<h2 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h2><ol>
<li>composite &#x2F;kɑm&#39;pɑzɪt&#x2F; 合数</li>
<li>divisible by 7 能被7整除</li>
<li>Mersenne Primes 梅森素数：满足2的素数次方减一的素数。检验2的素数次方减一是否素数是容易的，由此得到已知的最大素数。$2^{11}-1不是素数$</li>
<li>Prime Number Theorem: 不超过x的素数个数大约是(x &#x2F; ln x)，任取一个不超过n的数，则这个数是素数的概率是1&#x2F;lnx。</li>
<li>对两个互质的数a,b:ak+b可以生成无限个素数。</li>
<li>存在由任意个素数组成的等差数列（Arithmetic Progression）</li>
<li>现阶段没有发现高效生成素数的算法f(n)</li>
<li>不存在多项式函数f(n)使得其值一定是素数</li>
<li>Goldbach’s Conjecture 哥德巴赫猜想：所有大于2的偶数都能表示为两个素数的和。</li>
<li>Conjecture: There are infinitly many primes of the form $n^2+1$.</li>
<li>The Twin Prime Conjecture: 相差2的素数有无限多组</li>
</ol>
<h2 id="Great-Commom-Divisor-x2F-dɪ-39-vaɪzɚ-x2F"><a href="#Great-Commom-Divisor-x2F-dɪ-39-vaɪzɚ-x2F" class="headerlink" title="Great Commom Divisor &#x2F;dɪ&#39;vaɪzɚ&#x2F;"></a>Great Commom Divisor &#x2F;dɪ&#39;vaɪzɚ&#x2F;</h2><ol>
<li>relatively prime 互质数</li>
<li>pairwise relatively prime 两两互质</li>
<li>Prime Factorizations &#x2F;,fæktərai&#39;zeiʃən&#x2F; 质因数分解</li>
<li>Least Common Multiple 最小公倍数 lcm(a,b)</li>
<li>Euclidean &#x2F;ju:&#39;klidiən&#x2F; 欧几里得的</li>
<li>Bézout’s Theorem 贝祖定理 gcd(a,b) &#x3D; sa+tb. （求s、t用扩展欧几里得）</li>
<li>if gcd(a,b)&#x3D;1 &amp;&amp; a|bc, then a|c; Therefore, a ≡ b (mod m) if ac ≡ bc (mod m) &amp;&amp; gcd(c,m)&#x3D;1.</li>
</ol>
<h2 id="Solving-Congruences"><a href="#Solving-Congruences" class="headerlink" title="Solving Congruences"></a>Solving Congruences</h2><ol>
<li>linear congruences 线性同余方程 ax≡b ( mod m)</li>
<li>an inverse of A modulo m 模m下a的乘法逆元</li>
<li>逆元存在的充要条件：若gcd(a,m)&#x3D;1, 则存在a在模m下的乘法逆元。 Proof: Since gcd(a,m)&#x3D;1, there are integers s and t such that sa+tm&#x3D;1. Hence, sa+tm ≡ 1 ( mod m), and it follows that sa ≡ 1 ( mod m). 用扩展欧几里得求出s即逆元。</li>
<li>coefficient &#x2F;koʊəˈfɪʃənt&#x2F; 系数</li>
<li>Chinese Remainder Theorem: 对于模数两两互质的同余方程组（一条方程的形式为$x≡a_i (\mod m_i), m&gt;1$）,在$模M&#x3D;\prod\limits_{i&#x3D;1}^n m_i系$中有且仅有唯一解。一个解的构造为$x &#x3D; \sum\limits_{i&#x3D;1}^n a_i M_i y_i$, 其中$M_i &#x3D; M\div m_i, y_i*M_i≡1 (\mod m_i)$。如此构造后，对任意的i，都满足同余方程$x ≡ a_i M_i y_i ≡ a_i (\mod m_i)$。模系下的唯一性<strong>待证 练习30</strong>。</li>
<li>Fermat’s Little Theorem： $有质数p，有整数a不是p的倍数，则a^{p-1}≡1(\mod p)$</li>
<li>利用费马小定理可以简化$a^q \mod p$的运算，其中q很大。可以将q替换为$(q \mod (p-1))$</li>
<li>满足$b^{n-1}≡1(\mod n)$的非质数n成为以b为基的伪质数 Pseudoprimes to the base b。（苏豆）</li>
<li>因为在一定范围内的对于某个基的pseudoprimes总是很少，所以可以进行质数近似判定测试。可惜，对于某些数n，对于所有基b满足gcd(b,n)&#x3D;1，总是能通过伪素数测试，即$b^{n-1}≡1(\mod n)$，这些数称为Carmichael Numbers（卡麦抠 卡米切尔）。 Carmichael Numbers有无穷多个。</li>
<li>欧拉定理：费马小定理的推广。$有互质整数a,n.则a^{\phi(n)}≡1 (\mod n)$，而a在模n意义下存在逆元的充要条件就是a,n互质，从而得到推论：若a的逆元存在，则为$a^{\Phi(n)-1}$。</li>
<li>Discrete Logarithms (模p意义下的)离散对数 对已知质数p，在模p意义下存在唯一一个primitive root $r$ 原始根，使得$r^n$取遍所有模p意义下所有非零数。 对任意$a\in [1,p-1]$，若有$r^e≡a(\mod p), e \in [1, p-1]$ ，则即$\log_r a&#x3D;e$</li>
<li>求discrete logarithms $\log_r a$(模质数p意义下)没有找到多项式时间的算法。这个问题是密码学的一部分。</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程实战</title>
    <url>/2021/11/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="前方施工中"><a href="#前方施工中" class="headerlink" title="前方施工中"></a>前方施工中</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://chenshuo.com/practical-network-programming/">chenshuo.com&#x2F;pnp</a></li>
<li><a href="https://www.bilibili.com/video/BV1TA411q75p">陈硕-网络编程实战(TCP&#x2F;UDP&#x2F;Socket)</a></li>
<li>原来的 <a href="http://boolan.com/course/10093">Boolan 博览课</a>已经 404</li>
</ul>
<span id="more"></span>

<h2 id="如何保证可靠的-TCP-连接"><a href="#如何保证可靠的-TCP-连接" class="headerlink" title="如何保证可靠的 TCP 连接"></a>如何保证可靠的 TCP 连接</h2><h3 id="发送比接收更难"><a href="#发送比接收更难" class="headerlink" title="发送比接收更难"></a>发送比接收更难</h3><ul>
<li>按难度排序：<ol>
<li>服务器建立 TCP &lt; 客户端建立 TCP &lt; 销毁 TCP</li>
<li>接收 TCP 数据 &lt; 发送 TCP 数据 （尤其在非阻塞 IO 中）</li>
</ol>
</li>
<li>常见错误：<code>send()</code>+<code>close()</code> 导致丢数据<ul>
<li>如果接收缓冲区里有数据，<code>close()</code> 会导致 RST 段（而不是 FIN 段）强行断连，不论发送缓冲区是否为空，导致对方丢数据。</li>
<li><code>SO_LINGER</code> 不能解决这个问题。</li>
<li>正确发送端做法：<code>send()</code>+<code>shutdown_write()</code>+<code>read_until_eof()</code>+<code>close()</code></li>
<li>正确接收端做法：<code>read() -&gt; 0</code> + nothing to send + <code>close()</code></li>
<li>再考虑服务器防御：<code>shutdown_write()</code> 后设置超时，无论如何都关闭连接。</li>
<li>更好的做法是在协议中包含数据长度，使 App 能够判断数据是否完整。</li>
<li>还有一点漏洞：sender 无法保证 receiver 已经正确处理数据，例如 receiver 崩溃时，sender 也会读到 eof。</li>
</ul>
</li>
</ul>
<h3 id="启用-SO-REUSEADDR"><a href="#启用-SO-REUSEADDR" class="headerlink" title="启用 SO_REUSEADDR"></a>启用 SO_REUSEADDR</h3><ul>
<li>允许重复监听同一个端口<ul>
<li>以便 server 崩溃之后可以立即重启</li>
<li>以便多进程 server 监听同一个端口</li>
</ul>
</li>
</ul>
<h3 id="在-Server-中处理-SIGPIPE-信号"><a href="#在-Server-中处理-SIGPIPE-信号" class="headerlink" title="在 Server 中处理 SIGPIPE 信号"></a>在 Server 中处理 SIGPIPE 信号</h3><ul>
<li>在 Linux I&#x2F;O 中，若输出管道已经关闭，则 writer 会收到 SIGPIPE 信号。默认的反应行为是中止进程。</li>
<li>默认行为在多数场景下十分好用，可以提前结束工作流，减少 CPU 浪费。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip -c huge.log.gz | grep ERROR | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
然而在网络编程中，若 Client 已经关闭，则 Server 同样会收到 SIGPIPE 信号。</li>
<li>Server 应当小心处理 SIGPIPE 信号，以防 Client 出错或者恶意响应。</li>
<li>若直接忽略 SIGPIPE 信号，则应当检查<code>printf()</code>的返回值，在出错时<code>exit()</code>。</li>
</ul>
<h3 id="Nagle-算法-TCP-NODELAY"><a href="#Nagle-算法-TCP-NODELAY" class="headerlink" title="Nagle 算法, TCP_NODELAY"></a>Nagle 算法, TCP_NODELAY</h3><ul>
<li>影响「请求-响应」型协议。</li>
<li>如果有报文段未收到 ack，<code>write()</code> 就不会发送数据，避免应用层太拉发太多小数据。</li>
<li>对于「写-写-读」模式，第二次写会被延迟一个 RTT(Round-Trip Time, 往返延迟)。<ul>
<li>解决办法：应用层缓冲，改成「写-读」模式</li>
<li>然而难以解决并发请求问题</li>
</ul>
</li>
<li>应当考虑关闭 Nagle 算法<ul>
<li>Go 语言就是这么干的</li>
</ul>
</li>
</ul>
<h2 id="起线程还是-IO-复用"><a href="#起线程还是-IO-复用" class="headerlink" title="起线程还是 IO 复用"></a>起线程还是 IO 复用</h2><p>服务器应该选用「thread-per-connect」还是「IO-multiplexing」模式？</p>
<p>开销的根源在于切换。起线程会有切换开销，IO 复用也有系统调用的开销。</p>
<ul>
<li>若客户端不超过硬件并发数，就（几乎）没有线程切换开销。</li>
<li>若客户端很多，则 IO 复用的系统调用开销小于线程切换开销。</li>
</ul>
<h2 id="netcat-实现"><a href="#netcat-实现" class="headerlink" title="netcat 实现"></a>netcat 实现</h2><ol>
<li>阻塞式，2 threads per connection</li>
<li>IO-multiplexing</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络提纲</title>
    <url>/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a><ul>
<li><a href="#13-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.3 互联网的组成</a><ul>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F">交换方式</a></li>
</ul>
</li>
<li><a href="#15-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%B1%BB%E5%88%AB">1.5 计算机网络的类别</a><ul>
<li><a href="#%E6%8C%89%E7%85%A7%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB">按照网络的作用范围分类</a></li>
</ul>
</li>
<li><a href="#16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD">1.6 计算机网络的性能</a><ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">性能指标</a><ul>
<li><a href="#%E9%80%9F%E7%8E%87">速率</a></li>
<li><a href="#%E5%B8%A6%E5%AE%BD">带宽</a></li>
<li><a href="#%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a></li>
<li><a href="#%E6%97%B6%E5%BB%B6">时延</a></li>
<li><a href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">时延带宽积</a></li>
<li><a href="#%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4">往返时间</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E7%8E%87">利用率</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.7 计算机网络体系结构</a><ul>
<li><a href="#%E5%8D%8F%E8%AE%AE">协议</a><ul>
<li><a href="#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">五层协议的体系结构</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98">习题</a></li>
</ul>
</li>
<li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2 物理层</a><ul>
<li><a href="#21-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.1 物理层的基本概念</a></li>
<li><a href="#22-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">2.2 数据通信的基础知识</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E5%9E%8B">数据通信系统的模型</a></li>
<li><a href="#%E6%9C%89%E5%85%B3%E4%BF%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">有关信道的几个概念</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">常用的编码方式</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95">基本的带通调制方法</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">信道的极限容量</a><ul>
<li><a href="#%E4%BF%A1%E9%81%93%E8%83%BD%E9%80%9A%E8%BF%87%E7%9A%84%E9%A2%91%E7%8E%87%E8%8C%83%E5%9B%B4">信道能通过的频率范围</a></li>
<li><a href="#%E4%BF%A1%E5%99%AA%E6%AF%94">信噪比</a></li>
<li><a href="#%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F">香农公式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.3 物理层下面的传输媒体</a><ul>
<li><a href="#%E5%BC%95%E5%AF%BC%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">引导型传输媒体</a></li>
<li><a href="#%E9%9D%9E%E5%BC%95%E5%AF%BC%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">非引导型传输媒体</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a></li>
<li><a href="#25-%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F">2.5 数字传输系统</a></li>
<li><a href="#26-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.6 宽带接入技术</a><ul>
<li><a href="#adsl%E6%8A%80%E6%9C%AF">ADSL技术</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1">习题</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3 数据链路层</a><ul>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">点对点信道的数据链路层</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%B8%A7">数据链路和帧</a></li>
<li><a href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">三个基本问题</a></li>
</ul>
</li>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEppp">点对点协议PPP</a><ul>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9">PPP协议的特点</a></li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F">PPP协议的帧格式</a></li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">PPP协议的工作状态</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-2">习题</a></li>
</ul>
</li>
</ul>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ol>
<li>电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li>
<li>报文交换：整个报文传送到相邻结点，全部储存下来后查找转发表，转发到下一个结点。</li>
<li>分组交换：单个分组（整个报文的一部分）传送到相邻结点，储存下来后查找转发表，转发到下一个结点。</li>
</ol>
<h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="按照网络的作用范围分类"><a href="#按照网络的作用范围分类" class="headerlink" title="按照网络的作用范围分类"></a>按照网络的作用范围分类</h3><ol>
<li>广域网 (Wide Area Network, WAN)，远程网，长距离，高速链路，较大通信容量。</li>
<li>城域网 (Metropolitan Area Network, MAN)，多个局域网，一个城市，常用以太网技术。</li>
<li>局域网 (Local Area Network, LAN)，微型计算机或工作站通过高速通信线路相连。</li>
<li>个人区域网 (Personal Area Networl, PAN)，个人使用的电子设备。</li>
</ol>
<h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><ul>
<li>1Mbps &#x3D; $10^6$ bits &#x2F; second</li>
<li>1MB &#x3D; $2^{20}$ Bytes</li>
</ul>
<h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul>
<li>某个信号具有的频带宽度（300Hz &lt;-&gt; 3.4 kHz &#x3D;&#x3D;&gt; 3.1kHz），频域</li>
<li>某通道传输数据的能力，时域</li>
</ul>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul>
<li>单位时间内通过某个网络（或信道、接口）的实际数据量</li>
</ul>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ol>
<li>发送时延（传输时延）（transmission delay）：发送数据帧所需的时间，与发送器（网络适配器）有关。$发送时间 &#x3D; \frac{数据长度}{发送速率}$</li>
<li>传播时延（propagation delay）：电磁波传播花费的时间，与线路有关</li>
<li>处理时延：收到分组后的计算耗时</li>
<li>排队时延：输入队列、输出队列耗时</li>
</ol>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>传播时延 * 带宽。表示线路的“容积”</p>
<h4 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h4><p>（Round-Trip Time, RTT）最后一帧的传播延迟+ack的传播延迟（假设忽略发送时延）</p>
<p>$有效数据率 &#x3D; \frac{数据长度}{发送时间+\text{RTT}}$</p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><ul>
<li>信道利用率：信道有数据通过的时间的比率</li>
<li>网络利用率：全网络的信道利用率的加权平均值</li>
</ul>
<p>设$D_0$为网络空闲时（利用率0%）的时延，$D$表示当前网络时延，当前利用率$U$，则$D &#x3D; \frac{D_0}{1-U}$。</p>
<h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><ul>
<li>系统网络体系结构 SNA（System Network Architecture）。IBM开发。</li>
<li><strong>开放系统互连基本参考模型 OSI&#x2F;RM</strong>（Open Systems Interconnection Reference Model）ISO制定。</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><p>定义：为进行网络中的数据交换而建立的规则、标准或约定</p>
</li>
<li><p>三要素：语法，语义，同步</p>
</li>
</ul>
<h4 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h4><p><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<p>无论哪一层传送的数据单元，都笼统地用“<strong>分组</strong>”或“<strong>协议数据单元PDU（Protocol Data Unit）</strong>”来表示</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><strong>application layer</strong></p>
<p>负责应用进程间交互。  协议定义进程间通信和交互的规则。</p>
<p>如：域名系统DNS；HTTP协议；SMTP协议；</p>
<p>数据单元称为<strong>报文（message）</strong>。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p><strong>transport layer</strong></p>
<p>负责为进程间通信提供<strong>通用的</strong>数据传输服务。</p>
<p>一个主机，多个进程 &#x3D;&gt; 传输层有复用和分用的功能</p>
<p>主要协议：  </p>
<ul>
<li>传输控制协议 TCP（Transmission Control Protocol）：面向连接的、可靠的数据传输服务。数据传输的单位是<strong>报文段（segment）</strong></li>
<li>用户数据报协议 UDP（User Datagram protocol）：无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性）。数据传输的单位是<strong>用户数据报</strong></li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>network layer</strong></p>
<p>也叫网际层、IP层。</p>
<p>负责为分组交换网上的不同主机提供通信服务。 发送数据时，将运输层的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</p>
<p>在TCP&#x2F;IP中，网络层使用IP协议，所以分组也叫<strong>IP数据报</strong>，简称数据报。</p>
<p>网络层要选择合适的路由。</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p><strong>data link layer</strong></p>
<p>将网络层的包<strong>组装成帧（framing）</strong>，在两个相邻结点之间传送<strong>帧（frame）</strong>。每一帧包括数据和<strong>控制信息</strong>（如同步信息、地址信息、差错控制等）。</p>
<p>控制信息指出了数据在哪、校验或纠错信息。如果发现差错，可以<strong>丢弃</strong>这一帧。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p><strong>physical layer</strong></p>
<p>数据单位是<strong>比特</strong>。负责关注电压和电缆的引脚。</p>
<p>电缆、无线信道等物理媒体不是物理层关注的。如何解释0和1的意义也不是物理层负责的。</p>
<hr>
<p>同层次之间可以屏蔽下层的工作，看作把协议数据单元直接传送给“<strong>对等层（peer layers）</strong>”。</p>
<p>每一层在协议的控制下为上一层提供<strong>服务</strong>。要实现本层协议，需要依赖下一层提供的服务。</p>
<p>每一层协议只能看见下一层的服务。 下面的协议对上面的实体是透明的。</p>
<p>OSI把层与层之间交换的数据的单位称为*<em>服务数据单元SDU（Service Data Unit）</em></p>
<p>计算机网络的协议必须把<strong>所有</strong>不利的条件都事先估计到，而不能假定一切都是正常的和理想的。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>OSI的三个核心概念是服务、接口、协议。</li>
<li>原数据1000字节，七层体系结构，每层20字节的头。则头占用了$140&#x2F;1140 &#x3D; 12%$的带宽。</li>
<li>最早实现分组交换（<strong>packet switched</strong>）的网络是<strong>ARPAnet</strong>。</li>
<li>网络层控制了子网的操作、决定分组的路由。</li>
<li>应用层有一系列用户常用的协议。</li>
<li>表示层（<strong>presentation</strong>）关心数据的语法和语义。</li>
<li>数据链路层将原始传输设备转换为一个已检错的线路。</li>
<li>能将信息发往部分机器的广播形式叫多播（<strong>multicasting</strong>）。</li>
<li>协议是实体如何进行交流的约定。</li>
<li>各种协议的实现细节不属于网络体系结构的内容。</li>
<li>一个计算机网络可以看作一些自主计算机系统的连接。</li>
<li>发送速率是10Mbps，考虑同轴线缆的传播速度是光速的$\frac{2}{3}$，则1bit的长度是20米。</li>
<li>OSI的失败在于技术、耗时、实现、政策。</li>
<li>数据包在向上层传递时，头部将会被删除。</li>
<li>卫星组网，回应请求的延迟按4倍的距离算。</li>
<li>储存转发传输（<strong>Store-and-forward transmission</strong>）意味着路由器要储存整个包的内容。</li>
<li>数据转换和压缩是由表示层完成的。</li>
<li>接口定义了低层向高层提供的原始操作和服务。</li>
</ol>
<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2 物理层"></a>2 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层的主要任务是确定与传输媒体接口相关的一些特性，即：  </p>
<ol>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ol>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><p>三大部分：  </p>
<ol>
<li>源系统（发送端、发送方）</li>
<li>传输系统（传输网络）</li>
<li>目的系统（接收端、接收方）</li>
</ol>
<p>源系统、目的系统可细分为：</p>
<ol>
<li>源点（<strong>source</strong>）</li>
<li>发送器（数字比特流-&gt;模拟信号）</li>
<li>接收器（模拟信号-&gt;数字比特流）</li>
<li>终点（destination）</li>
</ol>
<h3 id="有关信道的几个概念"><a href="#有关信道的几个概念" class="headerlink" title="有关信道的几个概念"></a>有关信道的几个概念</h3><p>从通信的双方信息交互来看，三种基本方式：  </p>
<ol>
<li>单向通信（单工通信）</li>
<li>双向交替通信（半双工通信）</li>
<li>双向同时通信（全双工通信）</li>
</ol>
<p>“单工”有时也表示双向交替通信。</p>
<p>来自信源的信号称为<strong>基带信号</strong>（基本频带信号）。信道不能传输低频分量或直流分量，故需要对基带信号进行<strong>调制（modulation）</strong>。</p>
<p>调制的分类：</p>
<ol>
<li><strong>基带调制</strong>（<strong>编码</strong>）：对波形变换，变换后仍是基带信号，仍是数字信号。</li>
<li><strong>带通调制</strong>：使用<strong>载波（carrier）</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。载波调制后的信号成为<strong>带通信号</strong>（仅在一段频率范围内能通过信号）。</li>
</ol>
<h4 id="常用的编码方式"><a href="#常用的编码方式" class="headerlink" title="常用的编码方式"></a>常用的编码方式</h4><p><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="数字信号常用的编码方式"></p>
<ol>
<li><strong>不归零制</strong>：电平代表01</li>
<li><strong>归零制</strong>：脉冲代表01；位开始边界总是中间电平。</li>
<li><strong>曼彻斯特编码</strong>：位周期中心跳变代表01.</li>
<li><strong>差分曼彻斯特编码</strong>：位中心总是跳变；位开始边界跳变为0，不跳变为1。</li>
</ol>
<p>自同步：从信号波形本身提取信号时钟频率。</p>
<h4 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h4><p><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="基本的带通调制方法"></p>
<ol>
<li><strong>调幅（AM）</strong>：振幅随数字信号变化。<br>2.<strong>调频（FM）</strong>：频率随数字信号变化。</li>
<li><strong>调相（PM）</strong>：初相位随数字信号变化。</li>
</ol>
<p>为了更高的信息传输速率，必须采用多元制的振幅相位混合调制方法。例如<strong>正交振幅调制QAM（Quadrature Amplitude Modulation）</strong>。</p>
<h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>限制码元在信道上的传输速率的因素有两个：  </p>
<ol>
<li>信道能通过的频率范围</li>
<li>信噪比</li>
</ol>
<h4 id="信道能通过的频率范围"><a href="#信道能通过的频率范围" class="headerlink" title="信道能通过的频率范围"></a>信道能通过的频率范围</h4><p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间的清晰界限。</p>
<p><strong>奈氏准则</strong>：算出理想条件下、避免码间串扰，码元的传输速率的上限值。超过此上限，接收端对码元的识别成为不可能。</p>
<p>信道的频带越宽，能通过的信号高频分量越多，就可用更高速率传送码元而不出现码间串扰。</p>
<h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>信噪比就是信号的平均功率和噪声的平均功率之比，记为$S&#x2F;N$。</p>
<p>$$<br>\text{信噪比(dB)} &#x3D; 10 \log_{10}(S&#x2F;N) \text{(dB)}<br>$$</p>
<h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><p><strong>信道的极限信息传输速率</strong>$C$：</p>
<p>$$<br>C &#x3D; W \log_2(1 + S&#x2F;N) \text{(bit&#x2F;s)}<br>$$</p>
<p>$W$是信道的带宽(Hz)，S是信道内所传信号的平均功率，N是信道内高斯噪声功率。</p>
<p>只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p>
<p>要提高信息的传输速率，还可用编码的方法让每一个码元携带更多比特的信息量。</p>
<h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><p><strong>传输媒体</strong>（传输介质，传输媒介）是发送器和接收器之间的物理通路。可分为两大类：<strong>引导型（guided）</strong>，<strong>非引导型</strong>。</p>
<p>引导型沿着固体媒体传播；非引导型指向自由空间，无线传输。</p>
<h3 id="引导型传输媒体"><a href="#引导型传输媒体" class="headerlink" title="引导型传输媒体"></a>引导型传输媒体</h3><ol>
<li><strong>双绞线（twisted pairs）</strong>：最常用，便宜，性能不错。距离太长时需要放大器（模拟传输）或中继器（数字传输），加粗导线。<strong>屏蔽双绞线（STP，Shielded Twisted Pair）</strong>；<strong>无屏蔽双绞线（UTP，Unshielded Twisted Pair）</strong>。</li>
<li><strong>同轴电缆（coaxial cable）</strong></li>
<li><strong>光缆（fiber cable）</strong></li>
</ol>
<h3 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h3><p>短波（高频）通信：靠电离层的反射；多径效应，质量较差，低速传输。</p>
<p> 微波通信：  </p>
<ol>
<li>地面微波接力通信</li>
<li>卫星通信</li>
</ol>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol>
<li><strong>频分复用（FDM, Frequency Division Multiplexing）</strong>：用户始终占用不同频带</li>
<li><strong>时分复用（TDM）</strong>：更有利于数字信号的传输。利用率不高，若用户太多则时隙太短。</li>
<li><strong>统计时分复用（STDM, Statistic）</strong>：保存用户信息头，有额外花销。</li>
<li><strong>波分复用（WDM, Wavelength Division Multiplexing）</strong>：光的频分复用。光载波频率很高，因此常用波长。</li>
<li><strong>密集波分复用（DWDN, Dense）</strong>：一根光纤上复用几十或更多路。</li>
<li><strong>码分复用（CDM, Code），码分多址CDMA（Code Division Multple Access）</strong>：频谱类似于白噪声，不易被发现；抗干扰能力强。</li>
</ol>
<h2 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h2><h2 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h2><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p><strong>非对称数字用户线ADSL（Asymmetric Digital Subscriber Line）</strong>技术是用数字技术对线有的模拟电话用户线进行改造，使其承载宽带数字业务。</p>
<p>ADSL传输距离取决于数据率和用户线的线径。实际最高数据传输速率还与用户线上的信噪比密切相关。</p>
<p><strong>离散多音调 DMT（Discrete Multi-Tone）</strong>调制技术：频分复用（24kHz - 1.1MHz）划分为许多子信道。相当于许多的调制解调器并行地传送数据。</p>
<p>ADSL自适应地调整可用频率以避开干扰，可见不能保证固定的数据率</p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>ICMP属于网络层</li>
<li>SDLC, PPP, HDLC属于数据链路层</li>
<li>红外线在光纤中衰减。现有波段是0.85，1.30，1.55（微米，e-6）</li>
<li>电路交换不使用储存转发传输技术。</li>
<li>10base5，一种以太网标准，该标准用于使用粗同轴电缆（Thick coaxialcable）、速度为10Mbps的基带局域网络，基于曼彻斯特编码。在总线型网络中，最远传输距离为500米。</li>
<li>波特率（baud rate）为1000的信道，若其电平级数为16（2^4），则数据率（data rate）可达4Kbps。</li>
<li>影响数据传输率的因素有信噪比、频率带宽、调制效率（Modulation rate）。不受传播速率影响。</li>
<li>频分复用时，最左右两侧可不设置保护频段。</li>
<li><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90.png" alt="电话系统结构"></li>
<li>光纤具有较好的抗干扰性</li>
<li>二元信号，3KHz信道，信噪比S&#x2F;N 31，最大传输数据率为6Kbps。（当做无噪声信道计算）</li>
<li>E1载波，2.048Mbps速率的PCM载波，同步时分复用，30个话音信道（64K）和两个控制信道（16K）。  开始和中间各有8位分别做同步和信令；30路8位数据；组成一帧，256位，每一帧125us时间（每秒8000帧）。 开销占比2&#x2F;32 &#x3D; 6.25%， 有效数据率1.92Mbps。</li>
<li>T1载波，24个信道（每个8bit），外加1bit帧同步数据，共193bit每帧。每个8bit中有1bit是控制数据。对一路语音通道，数据比特率是7b&#x2F;125us&#x3D;56kb&#x2F;s。总的比特率193b&#x2F;125us&#x3D;1.544Mb&#x2F;s。开销占比(1*24+1)&#x2F;193 &#x3D; 13%。</li>
<li><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BF%A1%E9%81%93%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87.png" alt="信道最大传输速率"></li>
<li>物理层关心在一个通信信道上传输纯比特。</li>
</ol>
<h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3 数据链路层"></a>3 数据链路层</h1><p>主要信道类型：  </p>
<ol>
<li>点对点信道</li>
<li>广播信道</li>
</ol>
<h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>数据链路 &#x3D; 物理链路 + 通信协议</p>
<p>常用<strong>网络适配器</strong>实现这些硬件和软件，适配器也含有物理层的功能。</p>
<p>网络层交下来的数据构成<strong>帧</strong>——数据链路层的协议数据单元。 帧上交到网络层组成IP数据包（数据包、分组、包）。</p>
<p>点对点信道在数据链路层通信时的主要步骤：  </p>
<ol>
<li>网络层（IP数据报）-&gt;数据链路层</li>
<li>数据链路层添加首部尾部，成帧</li>
<li>帧发送到另一结点</li>
<li>接受者的数据链路层检错（有错则丢弃帧），提取IP数据报-&gt;网络层</li>
</ol>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ol>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ol>
<p>封装成帧：</p>
<p>链路层协议规定了<strong>最大传输单元（MTU, Maximum Transfer Unit）</strong>，表示帧能容纳的最大数据（不计首部和尾部）。</p>
<p>如果数据是ASCII编码的文本文件，帧头标记是<strong>SOH(Start Of Header, 0x01)<strong>，帧尾标记是</strong>EOT(End Of Transmission，0x04)</strong> 。</p>
<p>透明传输：</p>
<p>若文本无需处理（不会出现SOH和EOT），则传输是<strong>透明传输</strong>。</p>
<p>若文本无法透明传输，可以用<strong>字节填充（byte stuffing）</strong>或<strong>字符填充（character stuffing）</strong>。在特殊字符前插入<strong>转义字符</strong>“<strong>ESC（0x1B）</strong>”。例如文本含&quot;0x1B&quot;，就传输 &quot;0x1B 0x1B&quot;。</p>
<p>数据链路层还原IP数据报时需要去除转义信息。</p>
<p>差错检测：</p>
<p><strong>误码率（BER, Bit Error Rate）</strong>指单位时间内错误比特的比率。</p>
<p><strong>循环冗余检验（CRC, Cyclic Redundancy）</strong></p>
<p>假设传送数据$M$，<em>事先约定</em>除数$P\text（n+1位二进制）$，做异或取模$R\text{(n位二进制)} &#x3D;  2^nM \mod P$。</p>
<p>$R$作为<strong>帧检验序列（FCS, Frame Check Sequence）</strong>，也放在数据末尾。</p>
<p>接收端直接做异或取模，若无差错，余数为0。</p>
<p>用多项式表示，除数$P&#x3D;1100&#x3D;X^3 + X^2 + 1$。</p>
<p>现在可以近似认为“凡是接收端数据链路层接收的帧均无差错”。但尚未考虑<strong>帧丢失、重复、失序</strong>等问题，即非<strong>可靠传输</strong>。</p>
<p>OSI要求可靠传输，因此有CRC，<strong>帧编号、确认</strong>和<strong>重传机制</strong>。但现在的数据链路层不使用确认和重传，而将差错交给上层协议（如运输层TCP）来处理。</p>
<h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP协议是用户和ISP通信时使用的数据链路层协议。</p>
<h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ol>
<li>简单。将繁杂任务丢给TCP&#x2F;IP。不纠错，无序号，无流量控制。仅做CRC检验。</li>
<li>封装成帧。使用帧定界符。</li>
<li>透明性。规避文本出现的帧定界符。</li>
<li>支持多种网络层协议，在同一物理链路上。</li>
<li>支持多种链路。</li>
<li>差错检测。立即丢弃错误帧。</li>
<li>检测连接状态。及时发现链路故障或恢复。</li>
<li>最大传送单元MTU的标准默认值。</li>
<li>网络层地址协商。使通信的两个网络层知道或配置彼此的网络层地址。</li>
<li>数据压缩协商。</li>
</ol>
<p>PPP不需要的功能：  </p>
<ol>
<li>纠错</li>
<li>流量控制</li>
<li>序号（PPP不是可靠传输协议）</li>
<li>多点线路</li>
<li>半双工或单工链路（PPP仅支持全双工链路）</li>
</ol>
<p>PPP协议的组成：  </p>
<ol>
<li>IP数据包封装到串行链路的方法。PPP既支持异步链路（无奇偶校验的8比特数据），也支持面向比特的同步链路。</li>
<li><strong>链路控制协议LCP（Link Control Protocol）</strong>。建立、配置和测试数据链路连接。</li>
<li><strong>网络控制协议NCP（Network Control Protocol）</strong>。用来支持不同的网络层协议。</li>
</ol>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><p><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PPP%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="PPP协议的帧格式"></p>
<p>当“协议”为0x0021就是IP数据包，<br>为0xC021就是LCP数据，<br>为0x8021就是网络层的控制数据。</p>
<p>字节填充：</p>
<p>异步：  </p>
<ol>
<li>0x7E -&gt; (0x7D, 0x5E)</li>
<li>0x7D -&gt; (0x7D, 0x5D)</li>
<li>ASCII控制字符（小于0x20） -&gt; (0x7D 0x??)</li>
</ol>
<p>零比特填充： 用于SONET&#x2F;SDH链路，同步传输<br>信息字段中5个连续的1后插入一个0。有效避开了0x7E。</p>
<h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><p><img src="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="PPP协议的状态图"></p>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><ol>
<li>selective repeat protocol 最大接受窗口为$2^M-1$</li>
<li>Go-Back-N 最大接收窗口是$2^{M-1}$（默认接收窗口大小 &#x3D; 发送窗口大小）</li>
<li>CRC异或取模。别忘了先左移n位</li>
<li>纠错需要距离为2d+1比特的编码</li>
<li>检测需要距离为d+1比特的编码</li>
<li>数据链路层的功能：为网络层提供明确的服务接口；调节数据流，以帮助慢速接收者不被淹没。</li>
<li>处理传输错误</li>
<li>PPP提供了NCP，LCP和帧的封装方法</li>
<li>？？？PPP提供了协商网络层选项的方法（而不是SLIP, BOOTP, HDLC）</li>
<li>PPP, HDLC, SDLC(同步) 属于数据链路层。ICMP属于网络层。</li>
<li>PPP帧包括flags，address，control，protocol，payload，checksum。</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>识趣</title>
    <url>/2019/04/07/%E8%AF%86%E8%B6%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="换底公式"><a href="#换底公式" class="headerlink" title="换底公式"></a>换底公式</h3><p>$\log_ab &#x3D; \frac{\ln b}{\ln a}$</p>
<blockquote>
<p>证明：<br>$e^{\ln a * \log_an} &#x3D; b$ 两边取对数，移项。</p>
</blockquote>
<p>$A^{\log_bC} &#x3D; C^{\log_bA}$</p>
<blockquote>
<p>证明：两边取对数，得$\log_bC \ln A &#x3D; \frac{\ln C}{\ln b}*\ln A$</p>
</blockquote>
<h3 id="分治的时间复杂度"><a href="#分治的时间复杂度" class="headerlink" title="分治的时间复杂度"></a>分治的时间复杂度</h3><p>$T(N) &#x3D; aT(N&#x2F;b) + \Theta(N^k \log_p N)$</p>
<p>$$<br>T(N) &#x3D; \begin{cases}<br>O(N^{\log_b a})&amp; \text{if }a &gt; b^k \<br>O(N^k \log_{p+1} N)&amp; \text{if }a &#x3D; b^k \<br>O(N^k \log_{p} N)&amp; \text{if }a &lt; b^k \<br>\end{cases}<br>$$</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><h4 id="sin-cos-tan知一求二"><a href="#sin-cos-tan知一求二" class="headerlink" title="sin,cos,tan知一求二"></a>sin,cos,tan知一求二</h4><p>试试$(\tan^2x)^{(-1)^k}+1 &#x3D; ?$</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
