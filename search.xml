<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CG with OpenGL</title>
    <url>/2020/09/19/CG-with-OpenGL/</url>
    <content><![CDATA[<p>更新：现在都用核心模式了，推荐<a href="https://learnopengl-cn.github.io/">LearnOpenGL</a>，不推荐往下看啦。</p>
<hr>
<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>OpenGL系统由独立于设备的函数集（核心库）、实用库（GLU）和实用工具包（GLUT）三部分组成。</p>
<span id="more"></span>

<h2 id="二维几何变换"><a href="#二维几何变换" class="headerlink" title="二维几何变换"></a>二维几何变换</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="搬砖"><a href="#搬砖" class="headerlink" title="搬砖"></a>搬砖</h2><blockquote class="blockquote-center">
<p>码农之路不可长远</p>

</blockquote>


<h3 id="glut模板"><a href="#glut模板" class="headerlink" title="glut模板"></a>glut模板</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;GL/glut.h></span></span>

<span class="token keyword">void</span> <span class="token function">someDrawing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显示背景色</span>
    
    <span class="token function">glColor3f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置颜色为绿色</span>
    
    <span class="token comment">// 画线</span>
    <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINES<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">180</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (180, 15) --- (10, 145)</span>
        <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">145</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 立即处理OpenGL常规事务</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 使用单缓存，且使用RGB模式</span>
    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_SINGLE <span class="token operator">|</span> GLUT_RGB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 距离左边界50像素，距离上边界100像素</span>
    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 宽度400像素，高度300像素</span>
    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"Window Title"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 背景缓存色为白色，Alpha值（调和参数）为0</span>
    <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 设置正投影模式,将世界坐标系二维矩形区域内的内容映射到屏幕上</span>
    <span class="token comment">// x坐标为[0, 200]，y坐标为[0, 150]。此范围外的内容不予显示</span>
    <span class="token comment">// 纵横比与窗口保持一致，使图形不变形</span>
    <span class="token function">glMatrixMode</span><span class="token punctuation">(</span>GL_PROJECTION<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glLoadIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 排除之前投影矩阵的影响</span>
    <span class="token function">gluOrtho2D</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">200.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">150.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>someDrawing<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册绘图函数</span>
    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入主循环：显示所有东西然后等待</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="主动错误检查"><a href="#主动错误检查" class="headerlink" title="主动错误检查"></a>主动错误检查</h3><p>OpenGL记录一个全局错误标志，表示最近一个未被程序员抓取的错误信息。推荐在每一个显示回调子程序中至少检查一次出错情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">GLenum <span class="token function">errorCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> GLenum code <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> GLubyte<span class="token operator">*</span> what <span class="token operator">=</span> <span class="token function">gluErrorString</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 静态常量内存</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"OpenGL error: %s\n"</span><span class="token punctuation">,</span> what<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> code<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="画点与画线"><a href="#画点与画线" class="headerlink" title="画点与画线"></a>画点与画线</h3><p>函数后缀：int-&gt;<code>i</code>，short-&gt;<code>s</code>，float-&gt;<code>f</code>，double-&gt;<code>d</code>，vector-&gt;<code>v</code>，2D-&gt;<code>2</code>，3D-&gt;<code>3</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> p1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">glBegin</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 点</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINES<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 两个点构成线</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 成线</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 成线</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 被忽略</span>
<span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_STRIP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 普通折线</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_LOOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 封闭折线</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// p1与p5成线</span>
    <span class="token function">glVertex2i</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertex2iv</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有关OpenGL的出错编码请自行查找资料。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Concurrency With C++</title>
    <url>/2021/04/01/Concurrency-with-C/</url>
    <content><![CDATA[<p>不同语言/操作系统/硬件的线程实现还不一样，因此学一个比较主流的多线程库还是挺重要的。<br>C++ STL的线程支持库就是一个好例子。在这之前，最好先复习一下基础知识。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><strong>不变量(invariants)</strong> 是指对数据结构的断言<ul>
<li>例：某种帐本，任意前缀和不为负数。</li>
<li>例：链表某个节点的后继的前驱是自己。</li>
<li>众所周知，不良的并发编程会破坏不变量！</li>
<li>破坏不变量的根源是写操作。<span id="more"></span></li>
</ul>
</li>
<li>在并发中的<strong>竞争条件(race condition)</strong> 是指，任何结果依赖于在两个或多个线程上操作执行的相对顺序。<ul>
<li>有问题的竞争条件会破坏不变量，引发Bug。</li>
<li>Debug模式下可能无法发现有问题的竞争条件。</li>
<li>下文的竞争条件默认是有问题的。</li>
<li>在类内部使用互斥锁<em>不能</em>完全消除竞争条件。<ul>
<li>例：<code>return &amp;locked_data;</code> 泄露指针或引用，使得数据离开内部锁的保护！</li>
<li>例：<code>template&lt;typename F&gt; ... F(&amp;locked_data);</code> 可能已经泄露了指针或引用！</li>
<li>例：<code>if (!s.empty()) s.pop();</code> 很可能引发一次不安全的pop！</li>
<li>例：<code>tmp = s.top(); s.pop(); return tmp;</code> 在return时发生构造函数异常，数据丢失！</li>
<li>解决办法：<ol>
<li>传入引用或指针来接收返回值。缺点：一些类不支持赋值。</li>
<li>要求拷贝/移动构造函数不抛出异常。缺点：用户说我偏不。</li>
<li>返回指向原返回值的指针，最好配合shared_ptr。缺点：性能损耗。</li>
<li>1+2 或者 1+3。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>死锁</strong><ul>
<li>四要素：互斥，持有并等待，非抢占，循环等待。</li>
<li>解决办法：破坏四要素中任意一个<ol>
<li>保证上锁的顺序是唯一的。</li>
<li>使用<code>std::lock()</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>锁的粒度</strong>是指单个锁保护的数据量和保护时间。<ul>
<li>挑选合适的数据量大小。</li>
<li>在耗时的操作中尽可能地释放锁，例如I/O操作。</li>
</ul>
</li>
<li><strong>懒汉模式</strong>特指单例模式中的延迟初始化。<ul>
<li>裸懒汉模式显然是线程不安全的。</li>
<li>双重检查加锁也充满了陷阱，因为最外层的检查可能是错误的（赋好了指针，但未彻底完成初始化）！</li>
<li>理想的解决方法是保证标志位是最后初始化的（要防止编译器乱序优化），而不要将指针看作标志位。</li>
<li>使用<code>std::call_once</code>！</li>
<li>还可以利用C++的static局部变量实现懒汉模式。C++11标准保证这是线程安全的！</li>
</ul>
</li>
<li><strong>读写锁</strong>是指共享锁。<ul>
<li>用于很少更新的数据结构。</li>
<li>C++11啥也没有。</li>
<li>C++14新增<code>shared_timed_mutex</code>。</li>
<li>C++17新增<code>shared_mutex</code>，性能更好，好耶！</li>
<li>推荐将<code>shared_mutex</code>声明为<code>mutable</code>。</li>
<li>当心读者太多，写者饿死！</li>
</ul>
</li>
<li><strong>递归锁</strong>允许一个线程多次上锁，但必须进行相同次数的释放锁。<ul>
<li>例：<code>A.a()</code>需要锁，<code>A.b()</code>也需要锁，而且<code>A.a()</code>需要调用<code>A.b()</code>。</li>
<li>不建议这样用，因为<code>A.b()</code>可能要面对错误的数据。</li>
<li>建议抽出<code>A.a()</code>和<code>A.b()</code>的公共部分，成为一个新的私有函数，且不上锁（因为已经上了锁）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Thread-线程"><a href="#Thread-线程" class="headerlink" title="Thread 线程"></a>Thread 线程</h2><p><a href="https://en.cppreference.com/w/cpp/thread">cppreference thread</a></p>
<p><code>#include &lt;thread&gt;</code></p>
<p>起一个线程！</p>
<ul>
<li><code>thread</code> 类<ul>
<li>默认构造不代表任何线程</li>
<li>可移动，不可复制</li>
<li>构造函数完成后立即就绪</li>
<li>若子线程抛出异常，则调用<code>std::terminate</code>中止进程</li>
<li>使用<code>thread_local</code>关键字，令变量的生命周期和所属线程相同</li>
<li><code>join()</code> 调用者等待，直到线程执行完毕</li>
<li><code>detach()</code> 分离线程和线程对象，此时可以安全地销毁线程对象。</li>
<li><code>joinable()</code> 是否可以使用<code>join()</code>。正在运行中、未分离的线程都是 joinable.</li>
<li><code>thread::hardware_concurrency()</code> 获取线程数参考值。</li>
</ul>
</li>
<li><code>this_thread</code> 命名空间<ul>
<li><code>yield()</code> 建议当前线程进入就绪状态</li>
<li><code>get_id()</code> 获取线程id。结果可用<code>&lt;&lt;</code>序列化，虽然意义不大。</li>
<li><code>sleep_for(duration)</code>/<code>sleep_until(time_point)</code> 当前线程阻塞一段时间</li>
</ul>
</li>
</ul>
<hr>
<p>提到多线程，几乎避不开互斥、同步等概念。</p>
<h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h2><p><a href="https://en.cppreference.com/w/cpp/header/mutex">cppreference mutex</a></p>
<p><code>#include &lt;mutex&gt;</code></p>
<p>主要用于保护<strong>数据</strong>的操作原子性。</p>
<p>若多个线程请求同一个锁，而此锁尚未被释放，则当锁释放时，其中一个线程获得锁（退出阻塞），其余线程维持阻塞。</p>
<ul>
<li><code>mutex</code> 类<ul>
<li><code>lock()</code> 阻塞，直到获得锁</li>
<li><code>unlock()</code></li>
<li><code>try_lock()</code> 若无法获得锁，则返回 false 但不阻塞</li>
<li>小心<code>mutex</code>的生命周期。销毁一个被其他线程持有的锁是后果无定义的。</li>
<li>销毁线程前应当释放锁，否则后果无定义。</li>
<li>不可拷贝，不可移动</li>
<li>同一线程不可对同一<code>mutex</code>多次上锁，这样做的后果是无定义的。</li>
</ul>
</li>
<li><code>recursive_mutex</code> 类<ul>
<li>同一线程可以多次上锁。上锁和解锁应一一对应。</li>
<li>例如<code>std::lock_guard&lt;std::recursive_mutex&gt; lk(m);</code></li>
</ul>
</li>
<li><code>timed_mutex</code> 类<ul>
<li><code>try_lock_for(timeout_duration)</code> 最多等待一段时间，无法获得锁则返回 false</li>
<li><code>try_lock_until(timeout_time)</code> 最多等待至一个时间点，无法获得锁则返回 false</li>
</ul>
</li>
<li><code>recursive_timed_mutex</code> 类<ul>
<li>混合了两者的功能</li>
</ul>
</li>
<li><code>void lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn)</code> 全局函数<ul>
<li>安全地“同时”请求多个互斥锁</li>
<li>保证不会引发死锁</li>
</ul>
</li>
<li><code>lock_guard</code> 类<ul>
<li>RAII 请求和释放一个锁</li>
<li>必须拥有一个锁</li>
<li><code>lock_guard( mutex_type&amp; m, std::adopt_lock_t t );</code>假定已经获得了锁</li>
</ul>
</li>
<li><code>scoped_lock</code> 类<ul>
<li>RAII 同时请求和释放多个锁</li>
<li>保证不会引发死锁</li>
</ul>
</li>
<li><code>unique_lock</code> 类<ul>
<li>RAII 独占锁</li>
<li>可以主动解锁。常见于条件变量。暂时或提前释放锁通常可提高时间性能。</li>
<li>可以不拥有锁，因此有空间和性能损耗。常见于需要延迟上锁或转移所有权。</li>
<li>adopt_lock假定已经获得了锁，defer_lock假定延迟获得锁。</li>
<li>若延迟上锁，随后可用<code>std::lock(unique_lock, ...)</code>上锁。</li>
</ul>
</li>
<li><code>shared_lock</code> 类<ul>
<li>RAII 共享锁</li>
</ul>
</li>
<li><code>void call_once( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args );</code> 函数<ul>
<li>全局仅执行函数<code>f(args)</code>一次</li>
<li>若<code>flag</code>是复位，则允许执行<code>f(args)</code></li>
<li>支持多线程并发</li>
<li>若<code>f(args)</code>正常结束，则<code>flag</code>置位，防止第二次调用</li>
<li>若<code>f(args)</code>抛出未处理的异常，则<code>flag</code>保持复位，允许第二次调用</li>
<li>一个<code>flag</code>可以对应多个<code>f</code>，不保证哪个函数先执行。</li>
</ul>
</li>
</ul>
<h2 id="Condition-Variable-条件变量"><a href="#Condition-Variable-条件变量" class="headerlink" title="Condition Variable 条件变量"></a>Condition Variable 条件变量</h2><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference condition_variable</a></p>
<p>条件变量可以用来阻塞一个或多个线程，直到某个活动线程修改一个共享变量（即条件），并通知条件变量。</p>
<ol>
<li>为了保护上述共享变量，需要上互斥锁。</li>
<li>对比互斥锁的优势是：避免定时，定向唤醒，占用资源低，事件驱动。</li>
<li>被唤醒的线程需要手动或自动地检查条件，若条件失败，则再次被阻塞，等待被唤醒。</li>
</ol>
<p><code>#include &lt;condition_variable&gt;</code></p>
<ul>
<li><code>condition_variable</code>类<ul>
<li>只有默认构造函数</li>
<li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock );</code> <ul>
<li>释放锁，然后进入阻塞，直到被唤醒。</li>
<li>被唤醒后，先获得锁。</li>
</ul>
</li>
<li><code>void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred );</code> <ul>
<li>释放锁，然后进入阻塞，直到被唤醒。</li>
<li>被唤醒后，先获得锁</li>
<li>只要<code>pred</code>不满足，就会再次释放锁然后阻塞。</li>
<li>避免在<code>pred</code>里加副作用，因为无法确定它会执行多少次。</li>
</ul>
</li>
<li><code>notify_one()</code>/<code>notify_all()</code> <ul>
<li>唤醒关联的阻塞线程。</li>
<li>当前线程应当事先释放锁（lock_guard应已析构）。</li>
</ul>
</li>
<li><code>void notify_all_at_thread_exit( std::condition_variable&amp; cond, std::unique_lock&lt;std::mutex&gt; lk );</code> <ul>
<li>全局函数。 </li>
<li>线程退出时（所有thread_local被销毁后），释放锁，然后唤醒全部。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Future-amp-Async-未来与异步"><a href="#Future-amp-Async-未来与异步" class="headerlink" title="Future &amp; Async 未来与异步"></a>Future &amp; Async 未来与异步</h2><p><a href="https://en.cppreference.com/w/cpp/header/future">cppreference future</a></p>
<p>有时候，起一个线程仅仅是为了一次返回值。thread不能提供返回值，条件变量又太重量级了，你需要使用<code>async</code>。</p>
<p><code>async</code>可以轻量级地开启一个带返回值的线程，通常短期内你用不到返回值。一段时间后，你需要返回值了，才阻塞自己，直到返回值就绪。需要花费一段时间才能就绪的返回值就是<code>future</code>。</p>
<p><code>async</code>也允许你推迟执行，这意味着没有新线程，而是同步地执行。</p>
<ul>
<li><code>async</code>函数<ul>
<li>可接受<code>std::launch policy</code>为第一个参数，允许的值有：<ul>
<li><code>std::launch::async</code> 开启新线程，异步执行。</li>
<li><code>std::launch::deferred</code> 没有新线程，懒惰同步执行。</li>
<li><code>launch::async|launch::deferred</code> 默认值，由实现选择策略。</li>
<li>C++标准允许实现采用不同的默认策略，甚至允许新增策略。</li>
</ul>
</li>
<li><code>async</code>返回一个<code>future</code></li>
</ul>
</li>
<li><code>future&lt;&gt;</code>类<ul>
<li>表示一个值，这个值可能正在计算中，可能就绪，也可能是抛出的异常。</li>
<li><code>get()</code>成员函数。 保证返回就绪的值或者抛出异常。（若未就绪，则当前线程阻塞）。此函数只能调用一次，然后将<code>valid()</code>设置为false。</li>
<li><code>valid()</code>成员函数。 检查下一次<code>get()</code>的合法性，即有没有共享状态。</li>
<li><code>wait()</code>成员函数。 保证值就绪或者抛出异常。（若未就绪，则阻塞）</li>
<li><code>wait_for</code>, <code>wait_until</code>成员函数。有限等待。</li>
<li><code>share()</code>成员函数。移动自己，构造一个<code>shared_future&lt;&gt;</code>。</li>
<li>可移动，不可复制。</li>
</ul>
</li>
<li><code>shared_future&lt;&gt;</code>类<ul>
<li>与<code>future&lt;&gt;</code>类似，但可以<code>get()</code>多次。</li>
<li>可移动也可以复制。</li>
<li>正确的用法就是每个线程持有一份复制。</li>
</ul>
</li>
<li><code>packaged_task&lt;Callable&gt;</code>类<ul>
<li>将future绑定到函数（或可调用对象），方便自定义调度。</li>
<li>构造器仅接受函数（可以是lambda！），不绑定参数。只有在<code>operator ()</code>时才传入参数。</li>
<li>packaged_task本身也是一个可调用对象！可以用它起一个新线程。<code>thread(move(task), args...)</code></li>
<li>可移动，不可复制。</li>
<li><code>get_future()</code> 获取绑定的future。</li>
<li><code>operator(args...)</code> 立即在当前线程执行，然后future就绪，意味着唤醒等待此future的线程。</li>
<li><code>make_ready_at_thread_exit(args...)</code> 立即在当前线程执行，但是future不就绪。当线程退出且所有thread_local对象销毁后，future才就绪。</li>
<li><code>reset()</code> 重新构造自己。旧版的future作废。</li>
</ul>
</li>
<li><code>promise&lt;&gt;</code>类<ul>
<li>比async提供更强的自由度，可以手动设置future！如此可以在设置future后继续清理工作。</li>
<li>可移动，不可复制。</li>
<li>一般先<code>get_future()</code>留下接口，然后move<code>promise</code>到别的线程，在别的线程<code>set_value</code>。</li>
<li><code>set_value(value)</code> 设置关联的future的值，唤醒在等待的线程。</li>
<li><code>set_value_at_thread_exit(value)</code> 类似<code>set_value</code>，但当前线程退出后，才唤醒在等待的线程。</li>
<li><code>void set_exception( std::exception_ptr p )</code> 令future的<code>get()</code>抛出异常。<ul>
<li>在try-catch块中，配合<code>std::current_exception()</code>使用</li>
<li>不用try-catch，性能更高，配合<code>make_exception_ptr(E e)</code>用。</li>
</ul>
</li>
<li><code>set_exception_at_thread_exit</code> 同理。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>并发编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; NexT 更新方式</title>
    <url>/2021/04/01/Hexo-NexT-%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token function">install</span> -g cnpm                 <span class="token comment"># 升级 npm</span>
cnpm cache clean -f                 <span class="token comment"># 清除 npm 缓存</span>

<span class="token comment"># 更新 package.json 中的 hexo 及个插件版本</span>
cnpm <span class="token function">install</span> -g npm-check           <span class="token comment"># 检查之前安装的插件，都有哪些是可以升级的 </span>
cnpm <span class="token function">install</span> -g npm-upgrade         <span class="token comment"># 升级系统中的插件</span>
npm-check
npm-upgrade

cnpm update

hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="更新NexT"><a href="#更新NexT" class="headerlink" title="更新NexT"></a>更新NexT</h3><ol>
<li>重命名原有的主题文件（夹）</li>
<li><code>npm install hexo-theme-next@latest</code></li>
<li>diff配合肉眼更新配置</li>
<li>参考<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">官方文档</a></li>
</ol>
]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>跟我一起写Makefile</title>
    <url>/2020/02/01/Makefile/</url>
    <content><![CDATA[<p>路过一篇写得很到位的Makefile介绍文章，转载一下：</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/overview.html">seisman.github.io/how-to-write-makefile</a></p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机 Suffix Automaton</title>
    <url>/2020/10/01/Suffix-Automaton/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="自动机的五个部分"><a href="#自动机的五个部分" class="headerlink" title="自动机的五个部分"></a>自动机的五个部分</h2><ol>
<li><strong>alpha</strong> 字符集</li>
<li><strong>state</strong> 状态集合。另让$null$表示不存在的状态或转移</li>
<li><strong>init</strong> 初始状态</li>
<li><strong>end</strong> 结束状态集合</li>
<li><strong>trans</strong> 状态转移函数：令$trans(s, str)$表示在状态$s$时读入字符串$str$后，所达到的状态。$trans$应具有传递性。</li>
</ol>
<span id="more"></span>

<h2 id="设"><a href="#设" class="headerlink" title="设"></a>设</h2><ol>
<li>自动机能识别的所有字符串集合<strong>Reg(A)</strong> ，其中的字符串$x$满足$trans(init, x)\in end$</li>
<li>从状态$s$开始能识别的字符串 <strong>Reg(s)</strong></li>
<li>后缀自动机<strong>SAM</strong>，一个能识别母串$S$的所有后缀的自动机。$SAM(x)=true$当且仅当$x$是$S$的后缀。</li>
<li>$trans(init, str)$即从初始状态读入$str$后到达的状态<strong>ST(str)</strong> <em>（ST是state的缩写)</em></li>
<li>母串$S$的所有后缀的集合<strong>Suf</strong>，从$a$位置开始的后缀<strong>Suffix(a)</strong></li>
<li>母串$S$的所有连续子串的集合<strong>Fac</strong>，位置为$[l,r)$的子串<strong>S[l,r)</strong></li>
</ol>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="SAM的可行性分析"><a href="#SAM的可行性分析" class="headerlink" title="SAM的可行性分析"></a>SAM的可行性分析</h2><ol>
<li><p>对于字符串$s$，若$s\in Fac$，则$ST(s)$应存在，这是因为可以在$s$后面加上一些字符使其变成$S$的后缀。<em>反之$s\notin Fac$，则应有$ST(s)=null$以节省空间</em></p>
</li>
<li><p>考虑$ST(a)$能识别哪些字符串，即$Reg(ST(a))$。若$x\in Reg(ST(a))$，则$ax\in Suf$，故$ax$是后缀，$x$也是后缀。$Reg(ST(a))$是每次$a$出现后接下来的后缀。设<strong>Right(a)</strong> 为a每次出现的开区间末位置，则$Reg(ST(a))$完全由$Right(a)$决定。</p>
</li>
<li><p>对于状态$s$（不是单个字符串），我们关心$Reg(s)$。如果对于$a,b\in Fac$有$Right(a)=Right(b)$，那么可令$ST(a)= ST(b)$。所以一个状态$s$由所有$Right$集合是<strong>Right(s)</strong> 的字符串组成。</p>
</li>
<li><p>考虑状态$s$包括的字符串长度，易证若$s$包含长度为$l$,$r$的字符串，那么一定包含长度为$m(l \leq m \leq r)$的字符串。所以这些字符串长度一定可以组成一个区间，设为 <strong>[Min(s), Max(s)]</strong></p>
</li>
<li><p>状态数是线性的。<br/>　　状态由$Right$集合决定，考虑两个状态$a,b$的$Right$集合$R_a,R_b$。假设$R_a,R_b$有交集，设$r \in R_a \cap R_b$。由于一个子串只能属于一个状态，所以$a$，$b$所表示的子串不会有交集，即由$r$往前不能有长度相同的子串，故$[Min(a), Max(a)]$和$[Min(b), Max(b)]$没有交集，不妨设$Max(a) &lt; Min(b)$，由于$a$，$b$包含的所有串都可以视为$r$往前的子串，故$a$的所有串都是$b$的任意串的后缀。因$b$的任意串都能找到后缀属于$a$，两者$Right$集合又不相等，故$R_b \subset R_a$。那么任意两个状态的$Right$集合要么不相交，要么一个是另一个的真子集。<br/>　　疾风将以状态为节点，以$Right$包含关系为父子关系构成的树叫 <strong>“分裂树”</strong> <br/>　　不考虑字符串这个主题，“分裂树”易证是线性的；实际上，$SAM$的结点个数最多为$2n$。<br><br/><img src="./%E5%88%86%E8%A3%82%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="分裂树举例"></p>
</li>
<li><p>更严谨的分裂树定义：令满足$Right(s) \subset Right(fa)$的最小$|Right(fa)|$的$fa$为状态$s$的父亲。<br/>　　直观地看，一定是$fa$中最长的字符串向前扩展一位导致了$Right$集合分裂，所以**Max(fa)+1=Min(s)**。</p>
</li>
<li><p>自动机的边数是线性的。<br/>　　直观地看，自动机是一个DAG（否则可以无限地在自动机上走，即识别无限长的字符串，显然这是不可能的），而能从$init$走到某个$end$点的肯定是字符串的某一个后缀。字符串只有$n$个后缀，意味着从$init$到$end$只能有$n$种路径；另一方面，节点数只有$O(n)$，所以猜测边数也是$O(n)$的。<br/>　　标出自动机任意一个生成树，则对于一条非树边$(a\rightarrow b)$，存在若干路径${init \rightarrowtail a \rightarrow b \rightarrowtail e(e\in end)}$对应着一个后缀。对每一个后缀，对应在自动机上走到的第一条非树边。如此每个后缀最多对应一个非树边，而非树边至少被一个后缀对应，所以后缀数量$\geq$非树边数量。所以边数是$O(n)$的。</p>
</li>
</ol>
<h2 id="归纳法构造SAM"><a href="#归纳法构造SAM" class="headerlink" title="归纳法构造SAM"></a>归纳法构造SAM</h2><h3 id="SAM的更多性质"><a href="#SAM的更多性质" class="headerlink" title="SAM的更多性质"></a>SAM的更多性质</h3><p><em>这一部分是SAM构造算法的重要依据。<br/>请确认上文所有加粗内容都已理解。</em></p>
<ol>
<li><p>后缀自动机是一个有向无环图<br>$$<br>SAM = {分裂树的点，自动机的有向边}<br>$$ </p>
</li>
<li><p>SAM的构造算法是在线的，即从左到右逐个添加字符。根据数学归纳法，<strong>下文假设已有字符串$T$的后缀自动机</strong>。</p>
</li>
<li><p>考虑一个状态$s$，它的$Right(s)={r_1, r_2, \cdots, r_n}$，假如有状态转移$trans(s,c) = t$（即状态$s$后添加一个字符$c$得到状态$t$），由于向右扩展了一位字符，$Right(s)$中只有$T[r_i]=c$的满足要求。所以$Right(t)={r_i+1 | T[r_i]=c}$。<br/>　　如果$trans(s,c)$存在，那么$trans(Pa(s), c)$必定存在，其中$Pa(s)$表示分裂树上状态$s$的父亲。并且$Right(trans(s,c)) \subseteq Right(trans(Pa(s),c))$。<br/>　　另一个显然的结论是$Max(s)&lt;Max(t)$。</p>
</li>
<li><p>后缀自动机没有显式地储存$Right$集合。因此可以认为修改$Right$的时间复杂度为$O(0)$。</p>
</li>
<li><p>初始状态时母串$T$为空字符串，自动机只有一个节点$root$。</p>
</li>
</ol>
<h3 id="添加一位字符更新自动机"><a href="#添加一位字符更新自动机" class="headerlink" title="添加一位字符更新自动机"></a>添加一位字符更新自动机</h3><p>&emsp;&emsp;令当前字符串为$T$，长度为$L$；末尾添加一个字符$x$，要将$SAM(T)$更新为$SAM(Tx)$。<br><br/>　　那么新增的子串是$Tx$的所有后缀，可看作$T$的所有后缀后添加了$x$。令$SAM(T)$中表示$T$的后缀的节点为${v_1, v_2, \cdots, v_k=root}$。因为后缀在字符串的末尾出现，所以$L\in Right(v_i)$，可知$v_i$在分裂树上恰好构成一条从叶子到$root$的链，不妨设${v_1, v_2, \cdots, v_k=root}$已经按从叶子到祖先排序。<br><br/>　　添加字符$x$后，首先新建状态$np$表示$ST(Tx)$，这是一个已确定的状态（因为没有出边），可知$Right(np)={L+1}$。<br><br/>　　回头考虑旧自动机的$v_i$，设$Right(v_i)={r_1, r_2, \cdots, r_n=L}$。如果能在后面添加字符$x$（注意现在仍是字符串$T$的自动机），即$nv=trans(v_i, x)$存在，我们已经知道$Right(nv)={r_i+1|T[r_i]=x}$；反之如果$v_i$没有$x$的出边，意味着没有$r_i$满足$T[r_i]=x$。由于分裂树上父亲的$Right$扩大，如果$trans(v_i,x)$存在，那么$trans(v_{i+1}, x)$也存在。<br><br/>　　对于所有$trans(v,x)=null$的$v$，而只有$Tx[r_n=L]=x$满足转移条件，于是添加一条边$trans(v,x)=np$。<br><br/>　　令$v_p$是$v_1, v_2, \cdots, v_k$中第一个有$x$出边（即$trans(v_p, x)$存在）的状态。令$q=trans(v_p, x)$，注意，现在仍是旧的自动机。我们能不能直接在$Right(q)$中直接插入$L+1$呢？答案是不能。这是因为有可能$Max(q) &gt; Max(v_p)+1$，隐含意思是$q$在”$v_p$末尾添加$x$”的基础上，由于$Right$集合的缩减，纳入了左端更多字符；如果强行在$Right(q)$中插入$L+1$，会导致$Max(q)$减小而丢失了原来的状态，破坏了自动机的正确性。</p>
<p><img src="./%E5%BC%BA%E8%A1%8C%E6%8F%92%E5%85%A5%E7%9A%84%E5%8F%8D%E4%BE%8B.png" alt="强行插入的反例"><br><br/>　　如图所示，$v_p$含有的最长字符串是红色5个“A”，但$trans(v_p,x)=q$含有的最长字符串是蓝色7位字符串，如果在$Right(q)$中强行插入$L+1$即变为绿色部分，会使$Max(q)$从7减少到6从而丢失信息。<br><br/>　　如果足够幸运，$Max(q) = Max(v_p)+1$，就没有上面的问题，我们可以在$Right(q)$中插入$L+1$，然后只要令$Pa(np)=q$即可完成自动机更新。<em>注：理论上$Right(trans(v_p\dots v_k,x))$都要插入$L+1$，但这些状态的出边都没有发生改变，而后缀自动机实际上不记录$Right$，所以更新完成。</em><br><br/>　　如果没那么幸运，从图上可知，原状态$q$在插入末尾字符$x$后应转换两个状态，设蓝色对应的状态为$q&#39;$（沿用$q$)，绿色状态为$nq$（新建节点）。显然<br>$$<br>trans(q&#39;, *) = trans(q, *), \<br>Pa(q&#39;)=nq，\<br>Right(nq)=Right(q&#39;)\cup {L+1}，\<br>Max(nq) = Max(v_p)+1<br>$$<br>显然$Right(nq)$是真包含${L+1}$的最小集合，所以<br>$$ Pa(np)=nq $$<br>&emsp;&emsp;截至目前我们新添了$np$，将$q$转化为$q&#39;,nq$，其中$np,q&#39;$都正确处理了出边和分裂树父亲。<br>那么$nq$的分裂树父亲又是谁呢？结合上图易证<br>$$ Pa(nq)=Pa(q) $$</p>
<p>$nq$的出边是哪一些？由于新添的最后一个字符不能带来更多的状态转移（最后一个字符后面再没有字符了），所以<br>$$ trans(nq, *) = trans(q, *) $$<br><br/>　　最后，我们还要考虑原自动机中指向$q$的状态，和新自动机中应当指向$q&#39;$和$nq$的状态。在$v_p,\cdots,v_k$中，由于$Right$的扩大，$Right(trans(v_i,x))$也逐渐扩大（不缩小），所以只有一段连续的$v_p,\cdots,v_e(e\le k)$是指向$q$的，由于要配合在$Right$集合中插入$L+1$，这些出边要修改为<br>$$ trans(v_i,x) = nq $$<br>其余指向$q$的状态必然由于左端有过多字符而无法指向$nq$，于是改为指向$q&#39;$，等效于不做任何修改。<br><br/>　　最后的最后，对于$v_{e+1},\cdots,v_k$，对于$nv=trans(v_i, x)$，必然可以粗暴地令$Right(nv)$插入$L+1$，所以转移关系可以保持不变，等效于不做任何修改。</p>
<h1 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> MAXW <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">,</span> MAXN <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>
	State<span class="token operator">*</span> go<span class="token punctuation">[</span>MAXW<span class="token punctuation">]</span><span class="token punctuation">;</span>
	State<span class="token operator">*</span> pa<span class="token punctuation">;</span>
	<span class="token keyword">int</span> mx<span class="token punctuation">;</span>

	<span class="token function">State</span><span class="token punctuation">(</span><span class="token keyword">int</span> MX<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pa</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mx</span><span class="token punctuation">(</span>MX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>go<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">State</span><span class="token punctuation">(</span><span class="token keyword">const</span> State<span class="token operator">*</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		pa <span class="token operator">=</span> o<span class="token operator">-></span>pa<span class="token punctuation">;</span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>go<span class="token punctuation">,</span> o<span class="token operator">-></span>go<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>o<span class="token operator">-></span>go<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		mx <span class="token operator">=</span> o<span class="token operator">-></span>mx<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	State<span class="token operator">*</span> p <span class="token operator">=</span> last<span class="token punctuation">;</span>
	State<span class="token operator">*</span> np <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span>p<span class="token operator">-></span>mx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	last <span class="token operator">=</span> np<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
		p<span class="token operator">-></span>go<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> root<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	State<span class="token operator">*</span> q <span class="token operator">=</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>mx<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> q<span class="token operator">-></span>mx<span class="token punctuation">)</span>
		<span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> q<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	State<span class="token operator">*</span> nq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	nq<span class="token operator">-></span>mx <span class="token operator">=</span> p<span class="token operator">-></span>mx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	q<span class="token operator">-></span>pa <span class="token operator">=</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> nq<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>q<span class="token punctuation">)</span>
		p<span class="token operator">-></span>go<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> nq<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> st<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>

	last <span class="token operator">=</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">extend</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>&emsp;&emsp;SAM思路真的异常精妙，环环相扣，巧夺天工。不幸的是优美的结论是以复杂而庞大的论证为代价的。<br><br/>　　被奉为圣经的<code>2012年noi冬令营陈立杰讲稿(SAM后缀自动机)</code>在描述构造过程的时候没有解释可以省略的操作为什么被省略，导致思路有很大残缺和跳跃。即使是本文也用了不少“显然”字眼，但比较原文已有较大改进。另外，原讲稿没有交代构造算法为什么是$O(n)$的。<del>疾风理解这ppt花了整整三天</del>如果本文对你有帮助，不妨赏疾风一支冰阔乐喝（馋.jpg）<br><br/>　　有人说SAM完全可以当做黑盒来用，我认为不然。黑盒SAM的唯一功能是判定子串是否存在，局限性很大。而SAM的实战应用代码相对裸构造有很大增改，例如要结合dfs序，平衡树，动态树等等技巧，且都是建立在完全理解后缀自动机的基础上，难度依然很大。这部分日后再填补。</p>
<p><em>转载请注明原作者和网址</em></p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM实战剖析</title>
    <url>/2020/10/11/SAM%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<ul>
<li><em>实战不会SAM？导致比赛打铁？快 点 学 ！</em></li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机(Suffix-Automaton)">后缀自动机(Suffix-Automaton)</a>

<span id="more"></span>

<h1 id="在自动机上游走"><a href="#在自动机上游走" class="headerlink" title="在自动机上游走"></a>在自动机上游走</h1><p>&emsp;&emsp;从$root$开始，沿目标字符串逐个字符走。若路径存在，即当前子串存在；反之，若出边不存在，即目标子串不存在。</p>
<h2 id="求最小表示"><a href="#求最小表示" class="headerlink" title="求最小表示"></a>求最小表示</h2><p>&emsp;&emsp;求字符串$S$的最小表示。<br><br/>　　<em>度娘有$O(n)$的特殊做法，此处不赘述。</em><br><br/>　　构造字符串$SS$的后缀自动机，从$root$开始，每次沿最小的出边走，走n步就得到了$SS$中长度为n的最小子串，即$S$的最小表示。</p>
<h2 id="求本质不同的第k小子串"><a href="#求本质不同的第k小子串" class="headerlink" title="求本质不同的第k小子串"></a>求本质不同的第k小子串</h2><p><a href="https://www.spoj.com/problems/SUBLEX/">SPOJ SUBLEX</a> 题意：求字符串$S$的所有本质不同子串中的第$k$小。$length(S)\le 9e4, 询问数量\le 500$。<br><br/>　　SAM构造完成后得到一个DAG，利用拓扑序求从每个点出发可能的路径数目。见<a href="#SAM%E4%B8%8A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序的方法</a>。最后用类似二分法求第k小即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 内存池+计数排序的SAM，相对优秀</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> MAXW <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">,</span> MAXN <span class="token operator">=</span> <span class="token number">9e4</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>
    State <span class="token operator">*</span>pa<span class="token punctuation">;</span>
    State <span class="token operator">*</span>go<span class="token punctuation">[</span>MAXW<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> Max<span class="token punctuation">;</span>
    
    <span class="token keyword">int</span> siz <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>    
<span class="token punctuation">&#125;</span>sam<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>

State<span class="token operator">*</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token keyword">int</span> Max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    State<span class="token operator">&amp;</span> ref <span class="token operator">=</span> sam<span class="token punctuation">[</span>State<span class="token operator">::</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    ref<span class="token punctuation">.</span>Max <span class="token operator">=</span> Max<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

State<span class="token operator">*</span> <span class="token function">alloc</span><span class="token punctuation">(</span>State<span class="token operator">*</span> src<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    State<span class="token operator">&amp;</span> ref <span class="token operator">=</span> sam<span class="token punctuation">[</span>State<span class="token operator">::</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    ref <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    State <span class="token operator">*</span>p <span class="token operator">=</span> last<span class="token punctuation">,</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token function">alloc</span><span class="token punctuation">(</span>p<span class="token operator">-></span>Max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    last <span class="token operator">=</span> np<span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span>
        p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> root<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    State<span class="token operator">*</span> q <span class="token operator">=</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>Max <span class="token operator">==</span> p<span class="token operator">-></span>Max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> q<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    State<span class="token operator">*</span> nq <span class="token operator">=</span> <span class="token function">alloc</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nq<span class="token operator">-></span>Max <span class="token operator">=</span> p<span class="token operator">-></span>Max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>pa <span class="token operator">=</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> nq<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> q<span class="token punctuation">)</span>
        p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> nq<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> State<span class="token operator">::</span>cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> st<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> Q<span class="token punctuation">,</span> len<span class="token punctuation">;</span>

<span class="token keyword">int</span> num<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
State<span class="token operator">*</span> b<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 类似二分法求当前第lef小</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">const</span> State<span class="token operator">*</span> now<span class="token punctuation">,</span> <span class="token keyword">int</span> dep<span class="token punctuation">,</span> <span class="token keyword">int</span> lef<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> ans<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lef <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ans<span class="token punctuation">[</span>dep<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>MAXW<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>now<span class="token operator">-></span>go<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> State<span class="token operator">*</span> g <span class="token operator">=</span> now<span class="token operator">-></span>go<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lef <span class="token operator">&lt;=</span> g<span class="token operator">-></span>siz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ans<span class="token punctuation">[</span>dep<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> dep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> lef<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            lef <span class="token operator">-=</span> g<span class="token operator">-></span>siz<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    last <span class="token operator">=</span> root <span class="token operator">=</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token operator">=</span>len<span class="token punctuation">;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
        <span class="token function">extend</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 拓扑排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>State<span class="token operator">::</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">++</span>num<span class="token punctuation">[</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Max<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> num<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>State<span class="token operator">::</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> b<span class="token punctuation">[</span><span class="token operator">--</span>num<span class="token punctuation">[</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Max<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 沿拓扑序DP</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>State<span class="token operator">::</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>MAXW<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                 b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>siz <span class="token operator">+=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>siz<span class="token punctuation">;</span>
    
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> aim<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>aim<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> aim<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="离线计算-Right"><a href="#离线计算-Right" class="headerlink" title="离线计算|Right|"></a>离线计算|Right|</h1><p>&emsp;&emsp;构造好的后缀自动机隐含了一颗分裂树，只需访问所有节点和$Pa$指针，就能还原这颗分裂树。显然，叶子节点的$|Right| = 1$，但仅有这些信息还不足推出其他节点的$|Right|$，这是因为节点在往下分裂时可能丢失元素<br><br/><img src="./abaTree.png" alt="&quot;aba&quot;的分裂树。“1”没有出现在叶节点中"><br><br/>　　如上图所示，“1”在分裂的过程中消失了，不存在叶子节点中。<br><br/>　　为什么$Right$集合的元素无法往下分裂？这是因为它表示的子串无法向左端扩展，换句话说，它是前缀。注意到叶子节点也是前缀。综上所述，只要对前缀所在节点的$|Right|$预置为$1$（其他节点预置为$0$），然后自底向上更新分裂树即可得到所有$|Right|$</p>
<h2 id="分裂树上拓扑排序"><a href="#分裂树上拓扑排序" class="headerlink" title="分裂树上拓扑排序"></a>分裂树上拓扑排序</h2><p>&emsp;&emsp;上文引出了一个新问题，如何自底向上地访问分裂树？一种直观的办法是bfs收集SAM所有节点再做拓扑排序，这逻辑复杂而代码繁琐。一种更好的办法是，在构造SAM时采用内存池技术，之后对内存池按照$Max$降序排序即可。原因是<br>$$ Max(fa)+1=Min(s) \Rightarrow Max(s) &gt; Max(fa)$$<br>有趣的是，分裂树的拓扑序也是自动机的拓扑序！原因是<br>$$ trans(s, *)=t \Rightarrow Max(t) &gt; Max(s) $$<br>如果你忘记了，请复习<a href="/2020/10/01/Suffix-Automaton/" title="后缀自动机的更多性质">后缀自动机的更多性质</a>。</p>
<div class="note primary"><h4 id="拓扑排序要点"><a href="#拓扑排序要点" class="headerlink" title="拓扑排序要点"></a>拓扑排序要点</h4><ol>
<li>指针板构造采用内存池技术</li>
<li>$Max$可能的取值仅有$[1,n]$，所以要采用计数排序</li>
<li>不要真的修改内存池，而是新开指针做排序</li>
<li>如果不得不写常规拓扑排序，bfs时请注意DAG的重复访问</li>
</ol>
</div>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">++</span>num<span class="token punctuation">[</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Max<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> num<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> b<span class="token punctuation">[</span><span class="token operator">--</span>num<span class="token punctuation">[</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Max<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sam<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// sam[] has been top sorted by b[].</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>剩余细节在<a href="#%E6%B1%82%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AC%ACk%E5%B0%8F%E5%AD%90%E4%B8%B2">例题1</a>、<a href="#%E6%B1%82%E9%95%BF%E5%BA%A6%E4%B8%BA-i-%E7%9A%84%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">例题2</a>中体现</p>
<h2 id="求长度为i的子串的最大出现次数"><a href="#求长度为i的子串的最大出现次数" class="headerlink" title="求长度为i的子串的最大出现次数"></a>求长度为i的子串的最大出现次数</h2><p><a href="https://www.spoj.com/problems/NSUBSTR/">SPOJ NSUBSTR</a> 题意：给出字符串S（长度&lt;=2.5e5），设f(x)为S中长度为x的子串的最大出现次数，求f(1...length(s))。</p>
<p>&emsp;&emsp;分析：后缀自动机中每个状态$s$蕴含的字符串长度为$[Min(s), Max(s)]$，每个出现了$Right(s)$次，只需用$|Right(s)|$更新$ans[Max(s)]$就行了，在最后输出前依次用$ans[i+1]$更新$ans[i]$即可。原因是长度更长的子串出现的次数一定不超过长度短的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 朴素的拓扑排序版本，推荐改用计数排序</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXW <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">,</span> MAXN <span class="token operator">=</span> <span class="token number">50</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXW <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">,</span> MAXN <span class="token operator">=</span> <span class="token number">250000</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token keyword">struct</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>
    State<span class="token operator">*</span> pa<span class="token punctuation">;</span>
    State<span class="token operator">*</span> go<span class="token punctuation">[</span>MAXW<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> Max<span class="token punctuation">;</span>
    
    <span class="token keyword">int</span> RSiz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> inD <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> vis <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    
    <span class="token function">State</span><span class="token punctuation">(</span><span class="token keyword">int</span> Max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>go<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>go<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pa <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>Max <span class="token operator">=</span> Max<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token function">State</span><span class="token punctuation">(</span><span class="token keyword">const</span> State<span class="token operator">*</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>go<span class="token punctuation">,</span> o<span class="token operator">-></span>go<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>go<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pa <span class="token operator">=</span> o<span class="token operator">-></span>pa<span class="token punctuation">;</span>
        Max <span class="token operator">=</span> o<span class="token operator">-></span>Max<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    State <span class="token operator">*</span>p <span class="token operator">=</span> last<span class="token punctuation">,</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span>p<span class="token operator">-></span>Max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    last <span class="token operator">=</span> np<span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span>
        p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> root<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    State <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>Max<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> q<span class="token operator">-></span>Max<span class="token punctuation">)</span>
        <span class="token keyword">return</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> q<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    State <span class="token operator">*</span>nq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-></span>pa <span class="token operator">=</span> np<span class="token operator">-></span>pa <span class="token operator">=</span> nq<span class="token punctuation">;</span>
    nq<span class="token operator">-></span>Max <span class="token operator">=</span> p<span class="token operator">-></span>Max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> q<span class="token punctuation">)</span>
        p<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span>nq<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token operator">-></span>pa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> st<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len<span class="token punctuation">;</span>

State<span class="token operator">*</span> q<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
    cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        State<span class="token operator">*</span> <span class="token keyword">const</span> now <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now<span class="token operator">-></span>pa<span class="token punctuation">)</span> <span class="token operator">++</span>now<span class="token operator">-></span>pa<span class="token operator">-></span>inD<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>MAXW<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>now<span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>now<span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>vis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                q<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                now<span class="token operator">-></span>go<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>vis <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tail <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> q<span class="token operator">+</span>cnt<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> State<span class="token operator">*</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> o<span class="token operator">-></span>inD <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">-</span> q<span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">&lt;</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        State<span class="token operator">*</span> now <span class="token operator">=</span> q<span class="token punctuation">[</span>head<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>now<span class="token operator">-></span>pa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        now<span class="token operator">-></span>pa<span class="token operator">-></span>RSiz <span class="token operator">+=</span> now<span class="token operator">-></span>RSiz<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>now<span class="token operator">-></span>pa<span class="token operator">-></span>inD <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            q<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token operator">-></span>pa<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> ans<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    root <span class="token operator">=</span> last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
        <span class="token function">extend</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// bfs取出SAM中的所有节点，注意判重</span>
    <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 对SAM中所有蕴含前缀的状态 |Right| = 1（其它置为0）</span>
    State<span class="token operator">*</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> p<span class="token operator">-></span>go<span class="token punctuation">[</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>p<span class="token operator">-></span>RSiz<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 拓扑排序，顺便自底向上更新|Right|</span>
    <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ans<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>Max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>Max<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>RSiz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>
        ans<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="跳向父亲，舍弃左端，寻求匹配"><a href="#跳向父亲，舍弃左端，寻求匹配" class="headerlink" title="跳向父亲，舍弃左端，寻求匹配"></a>跳向父亲，舍弃左端，寻求匹配</h1><p>&emsp;&emsp;<code>now = now-&gt;pa</code>的本质是抛弃左端一部分字符，带来的效果是$Right$集合的扩张。这个特性在求最长公共子串的时候尤为好用，与KMP舍弃右端部分字符以寻求匹配的原理有异曲同工之妙。</p>
<h2 id="求两字符串的最长公共子串"><a href="#求两字符串的最长公共子串" class="headerlink" title="求两字符串的最长公共子串"></a>求两字符串的最长公共子串</h2><p><a href="https://www.spoj.com/problems/LCS/">SPOJ LCS</a> 题意：求字符串$S1,S2$的最长公共子串(要求连续)</p>
<p>&emsp;&emsp;分析：后缀自动机很擅长处理连续串的匹配。试想我们做出$S1$的SAM，然后直接跑$S2$，势必出现出边不存在的问题——无法继续匹配了。不妨设无法继续匹配时，导致无法匹配的字符是$S2[i]$，当前状态为$s$，即$trans(s, S2[i])$不存在，即不存在$S1[r_j]=S2[i], r_j\in Right(s)$。想要寻求匹配，只能抛弃已匹配的子串左端，而<code>s=s-&gt;pa</code>恰好带来了最少的抛弃量，使得$Right(s)$能扩张，从而带来匹配的可能性。<br><br/>　　换句话说，当<code>s-&gt;go[S2[i]] == nullptr</code>时，重复<code>s = s-&gt;pa</code>，直到获得匹配<code>s-&gt;go[S2[i]] != nullptr</code>或不可能匹配<code>s == nullptr</code>。<br><br/>　　假如直接能匹配呢？那太简单了，匹配长度加一，下一位。<br><br/>　　于是最终解为：记当前已匹配长度$match$，当前答案$ans$，当前自动机状态$s$，接下来尝试匹配$S2[i]$，若$trans(s,S2[i])$存在，就转移，并且$match$加一；否则尝试不断跳分裂树的$fa$，直到转移存在，由于$Max(fa) &lt; Min(s) \le match$，$match$必能取到$Max(fa)$，所以$s$跳到$trans(fa, S2[i])$， $match$取为$Max(fa)+1$即可。每走一步都用$match$更新$ans$。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 省略SAM的构造和其他乱七八糟的东西</span>
    State<span class="token operator">*</span> now <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">int</span> match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> sb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>sb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            now <span class="token operator">=</span> now<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>match<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>now <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>now<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span>
                now <span class="token operator">=</span> now<span class="token operator">-></span>pa<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>now<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                match <span class="token operator">=</span> now<span class="token operator">-></span>Max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                now <span class="token operator">=</span> now<span class="token operator">-></span>go<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                now <span class="token operator">=</span> root<span class="token punctuation">;</span>
                match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        
        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> match<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu双系统双显卡装机</title>
    <url>/2020/01/25/Ubuntu%E8%A3%85%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久之前就在Windows笔记本上装了ubuntu 18.04 LTS，因为是双系统，需要手动给硬盘分区，而当时ubuntu的系统分区贼多，埋下了某一个分区过小的伏笔。最近某Filesystem塞满了（500MB），才发现很多双系统安装教程没有卸载教程！</p>
<p>于是探索的旅程又开始了。<strong>我们将卸载现有的Ubuntu系统，调整硬盘分区，然后重装ubuntu，并安装最棒的软件和驱动</strong>。</p>
<span id="more"></span>

<h1 id="卸载原有ubuntu"><a href="#卸载原有ubuntu" class="headerlink" title="卸载原有ubuntu"></a>卸载原有ubuntu</h1><p>原有的系统是手动分区的，导致一个硬盘上分区数较多。</p>
<ol>
<li>启动Windows系统，使用分区助手将ubuntu占用的分区合并，并格式化成ext4系统。（格式化似乎不是必要步骤）</li>
<li>准备好ubuntu装机u盘。应该都会吧！用UltraISO。</li>
<li>调整BIOS设置。设置为u盘启动，关闭secure boot，华硕的主板还要关闭fast boot。</li>
</ol>
<h1 id="安装ubuntu-18-04-3-LTS"><a href="#安装ubuntu-18-04-3-LTS" class="headerlink" title="安装ubuntu 18.04.3 LTS"></a>安装ubuntu 18.04.3 LTS</h1><ol>
<li>u盘启动，选择试用ubuntu。</li>
<li>开始安装，接好wifi。在询问是否与windows共存的时候点自定义。在分区表中将刚刚在分区助手中合并的分区删除，归还的空间分配到windows的C盘上。然后后退，选择与windows共存。</li>
<li>这时界面让你分割windows的C盘，供ubuntu使用。我分割了32GB，建议贪多，原因玄学。</li>
<li>一路安装，没什么大问题。</li>
</ol>
<h1 id="登陆ubuntu"><a href="#登陆ubuntu" class="headerlink" title="登陆ubuntu"></a>登陆ubuntu</h1><p>因为是双显卡（Intel集显 + Geforce MX150），这可能会导致开机登陆困难，原因是默认的独显驱动有问题，导致机器卡死。</p>
<ol>
<li><p>在grub引导时，对ubuntu按&quot;e&quot;，倒数第二行找到<code>quiet splash *</code>，修改为<code>quiet splash acpi_osi=linux nomodeset *</code>，按&quot;F10&quot;引导。这么做是为了禁用所有显卡驱动。</p>
</li>
<li><p>开机后分辨率是800*600的，操作不便时按&quot;Alt+F7&quot;移动窗口。</p>
</li>
<li><p>安装vim。(喜欢gedit的不安装也完全可以)</p>
</li>
<li><p>按照以下代码禁用Nvidia开源显卡驱动</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/modprobe.d/blacklist.conf

<span class="token comment"># 文件内加入以下黑名单</span>
blacklist vga16fb
blacklist nouveau
blacklist rivafb
blacklist rivatv
blacklist nvidiafb

<span class="token comment"># 保存退出，然后更新boot配置</span>
<span class="token function">sudo</span> update-initramfs -u
<span class="token function">sudo</span> <span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>现在可以正常开机了。接下来安装Nvidia官方闭源驱动（可跳过）。打开ubuntu自带软件Software &amp; Updates，在Additional Drivers里勾选闭源驱动，版本号选大一点，Apply Changes，等一段时间下载安装即可。</p>
</li>
<li><p>重启电脑，Enjoy！可以根据喜好调整NVIDIA X Server Settings的内容。<br>PS：不要自行下载英伟达官网的驱动！亲测无效！相信我！</p>
</li>
<li><p>调整grub引导，自己看着办吧，当然不是必须的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/default/grub
<span class="token function">sudo</span> <span class="token function">update-grub</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="触摸板右键失灵"><a href="#触摸板右键失灵" class="headerlink" title="触摸板右键失灵"></a>触摸板右键失灵</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gsettings <span class="token builtin class-name">set</span> org.gnome.desktop.peripherals.touchpad click-method areas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>ubuntu默认源已经很久没更新Vim，所以加上源</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> add-apt-repository ppa:jonathonf/vim <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>再给出竞赛用~/.vimrc岂不美哉！赶紧背下来！</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token keyword">number</span>
<span class="token keyword">set</span> <span class="token builtin">cindent</span>
<span class="token keyword">set</span> <span class="token builtin">autoread</span>
<span class="token keyword">set</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token keyword">set</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token keyword">set</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span>

nnoremap <span class="token operator">&lt;</span>F9<span class="token operator">></span> <span class="token punctuation">:</span><span class="token keyword">call</span> <span class="token function">CompileCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>
func<span class="token operator">!</span> <span class="token function">CompileCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    exec <span class="token string">"w"</span>
    <span class="token keyword">if</span> &amp;<span class="token keyword">filetype</span> <span class="token operator">==</span> <span class="token string">'cpp'</span>
        exec <span class="token string">"g++ -Wall -DDEBUG % -o %&lt;"</span>
    <span class="token keyword">endif</span>
endfunc

nnoremap <span class="token operator">&lt;</span>F10<span class="token operator">></span> <span class="token punctuation">:</span><span class="token keyword">call</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>
func<span class="token operator">!</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    exec <span class="token string">"!./%&lt;"</span>
endfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果控制台&quot;F10&quot;被占用，就在preferences里取消掉。</p>
<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p>没什么好说的，只想说：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dpkg --get-selections <span class="token operator">|</span> <span class="token function">grep</span> firefox
<span class="token function">sudo</span> <span class="token function">apt</span> purge firefox firefox-locale-en firefox-locale-zh-hans
<span class="token function">sudo</span> <span class="token function">apt</span> autoremove
<span class="token comment"># 司马笑</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>借助Settings Sync插件可以很快配置Code，但是各种task还需要自行备份。</p>
<h1 id="飞机"><a href="#飞机" class="headerlink" title="飞机"></a>飞机</h1><p>第一次在~/.local下安装软件，需要注销重登陆才能正常使用。<br>某些算法需要额外的库，比如</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libsodium-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>搞定之后在Settings-&gt;...-&gt;Socks Host作调整即可。</p>
<h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p>调整控制台的配色和透明度，换壁纸等等，不多说了。</p>
<p>ubuntu很鸡贼，用日本字来糊弄我，字体很不好看，统统干掉。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将SC挪到最前面，解决“门”等字显示不正常的问题。</span>
<span class="token function">sudo</span> <span class="token function">vim</span> /etc/fonts/conf.d/64-language-selector-prefer.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其他杂七杂八的东西就自行解决吧，祝看官ubuntu旅程愉快！</p>
]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin语法笔记</title>
    <url>/2019/10/12/kotlin/</url>
    <content><![CDATA[<p>Since 2019/10/12</p>
<span id="more"></span>

<h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><code>val a: Int = 10 // 声明常量</code></li>
<li><code>var b = 6.99 // 声明变量</code></li>
</ol>
<table>
<thead>
<tr>
<th>Java</th>
<th>Kotlin</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Int</td>
<td>整型</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>长整型</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>短整型</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>单精度</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>双精度</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>布尔型</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
<td>字符型</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>字节型</td>
</tr>
</tbody></table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">myIntMax</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Int<span class="token punctuation">,</span> p2<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>单表达式化简-&gt;</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">myIntMax</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Int<span class="token punctuation">,</span> p2<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>类型推导化简-&gt;</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">myIntMax</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Int<span class="token punctuation">,</span> p2<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>用 if 实现max()</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">myIntMax</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Int<span class="token punctuation">,</span> p2<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">></span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        value <span class="token operator">=</span> p1
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        value <span class="token operator">=</span> p2
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> value
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用 if 的返回值-&gt;</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">></span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    p1
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    p2
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>单表达式化简-&gt;</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">myIntMax</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Int<span class="token punctuation">,</span> p2<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">></span> p2<span class="token punctuation">)</span> p1 <span class="token keyword">else</span> p2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>带参数的 when，参数类型没有限制</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">getScore</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"Tom"</span> <span class="token operator">-></span> <span class="token number">86</span>
    <span class="token string">"Jim"</span> <span class="token operator">-></span> <span class="token number">77</span>
    <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还可以按类型选择</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">checkNumber</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Number 是数字数据类型的父类</span>
    <span class="token keyword">when</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">is</span> Int <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num is Int"</span><span class="token punctuation">)</span>
        <span class="token keyword">is</span> Double <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num is Double"</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"number not support"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不带参数的 when，更加灵活</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">getScore</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">&#123;</span>
    name<span class="token punctuation">.</span><span class="token function">startWith</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">86</span>
    name <span class="token operator">==</span> <span class="token string">"Jim"</span> <span class="token operator">-></span> <span class="token number">77</span> <span class="token comment">// 不需要显式equals()</span>
    name <span class="token operator">==</span> <span class="token string">"Jack"</span> <span class="token operator">-></span> <span class="token number">95</span>
    <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>和 Java 相同。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>取消了 for-i 循环。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> range <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">10</span> <span class="token comment">// 创建一个左闭右闭区间</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右闭区间</span>
        <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span> until <span class="token number">10</span> step <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右开区间</span>
	    <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">10</span> downTo <span class="token number">1</span> step <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右闭降序</span>
        
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Person <span class="token punctuation">&#123;</span> <span class="token comment">// 默认public，且不可继承</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">""</span> <span class="token comment">// 默认public</span>
    
    <span class="token keyword">fun</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" is eating."</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">val</span> p <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不需要new</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="继承与构造函数"><a href="#继承与构造函数" class="headerlink" title="继承与构造函数"></a>继承与构造函数</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">open</span> <span class="token keyword">class</span> Person <span class="token punctuation">&#123;</span> <span class="token comment">// open，允许继承</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 主构造函数</span>
<span class="token keyword">class</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">val</span> sno<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> grage<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token comment">/*调用父构造函数*/</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// sno, grage自动成为类成员</span>
    <span class="token comment">// 如果不想自动成为类成员，则不要加val或var修饰符</span>
    <span class="token comment">/* 向主构造函数加逻辑
    init &#123;
        println("sno is " + sno)
    &#125;
    */</span>
    
    <span class="token comment">// 此构造函数</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"dzf"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    
<span class="token punctuation">&#125;</span>

<span class="token comment">// 仅有次构造函数</span>
<span class="token comment">// 则声明处不需要声明调用父构造函数了</span>
<span class="token keyword">class</span> Stu<span class="token operator">:</span> Person <span class="token punctuation">&#123;</span>
    <span class="token comment">// 没有了主构造函数，这里就不能this()，只能super()</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">,</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Study <span class="token punctuation">&#123;</span>
    <span class="token keyword">fun</span> <span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 可以不实现</span>
    <span class="token keyword">fun</span> <span class="token function">doHomework</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 也可以提供默认实现</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token function">Stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Study <span class="token punctuation">&#123;</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 覆盖实现</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"reading."</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>Java</th>
<th>Kotlin</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>所有类可见</td>
<td>所有类可见（默认）</td>
</tr>
<tr>
<td>private</td>
<td>当前类可见</td>
<td>当前类可见</td>
</tr>
<tr>
<td>protected</td>
<td>当前类、子类、同一包下的类可见</td>
<td>当前类、子类可见</td>
</tr>
<tr>
<td>default</td>
<td>同一包下的类可见</td>
<td>无</td>
</tr>
<tr>
<td>internal</td>
<td>无</td>
<td>同一模块下的类可见</td>
</tr>
</tbody></table>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>类修饰符<code>data</code>，自动生成各种方法：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Cellphone</span><span class="token punctuation">(</span><span class="token keyword">val</span> brand<span class="token operator">:</span>String<span class="token punctuation">,</span> <span class="token keyword">val</span> number<span class="token operator">:</span>Int<span class="token punctuation">)</span> <span class="token comment">// 没有代码，省略大括号</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> Boolean <span class="token function">equals</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> Int <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">override</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>类修饰符<code>object</code>，使类名成为全局唯一对象</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">object</span> Singleton <span class="token punctuation">&#123;</span> <span class="token comment">// 注意没有class</span>
    <span class="token keyword">fun</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

Singleton<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="伴生单例"><a href="#伴生单例" class="headerlink" title="伴生单例"></a>伴生单例</h3><p>包裹在 <code>companion object &#123;&#125;</code> 内部即可。性质类似静态成员。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Util <span class="token punctuation">&#123;</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// @JvmStatic</span>
        <span class="token keyword">fun</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Util <span class="token punctuation">&#123;</span>
    
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="真正的静态成员"><a href="#真正的静态成员" class="headerlink" title="真正的静态成员"></a>真正的静态成员</h4><p>在伴生单例内加入 <code>@JvmStatic</code> 注解，或者，顶层方法是静态成员方法。</p>
<p>在 Java 中，将 kt 的文件名看作类名，即可调用 kotlin 顶层方法。</p>
<h2 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>列表</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> list <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 可变</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Banana"</span><span class="token punctuation">)</span>
<span class="token comment">// -------------------------------</span>
<span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">)</span> <span class="token comment">// 不可变</span>
<span class="token keyword">val</span> list2 <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">)</span> <span class="token comment">// 可变</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>fruit <span class="token keyword">in</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>集合</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token function">setOf</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">)</span> <span class="token comment">// HashSet</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Map</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> map <span class="token operator">=</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
map<span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// --------------------------------</span>
<span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string">"Apple"</span> <span class="token keyword">to</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span> <span class="token keyword">to</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// to 是 infix函数</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fruit<span class="token punctuation">,</span> number<span class="token punctuation">)</span> <span class="token keyword">in</span> map<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span>fruit <span class="token operator">+</span> <span class="token string">" is "</span> <span class="token operator">+</span> number<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a>集合的函数式API</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> maxLengthFruit<span class="token operator">:</span> String <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> isOk<span class="token operator">:</span> Boolean <span class="token operator">=</span> newList<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> isFault<span class="token operator">:</span> Boolean <span class="token operator">=</span> newList<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span>length <span class="token operator">>=</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Lambda表达式语法结构：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token punctuation">&#123;</span>v1<span class="token operator">:</span> Type<span class="token punctuation">,</span> v2<span class="token operator">:</span> Type <span class="token operator">-></span> body<span class="token punctuation">&#125;</span>
<span class="token comment">// 返回值是body的最后一行代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Lambda表达式举例</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> lambda <span class="token operator">=</span> <span class="token punctuation">&#123;</span> fruit<span class="token operator">:</span> String <span class="token operator">-></span> fruit<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span>lambda<span class="token punctuation">)</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> fruit<span class="token operator">:</span> String <span class="token operator">-></span> fruit<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// lambda是最后一个参数</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> fruit<span class="token operator">:</span> String <span class="token operator">-></span> fruit<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span>

<span class="token comment">// lambda是唯一一个参数</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">&#123;</span> fruit<span class="token operator">:</span> String <span class="token operator">-></span> fruit<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span>

<span class="token comment">// 自动推导参数类型</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">&#123;</span> fruit <span class="token operator">-></span> fruit<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span>

<span class="token comment">// lambda内只有一个参数</span>
<span class="token keyword">val</span> maxLengthFruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">&#123;</span> it<span class="token punctuation">.</span>length <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Java函数式API"><a href="#Java函数式API" class="headerlink" title="Java函数式API"></a>Java函数式API</h3><p>Java单抽象方法接口（例如Runnable）</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> Runnable <span class="token punctuation">&#123;</span> <span class="token comment">// object 关键字，代表一个匿名对象</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running."</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// Runnable只有一个抽象方法</span>
<span class="token function">Thread</span><span class="token punctuation">(</span>Runnale <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running."</span><span class="token punctuation">)</span> <span class="token comment">// Lambda表达式覆盖run()</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// </span>

<span class="token comment">// Thread的参数列表中有且只有Runnable</span>
<span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running."</span><span class="token punctuation">)</span> <span class="token comment">// Lambda表达式覆盖run()</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// lambda是唯一一个参数</span>
Thread <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread is running."</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 举例</span>
button<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="常用标准函数"><a href="#常用标准函数" class="headerlink" title="常用标准函数"></a>常用标准函数</h3><ol>
<li><code>let</code> 返回最后一行 <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">obj<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">&#123;</span>
    it<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><code>also</code> 返回本身 <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">obj<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">&#123;</span>
    it<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><code>with</code> 返回最后一行 <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">with</span><span class="token punctuation">(</span><span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>run</code> 返回最后一行 <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span> <span class="token punctuation">&#123;</span>
    <span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>apply</code> 返回本身 <pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">&#123;</span>
    <span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li></li>
</ol>
<h2 id="空类型系统"><a href="#空类型系统" class="headerlink" title="空类型系统"></a>空类型系统</h2><p>Kotlin默认编译器形参不可为空。</p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">doStudy</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Study<span class="token operator">?</span><span class="token punctuation">,</span> b<span class="token operator">:</span> Study<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 加问号，表示可空</span>
    a<span class="token punctuation">.</span><span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 编译错误，未处理空</span>
    a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确，若a为null则返回null</span>
    a<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确，向编译器保证a不为空。</span>
    <span class="token keyword">val</span> c <span class="token operator">=</span> a <span class="token operator">?:</span> b <span class="token comment">// c = if (a!=null) a else b</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fun</span> <span class="token function">getTextLength</span><span class="token punctuation">(</span>text<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">=</span> text<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token operator">?:</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">doStudy</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Study<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 简化版</span>
    a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 内置的let函数</span>
        it<span class="token punctuation">.</span><span class="token function">readBooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        it<span class="token punctuation">.</span><span class="token function">doHomework</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>let</code>函数的优势是暂存了对象引用，不怕全局变量被多线程修改。相反，用<code>if</code>无法保证全局变量的非空。</p>
<h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h2><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">$&#123;</span>obj<span class="token punctuation">.</span>name<span class="token delimiter variable">&#125;</span></span>. Nice to meet you."</span> <span class="token comment">// 表达式</span>
<span class="token string">"Hello, <span class="token interpolation variable">$name</span>. Nice to meet you"</span> <span class="token comment">// 变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="绑定参数"><a href="#绑定参数" class="headerlink" title="绑定参数"></a>绑定参数</h2><p>通过绑定形参-实参，可以调换参数顺序</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token function">myfun</span><span class="token punctuation">(</span>str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


]]></content>
      <tags>
        <tag>语法</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>.vimrc</title>
    <url>/2019/08/25/vimrc/</url>
    <content><![CDATA[<h2 id="vimrc-amp-Font"><a href="#vimrc-amp-Font" class="headerlink" title=".vimrc &amp; Font"></a>.vimrc &amp; Font</h2><p><a href="vimrc/null.vimrc">.vimrc</a></p>
<p><a href="vimrc/FiraCode-Retina.ttf">Fira Code Retina</a></p>
<span id="more"></span>


<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>For 8+ version.</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span>
<span class="token comment">" the call to :runtime you can find below.  If you wish to change any of those</span>
<span class="token comment">" settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span>
<span class="token comment">" will be overwritten everytime an upgrade of the vim packages is performed.</span>
<span class="token comment">" It is recommended to make changes after sourcing debian.vim since it alters</span>
<span class="token comment">" the value of the </span><span class="token string">'compatible'</span> option<span class="token operator">.</span>

<span class="token comment">" This line should not be removed as it ensures that various options are</span>
<span class="token comment">" properly set to work with the Vim-related packages available in Debian.</span>
<span class="token keyword">runtime</span><span class="token operator">!</span> debian<span class="token operator">.</span><span class="token keyword">vim</span>

<span class="token comment">" Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span>
<span class="token comment">" This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span>
<span class="token comment">" any settings in these files.</span>
<span class="token comment">" If you don't want that to happen, uncomment the below line to prevent</span>
<span class="token comment">" defaults.vim from being loaded.</span>
<span class="token comment">" let g:skip_defaults_vim = 1</span>

<span class="token comment">" Uncomment the next line to make Vim more Vi-compatible</span>
<span class="token comment">" NOTE: debian.vim sets </span><span class="token string">'nocompatible'</span><span class="token operator">.</span>  Setting <span class="token string">'compatible'</span> <span class="token keyword">changes</span> numerous
<span class="token comment">" options, so any other options should be set AFTER setting </span><span class="token string">'compatible'</span><span class="token operator">.</span>
<span class="token comment">"set compatible</span>

<span class="token comment">" Vim5 and later versions support syntax highlighting. Uncommenting the next</span>
<span class="token comment">" line enables syntax highlighting by default.</span>
<span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">"syntax"</span><span class="token punctuation">)</span>
  <span class="token builtin">syntax</span> <span class="token keyword">on</span>
<span class="token keyword">endif</span>

<span class="token comment">" If using a dark background within the editing area and syntax highlighting</span>
<span class="token comment">" turn on this option as well</span>
<span class="token keyword">set</span> <span class="token builtin">background</span><span class="token operator">=</span>dark

<span class="token comment">" Uncomment the following to have Vim jump to the last position when</span>
<span class="token comment">" reopening a file</span>
<span class="token string">"if has("</span><span class="token builtin">autocmd</span><span class="token comment">")</span>
<span class="token string">"  au BufReadPost * if line("</span><span class="token string">'\"") > 1 &amp;&amp; line("'</span>\<span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">line</span><span class="token punctuation">(</span><span class="token string">"$"</span><span class="token punctuation">)</span> | exe <span class="token string">"normal! g'\""</span> | <span class="token keyword">endif</span>
<span class="token comment">"endif</span>

<span class="token comment">" Uncomment the following to have Vim load indentation rules and plugins</span>
<span class="token comment">" according to the detected filetype.</span>
<span class="token string">"if has("</span><span class="token builtin">autocmd</span><span class="token comment">")</span>
<span class="token comment">"  filetype plugin indent on</span>
<span class="token comment">"endif</span>

<span class="token comment">" The following are commented out as they cause vim to behave a lot</span>
<span class="token comment">" differently from regular Vi. They are highly recommended though.</span>
<span class="token keyword">set</span> <span class="token builtin">showcmd</span>		<span class="token comment">" Show (partial) command in status line.</span>
<span class="token keyword">set</span> <span class="token builtin">showmatch</span>		<span class="token comment">" Show matching brackets.</span>
<span class="token keyword">set</span> <span class="token builtin">ignorecase</span>		<span class="token comment">" Do case insensitive matching</span>
<span class="token keyword">set</span> <span class="token builtin">smartcase</span>		<span class="token comment">" Do smart case matching</span>
<span class="token string">"set incsearch		"</span> Incremental search
<span class="token keyword">set</span> <span class="token builtin">autowrite</span>		<span class="token comment">" Automatically save before commands like :next and :make</span>
<span class="token keyword">set</span> <span class="token builtin">hidden</span>		<span class="token comment">" Hide buffers when they are abandoned</span>
<span class="token keyword">set</span> <span class="token builtin">mouse</span><span class="token operator">=</span>a		<span class="token comment">" Enable mouse usage (all modes)</span>

<span class="token keyword">set</span> <span class="token builtin">cindent</span>
<span class="token keyword">set</span> <span class="token keyword">number</span>
<span class="token keyword">set</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token keyword">set</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token keyword">set</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token keyword">set</span> <span class="token builtin">autoread</span>

<span class="token comment">" Source a global configuration file if available</span>
<span class="token keyword">if</span> <span class="token function">filereadable</span><span class="token punctuation">(</span><span class="token string">"/etc/vim/vimrc.local"</span><span class="token punctuation">)</span>
  <span class="token keyword">source</span> <span class="token operator">/</span>etc<span class="token operator">/</span><span class="token keyword">vim</span><span class="token operator">/</span>vimrc<span class="token operator">.</span>local
<span class="token keyword">endif</span>

nnoremap <span class="token operator">&lt;</span>F9<span class="token operator">></span> <span class="token punctuation">:</span><span class="token keyword">call</span> <span class="token function">CompileCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>
func<span class="token operator">!</span> <span class="token function">CompileCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	exec <span class="token string">"w"</span>
	<span class="token keyword">if</span> &amp;<span class="token keyword">filetype</span> <span class="token operator">==</span> <span class="token string">'cpp'</span>
		exec <span class="token string">'!g++ -Wall -DDEBUG % -o %&lt;'</span>
	<span class="token keyword">endif</span>
endfunc

nnoremap <span class="token operator">&lt;</span>F10<span class="token operator">></span> <span class="token punctuation">:</span><span class="token keyword">call</span> <span class="token function">RunOUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>
func<span class="token operator">!</span> <span class="token function">RunOUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	exec <span class="token string">'!./%&lt;'</span>
endfunc
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="ps-bashrc"><a href="#ps-bashrc" class="headerlink" title="ps. bashrc"></a>ps. bashrc</h2><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">TEXT::
terminal size : 90 * 34

custom font Fira Code Retina 14
Cell spaceing 1.00 1.00

Cursor : Block, Default

COLORS::
Custom::
	Default: #D3D7CF, #020F20
	Bold: disabled
	Cursor: #FFFFFF, #0350C9
	Hightlight: disabled
	palette: (Tango), blue: #4A7DBE #7EA9D6

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>减少脱发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>初等数论</title>
    <url>/2019/08/02/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="模方程"><a href="#模方程" class="headerlink" title="模方程"></a>模方程</h1><h2 id="基础性质"><a href="#基础性质" class="headerlink" title="基础性质"></a>基础性质</h2><h3 id="模的等价关系"><a href="#模的等价关系" class="headerlink" title="模的等价关系"></a>模的等价关系</h3><p><strong>自反性</strong><br>$$ a\equiv a \mod m $$<br><strong>对称性</strong><br>$$ a\equiv b \mod m\Leftrightarrow b\equiv a \mod m$$</p>
<span id="more"></span>
<p><strong>传递性</strong><br>$$<br>a\equiv c \mod m, c\equiv b\mod m \Rightarrow a\equiv b \mod m<br>$$</p>
<h3 id="等式的性质"><a href="#等式的性质" class="headerlink" title="等式的性质"></a>等式的性质</h3><p><strong>可加减性</strong><br>$$<br>模m意义下\<br>a\equiv b, c\equiv d \Rightarrow a+c\equiv b+d<br>$$<br><strong>可乘性</strong><br>$$<br>模m意义下\<br>a\equiv b, c\equiv d \Rightarrow ac\equiv bd<br>$$</p>
<blockquote>
<p>证明：设$a-b=km$, $c-d=lm$. 则$a=b+km$, $c=d+lm$, $ac=klm^2+(bl+ck)m+bd$, 显然$m|(ac-bd)$</p>
<p>推论：模$m$意义下,$a\equiv b \Rightarrow an\equiv bn$, $n$是自然数</p>
</blockquote>
<p><strong>消去律</strong>（乘法逆元的充要条件）<br>$$<br>模m意义下\<br>ac\equiv bc, gcd(c,m)=1 \Rightarrow a\equiv b<br>$$</p>
<blockquote>
<p>证明：m|c(a-b), 因为c,m公因子为1，所以m|(a-b).</p>
</blockquote>
<p><strong>幂保持恒等</strong><br>$$<br>模m意义下\<br>a\equiv b \Rightarrow a^n\equiv b^n<br>$$</p>
<p><strong>恒等的最大空间</strong><br>$$<br>a\equiv b \mod m_1\<br>a\equiv b \mod m_2\<br>\dotsm \<br>a\equiv b \mod m_n \<br>\Downarrow \<br>a\equiv b \mod lcm(m_1, m_2,\dotsm, m_n);<br>$$</p>
<blockquote>
<p>证明：(a-b)是$m_1,m_2,\dotsm,m_n$的倍数，而lcm包含了所有质因子的最大次幂。</p>
<p>推论：若$m_1,m_2,\dotsm,m_n$互质，则$a\equiv b \mod m_1m_2\dotsm m_n;$</p>
</blockquote>
<p><strong>换模的另一种途径</strong><br>$$<br>a\equiv b \mod c \<br>\Downarrow \<br>ad \equiv bd \mod cd<br>$$</p>
<blockquote>
<p>证明：$c|(a-b)\Rightarrow cd|d(a-b)$。</p>
</blockquote>
<h2 id="高级定理"><a href="#高级定理" class="headerlink" title="高级定理"></a>高级定理</h2><h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><p>$$<br>gcd(a,b)是a,b的线性组合。即存在整数x,y,使得xa+yb=gcd(a,b).<br>$$</p>
<blockquote>
<p>证明：</p>
<p>当$a=b$时结论显然成立。</p>
<p>当$a\neq b$时，不妨设$a\neq0$，取$d$为$a,b$的所有线性组合中最小的正整数。作带余除法$a=qd+r$，则$0\leq r&lt;d$. 若$r\neq 0$,则$r=a-qd$是比d更小的线性组合，与假设矛盾,所以$r=0$,$d$是$a$的因子;同理可得$d$是$b$的因子,故$d$是$a,b$的公因子.取$c$为$a,b$的任意公因子,对$d=(xa+yb)$提取$c$得$d=c(xa&#39;+yb&#39;)$,可知$c$是$d$的因子,所以$|c|\leq d$,故$d=gcd(a,b)$.</p>
</blockquote>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>$$<br>有线性同余方程组\<br>x\equiv a_1 \mod m_1\<br>x\equiv a_2 \mod m_2\<br>\dotsm \<br>x\equiv a_3 \mod m_n \<br>其中m_i两两互质，则在模M=m_1m_2\dotsm m_n意义下解有且只有一个。\<br>构造方法如下：<br>设M_i为\frac{M}{m_i}，在模m_i意义下M_i的逆为t_i。则\<br>x=\sum_{i=1}^{n} a_it_iM_i<br>$$</p>
<blockquote>
<p>证明：</p>
<p>构造解$x$的正确性。对于方程$i$,$\quad t_iM_i\equiv 1 \mod m_i, M_j\equiv 0 \mod m_i$。所以解满足每一条方程式。</p>
<p>在模$M$意义下解的唯一性。令$x_1,x_2$为方程组的两个不同的解,则$(x_1-x_2)$分别是$m_1,m_2\dotsm m_n$的倍数，则$|(x_1-x_2)|\geq M$，则在模$M$意义下解是唯一的。</p>
</blockquote>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>m的化简剩余系（又称既约剩余系，缩系），<strong>本文记为$Z_m$</strong><br>$$<br>m的剩余系中与m互质的数构成的子集<br>$$</p>
<p>欧拉函数$\phi(n)$<br>$$<br>m的化简剩余系的元素个数，即|Z_m|<br>$$</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p>对于质数$p$，$\phi(p)=p-1$ </p>
</li>
<li><p>对于质数$p$，$\phi(p^k)=p^{k-1}(p-1)$</p>
<blockquote>
<p>证明：在$[1,p^k]$中，不与$p^k$互质的有${p,2p,3p,\dotsc,p^k}$共$\frac{p^k}{p}=p^{k-1}$个数，则互质的有$p^k-p^{k-1}=p^{k-1}(p-1)$个数。</p>
</blockquote>
</li>
<li><p><strong>欧拉函数是积性函数</strong>，即对于互质的两数$m_1,m_2$，有$\phi(m_1m_2)=\phi(m_1)\phi(m_2)$</p>
</li>
</ol>
<blockquote>
<p>证明：设$a\in Z_{m_1}, b\in Z_{m_2}$，则有同余方程组<br>$$ N \equiv a \mod m_1\<br>N \equiv b \mod m_2\ $$<br>其中$a,m_1$互质，$b,m_2$互质，$m_1,m_2$互质。则N在模$m_1m_2$下有且仅有唯一解$N=am_2^{-1}m_2+bm_1^{-1}m_1$，显然$N$与$m_1,m_2$都互质，故与$m_1m_2$互质，$N\in Z_{m_1m_2}$。对任意的$N\in Z_{m_1m_2}$，其对应的$(a,b)$也是唯一的。综上，映射$Z_{m_1m_2}\rightarrow Z_{m_1}\times Z_{m_2}$是满射也是单射，则此映射是双射，故$|Z_{m_1m_2}|=|Z_{m_1}||Z_{m_2}|$，即$\phi(m_1m_2)=\phi(m_1)\phi(m_2)$。</p>
</blockquote>
<ol start="4">
<li>对于质数$p$，且$p|a$，则$\phi(ap)=\phi(a)p$</li>
</ol>
<blockquote>
<p>证明：提取$a$的所有p因子得$ap=a&#39;p^xp=a&#39;p^{x+1}$，由积性函数得<br>$$ \begin{aligned}<br>  \phi(ap)=&amp;\phi(a&#39;)\phi(p^{x+1}) \<br>  =&amp;\phi(a&#39;)p^x(p-1)\<br>  =&amp;\phi(a&#39;)p^{x-1}(p-1)p\<br>  =&amp;\phi(a&#39;)\phi(p^x)p\<br>  =&amp;\phi(a&#39;p^x)p\<br>  =&amp;\phi(a)p<br>\end{aligned} $$</p>
</blockquote>
<ol start="5">
<li>欧拉函数通项<br>$$<br>令{p_1,p_2,\dotsc,p_m}为n的所有质因子\<br>\phi(n)=n\prod_{i=1}^m(1-\frac{1}{p_i})<br>$$</li>
</ol>
<blockquote>
<p>证明：<br>$$\begin{aligned}<br>  设n=&amp;\prod_{i=1}^mp_i^{x_i}\<br>  由积性&amp;函数得\<br>  \phi(n)=&amp;\prod_{i=1}^{m}\phi(p_i^{x_i})\<br>  =&amp;\prod_{i=1}^{m}p_i^{x_i}(1-\frac{1}{p_i})\<br>  =&amp;n\prod_{i=1}^m(1-\frac{1}{p_i})<br>  \end{aligned}<br>$$</p>
</blockquote>
<ol start="6">
<li>$\phi(n)(n&gt;2)$是偶数</li>
</ol>
<blockquote>
<p>证明：由欧几里得算法可知$\forall i \in [1,n]$且$i$与n互质，则$(n-i)$也与$n$互质。并且$i \neq (n-i)$，这是因为若相等，有$2i=n$，此时$i(i&gt;1)$不与$n$互质。所以与$n$互质的数成对出现，$\phi(n)(n&gt;2)$是偶数。</p>
</blockquote>
<ol start="7">
<li><strong>质因子的次数不超过欧拉函数值</strong><br>$$<br>设n=p^xs，其中gcd(p,s)=1，则x\leq \phi(n)<br>$$</li>
</ol>
<blockquote>
<p>证明：<br>$$<br>\begin{aligned}<br>\phi(n)=&amp;\phi(p^x)\phi(s) \<br>\geq&amp; \phi(p^x) = p^{x-1}(p-1)<br>\end{aligned}\<br>下面证明x\leq p^{x-1}(p-1)<br>$$<br>取$p=2$，验证得当$x=1,2,3$时不等式都成立。由归纳法可知$p=2$时不等式成立。取$p&gt;2$，等式左边不变，右边变大，不等式仍成立。</p>
</blockquote>
<ol start="8">
<li>$\sum\limits_{d|n}\phi(d) = n$</li>
</ol>
<blockquote>
<p>证明：$\forall k \in [1,n]$，对应有一个$d=gcd(k,n)$。所有可能的$d$取遍了$n$的所有因子。对$d|n$，考虑其对应的$k$，不妨设$k=k_1d,n=k_2d，且gcd(k_1,k_2)=1,那么k_1\leq k_2$。显然$k_2=\frac{n}{d}$是固定的，那么可能的$k_1$的取值有$\phi(k_2)=\phi(\frac{n}{d})$种。所以<br>$$<br>n=\sum\limits_{d|n}\phi(\frac{n}{d})=\sum\limits_{d|n}\phi(d)<br>$$</p>
</blockquote>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>$$<br>对于互质的两个数a,n有\<br>a^{\phi(n)} \equiv 1 \mod n<br>$$</p>
<blockquote>
<p>证明：设$Z_n={x_1,x_2,\dotsc,x_{\phi(n)}}$，因$a,n互质$，则$ax_i \mod n \in Z_n$；而对$x_i\neq x_j$，由消去律有$ax_i\neq ax_j \mod n$。故模n意义下$Z_n={ax_1,ax_2,\dotsc,ax_{\phi(n)}}$。</p>
<p>故<br>$$<br>\prod_{i=1}^{\phi(n)}x_i \equiv \prod_{i=1}^{\phi(n)}ax_i \mod n\<br>$$<br>由消去律得<br>$$<br>a^{\phi(n)} \equiv 1 \mod n<br>$$</p>
<p>推论：<strong>费马小定理</strong>。</p>
</blockquote>
<h3 id="扩展欧拉定理（欧拉降幂）"><a href="#扩展欧拉定理（欧拉降幂）" class="headerlink" title="扩展欧拉定理（欧拉降幂）"></a>扩展欧拉定理（欧拉降幂）</h3><p>$$<br>模m意义下\<br>a^c\equiv<br>\begin{cases}<br>    a^{c \mod \phi(m)}, \qquad &amp;a,m互质\<br>    a^c, \qquad &amp;a,m不互质，c&lt;\phi(m)\<br>    a^{c \mod \phi(m)+\phi(m)}, \qquad &amp;a,m不互质，c\geq \phi(m)<br>\end{cases}<br>$$</p>
<blockquote>
<p>证明：$当a,m互质时$，由欧拉定理知$a^{\phi(m)}\equiv 1 \mod m$，定理显然成立。</p>
<p>$当a,m不互质，c&lt;\phi(m)时$，定理显然成立。</p>
<p>$当 a,m不互质，c\geq \phi(m)时$，取$a$的任意质因子$p$，即$a=p^xs且gcd(p,s)=1$，由欧拉定理知<br>$$p^{\phi(s)}\equiv 1 \mod s$$<br>由积性函数知$\phi(s)|\phi(m)$，故<br>$$p^{\phi(m)}\equiv 1 \mod s$$<br>同余方程同乘$p^x$(<strong>换模的另一种途径</strong>)得<br>$$<br>p^{\phi(m)+x} \equiv p^x \mod m<br>$$<br>由<strong>欧拉函数的性质7</strong>知$x\leq \phi(m)$，已知$\phi(m)\leq c$，所以<br>$$<br>x \leq \phi(m) \leq c\<br>p^c\equiv p^{x+(c-x)}\equiv p^{\phi(m)+x+(c-x)}\equiv p^{\phi(m)+c} \mod m<br>$$<br>由$c(c\geq \phi(m))$的任意性和数学归纳法得<br>$$<br>p^c\equiv p^{c \mod \phi(m) + \phi(m)} \mod m \<br>$$<br>对$p$的幂$p^k$，易得<br>$$<br>(p^k)^c\equiv p^{kc}\equiv p^{kc \mod \phi(m)+\phi(m)}\<br>\equiv p^{kc\mod \phi(m)+k\phi(m)}\equiv (p^k)^{c \mod \phi(m)+\phi(m)} \mod m<br>$$<br>对$a=\prod\limits_{i=1}^np_i^{x_i}$，得<br>$$ \begin{aligned}<br>  a^c\equiv &amp; \prod\limits_{i=1}^n(p_i^{x_i})^c \<br>  \equiv &amp; \prod\limits_{i=1}^n(p_i^{x_i})^{c \mod \phi(m)+\phi(m)} \<br>  \equiv &amp; a^{c \mod \phi(m) + \phi(m)} \mod m<br>\end{aligned}<br>$$</p>
</blockquote>
<hr>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="线性筛质数"><a href="#线性筛质数" class="headerlink" title="线性筛质数"></a>线性筛质数</h2><p>求$[1,n]$内的所有素数。</p>
<ol>
<li>算法核心是<strong>每个合数只被其最小质因子筛到</strong>。</li>
<li>当前判断完$i$是否质数。接下来筛去i的倍数。枚举已知质数$p_j$，筛去$p_j*i$。若$p_j$是$i$的最小质因子则break。这是因为i以后筛的数都以$p_j$为最小质因子，这些数肯定能被其他的$i$枚举$p_j$筛去，不必重复筛。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getPrime(int n) &#123;
    &#x2F;&#x2F; memset(vis, 0, sizeof(vis));
    pcnt &#x3D; 0;
    vis[0] &#x3D; vis[1] &#x3D; true;
    for (int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;
        if (!vis[i]) prime[pcnt++] &#x3D; i;
        for (int j&#x3D;0; j&lt;pcnt &amp;&amp; prime[j]*i&lt;&#x3D;n; ++j) &#123;
            vis[prime[j]*i] &#x3D; true;
            if (i % prime[j] &#x3D;&#x3D; 0) break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h2><p>求$[1,n]$内所有欧拉函数值</p>
<ol>
<li>算法核心是<strong>积性函数</strong>和<strong>欧拉函数性质4</strong></li>
<li>在线性筛的同时完成欧拉函数计算。当前判断完$i$是否质数，若是合数，则函数值在前面计算过了；若是质数，直接赋值$\phi(i)=i-1$。枚举已知质数$p_j$时，若$p_j$不是$i$的因子，由积性函数可知$\phi(i\cdot p_j)=\phi(i)\cdot \phi(p_j)=\phi(i)\cdot (p_j-1)$ ; 若$p_j$是$i$的因子，由<strong>性质4</strong>得$\phi(i\cdot p_j)=\phi(i)\cdot p_j$，然后break。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void getPhi(int n) &#123;
    &#x2F;&#x2F; memset(phi, 0, sizeof(phi));
    pcnt &#x3D; 0;
    phi[1] &#x3D; 1;
    for (int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;
        if (phi[i] &#x3D;&#x3D; 0) &#123;
            prime[pcnt++] &#x3D; i;
            phi[i] &#x3D; i - 1;
        &#125;
        for (int j&#x3D;0; j&lt;pcnt &amp;&amp; i*prime[j]&lt;&#x3D;n; ++j) &#123;
            if (i % prime[j] &#x3D;&#x3D; 0) &#123;
                phi[i * prime[j]] &#x3D; phi[i] * prime[j];
                break;
            &#125; else &#123;
                phi[i * prime[j]] &#x3D; phi[i] * (prime[j]-1);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a><strong>欧几里得算法</strong>（辗转相除法）</h2><p>求$gcd(a,b)$。</p>
<ol>
<li>$gcd(a, 0)$的结果显然等于$a$。</li>
<li>当$a，b$全不为零，则$gcd(a,b) = gcd(b, a \mod b )$使问题规模减小。<blockquote>
<p>证明：令$c=a\mod b$,则$a=kb+c$.设$r$是$a,b$的公约数，则$r|a-kb$即$r|c$.设$r$是$b,c$的公约数,则$r|kb+c$即$r|a$.可见$a,b$的公约数和$b,a\mod b$的公约数完全相同，则最大公约数也必然相同。</p>
<p>应用：从$1$到$n(n&gt;2)$中与$n$互质的数成对出现，每一对和为$n$</p>
</blockquote>
</li>
</ol>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a><strong>扩展欧几里得算法</strong></h2><p>求$ax+by=gcd(a,b)$的一组整数解$x,y$。</p>
<ol>
<li>直接由<strong>贝祖定理</strong>可知整数解一定存在。（贝祖定理：存在整数$s，t$使得$sa+tb=gcd(a,b)$）</li>
<li>由辗转相除法知$bx&#39;+(a%b)y&#39;=gcd(b,a%b)=gcd(a,b)$的解也存在。由整数除法得<br>$$\begin{aligned}<br> bx&#39;+(a%b)y&#39;=&amp;bx&#39;+(a-\frac{a}{b}b)y&#39;\<br> =&amp;b(x&#39;-\frac{a}{b}y&#39;)+ay&#39;=gcd(a,b)<br>\end{aligned}<br>$$</li>
<li>递归进行求解，直到$b=0$，显然有解$1a+0b=gcd(a,b)$，令$x=1, y=0$，回溯，得解$x=y&#39;, y=x&#39;-\frac{a}{b}y&#39;$</li>
<li>实际写代码时用引用，减少临时变量。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y) &#123;
    if (b &#x3D;&#x3D; 0) &#123;
        x &#x3D; 1; y &#x3D; 0;
        d &#x3D; a;
        return;
    &#125;
    exgcd(b, a%b, d, y, x); &#x2F;&#x2F; x和y完成了交换
    y -&#x3D; a &#x2F; b * x;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a><strong>类欧几里得算法</strong></h2><p>求等差数列对每一项做整数除法的和，即<br>$$<br>lgcd(a, b, c, n) = \sum_{i=0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor<br>$$</p>
<ol>
<li><p>首先标准化$a,b$，使满足$a\geq 0, b\geq 0$，在答案中预先减去补上的$c$即可。</p>
</li>
<li><p>把$a,b$中含$c$的贡献拆出来，使问题规模变小。答案加上$n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor$。即<br>$$<br>\sum_{i=0}^{n-1}\lfloor \frac{ai+b}{c}\rfloor = \sum_{i=0}^{n-1}\lfloor \frac{(a%c)i+(b%c)}{c}\rfloor + n\lfloor \frac{b}{c}\rfloor + \frac{(n-1)n}{2}\lfloor \frac{a}{c}\rfloor<br>$$<br>现在可以令$a&#39;=a%c,\quad b&#39;=b%c$。</p>
</li>
<li><p>计算$\sum\limits_{i=0}^{n-1}\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor$，得到的商肯定介于$[0,\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor]$，设某次除法得到的商是$x$，可以认为$[1,x]$中每一个数对答案贡献了$1$，考虑每个数的总贡献，则<br>$$<br>\sum\limits_{i=0}^{n-1}\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor = \sum_{j=1}^{\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor} \sum_{i=0}^{n-1} [\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor \geq j]<br>$$</p>
</li>
<li><p>接下来变换不等式$\lfloor \frac{a&#39;i+b&#39;}{c}\rfloor \geq j$。 取整符号不影响大于等于号的判断，可直接去掉；可直接通分；移项得$a&#39;i\geq jc-b&#39;$。整数除法的同除会影响大于等于号的判断，但不影响大于号，于是右边减一，两边同除$a&#39;$得$i&gt;\frac{jc-b&#39;-1}{a&#39;}$。</p>
</li>
<li><p>为了方便统计合法的$i$，也为了转化形式满足递归，利用补集统计数量。对于固定的$j$，<br>$$ \begin{aligned}<br> \sum\limits_{i=0}^{n-1} [i&gt;\frac{jc-b&#39;-1}{a&#39;}] =&amp; n-\sum\limits_{i=0}^{n-1} [i\leq\frac{jc-b&#39;-1}{a&#39;}] \<br> =&amp; n-(\lfloor\frac{jc-b&#39;-1}{a&#39;}\rfloor+1)<br>\end{aligned}<br>$$</p>
</li>
<li><p>套上前一层Sigma，得到递归形式（<strong>注意j变成从0开始</strong>）<br>$$<br>令m={\lfloor\frac{a&#39;(n-1)+b&#39;}{c}\rfloor} \<br>\sum_{j=0}^{m-1}[n-(\lfloor\frac{(j+1)c-b&#39;-1}{a&#39;}\rfloor+1)] = (n-1)m-lgcd(c, c-b&#39;-1,a&#39;,m)<br>$$</p>
</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Sum&#123;(ai+b)/c&#125; for i=0..n-1</span>
LL <span class="token function">lgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> LL n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	LL res <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token operator">/</span>c<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">/</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> a <span class="token operator">%</span> c<span class="token punctuation">;</span> b <span class="token operator">=</span> b <span class="token operator">%</span> c<span class="token punctuation">;</span>
	LL m <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">/</span>c<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>m <span class="token operator">-</span> <span class="token function">lgcd</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token operator">-</span>b<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">+</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>质因数分解时，质因数要么小于等于$\sqrt{n}$，要么等于$n$。不要漏掉等于$n$的情况。</li>
<li>1e8+7以内的质数<br>有5761456个，约为6e6，约为范围的1/15。</li>
</ol>
<p><strong>范围越大，质数的占比越小</strong></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈</title>
    <url>/2019/07/08/%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h1 id="组合游戏"><a href="#组合游戏" class="headerlink" title="组合游戏"></a>组合游戏</h1><ol>
<li>两个游戏者轮流操作</li>
<li>游戏的状态集有限，每种状态最多出现一次（游戏可以结束）</li>
<li>无法操作的输，另一个获胜（游戏必有胜负）</li>
<li>公平游戏。两个游戏者面对相同的状态允许有相同的操作。</li>
</ol>
<span id="more"></span>

<h3 id="状态判定"><a href="#状态判定" class="headerlink" title="状态判定"></a>状态判定</h3><ol>
<li>一个状态是必胜状态(N)当且仅当它至少有一个后继是必败状态。</li>
<li>一个状态是必败状态(P)当且仅当它的所有后继都是必胜状态。</li>
<li>特别地，没有后继的状态是必败状态。</li>
</ol>
<h3 id="后手必胜的必要条件"><a href="#后手必胜的必要条件" class="headerlink" title="后手必胜的必要条件"></a>后手必胜的必要条件</h3><p>如果后手有必胜策略，则无论先手怎么取，都会存在后继可导致必败状态（即先手的所有后继都是必胜）。若先手能直接到达必败状态，则后手必输。</p>
<p>如Chomp!游戏（m*n棋盘，每次取某个点的所有右上格子，取到最后一个输）中，只要格子大于1，先手取最右上的一个格子，若后手能导致必败状态，则开局先手模仿后手的策略即可。故格子大于1时后手必败。</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>设有状态x，令SG(x) = mex(S), S为x的所有后继状态的SG值的集合，mex(S)为不在集合中的最小非负整数。对于没有后继的状态，SG=0，因为S是空集。其余的SG值可由递推得到。<br>当且仅当SG(x) == 0, x是必败状态。</p>
<h2 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h2><p>一个总游戏的SG值等于子游戏的SG值的Nim和（异或和）</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol>
<li>证明P状态的所有后继都是N状态<ol>
<li>异或和为零，对转移任意一状态，则异或和必不为零（新状态异或旧状态不为零），即后继必为N</li>
</ol>
</li>
<li>证明N状态的后继存在P状态<ol>
<li>异或和不为零，</li>
</ol>
</li>
</ol>
<h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>有n堆火柴，每堆有ai根火柴。每次选择一堆取走任意根，不能取的游戏者输。</p>
<p>考虑只有一堆的情况，设剩余火柴数为x。若x==0，没有后继状态，SG(0) = 0; 若x==1，所有后继状态的SG集合{0}，则SG(1) = 1; 若x==2，对应的S=={0，1}，SG(2) = 2; 归纳法证明SG(x) = x;</p>
<p>应用SG定理，对于多堆游戏，总游戏SG值为所有子游戏的SG值的Nim和，即所有堆火柴数的异或和。当且仅当异或和为0，先手必败。</p>
<h2 id="组合游戏题解法"><a href="#组合游戏题解法" class="headerlink" title="组合游戏题解法"></a>组合游戏题解法</h2><p>小范围内暴力计算子游戏SG值，找规律找到SG公式。</p>
<h1 id="博弈搜索"><a href="#博弈搜索" class="headerlink" title="博弈搜索"></a>博弈搜索</h1><p>CF ROUND 460 DIV2 F</p>
<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><ol>
<li>圆桌放圆盘<ol>
<li>对称性。先手占领圆心，后面被一步都模仿另一方。</li>
</ol>
</li>
<li>硬币环取1-K连续<ol>
<li>分类讨论K</li>
</ol>
</li>
<li>威佐夫博弈：两堆石子，取任意个时可对两堆同时操作<ol>
<li>记结论(x0=0, y0=0),(xk=mex{xi,yi}, yk=xk+k)必败</li>
<li>$a_k=\frac{\sqrt{5}+1}{2}k$</li>
<li>扩展：三堆，可同时操作两堆<ol>
<li>必败态少，跳过必胜态</li>
</ol>
</li>
</ol>
</li>
<li>每次一堆分别成异或加数两堆（每堆小于源堆）</li>
<li>反NIM游戏，先手必胜条件<ol>
<li>每堆石子只有一个，NIM和为零</li>
<li>有一堆石子多于一个，NIM和不为零</li>
</ol>
</li>
<li>SJ定理（泛化反NIM游戏）先手必胜条件<ol>
<li>每个子游戏SG值&lt;=1，SG异或和为零</li>
<li>存在一个子游戏SG&gt;1，SG异或和不为零</li>
</ol>
</li>
<li>Every-SG策略<ol>
<li>必胜态使步骤尽量长</li>
<li>必败态使步骤尽量短</li>
<li>先手获胜充要条件：所有单一游戏SG值最大值是奇数</li>
</ol>
</li>
<li>有根无向图删边游戏<ol>
<li>若无环，Colon定理</li>
<li>可能有环，Fushion等价缩环变树</li>
</ol>
</li>
<li>齐肯多夫定理：任何正整数可以唯一的表示为若干个不连续的斐波那契数之和</li>
<li>动态减法游戏（一倍，两倍，k倍）</li>
<li>翻硬币，最右必须由正变反<ol>
<li> 多种扩展</li>
<li> 打表吧</li>
<li>tartan定理<ol>
<li> 二维硬币分解成一维硬币的积，logn2求nim积。这种积有结合律，可扩展到更高维</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>在ACM中使用C++</title>
    <url>/2019/08/28/%E5%9C%A8ACM%E4%B8%AD%E4%BD%BF%E7%94%A8C/</url>
    <content><![CDATA[<p>今天又双叒叕来水博客了……（不务正业）</p>
<h1 id="令人尖叫的STL"><a href="#令人尖叫的STL" class="headerlink" title="令人尖叫的STL"></a>令人尖叫的STL</h1><h2 id="algorithm-系列"><a href="#algorithm-系列" class="headerlink" title="algorithm 系列"></a><strong>algorithm</strong> 系列</h2><h3 id="fill-fill-n-填充数组"><a href="#fill-fill-n-填充数组" class="headerlink" title="fill, fill_n 填充数组"></a><strong>fill</strong>, <strong>fill_n</strong> 填充数组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">fill</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> INF<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> INF<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<span id="more"></span>

<h3 id="unique-unique-copy-对排序后数组去重"><a href="#unique-unique-copy-对排序后数组去重" class="headerlink" title="unique, unique_copy 对排序后数组去重"></a><strong>unique</strong>, <strong>unique_copy</strong> 对排序后数组去重</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unique_copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> b<span class="token punctuation">,</span> 重载<span class="token operator">==</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unique</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">==</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="reverse-reverse-copy-镜像翻转数组"><a href="#reverse-reverse-copy-镜像翻转数组" class="headerlink" title="reverse, reverse_copy 镜像翻转数组"></a><strong>reverse</strong>, <strong>reverse_copy</strong> 镜像翻转数组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">reverse_copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reverse</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="rotate-rotate-copy-数组轮换"><a href="#rotate-rotate-copy-数组轮换" class="headerlink" title="rotate, rotate_copy 数组轮换"></a><strong>rotate</strong>, <strong>rotate_copy</strong> 数组轮换</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">rotate_copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b == &#123;3, 4, 5, 6, 1, 2&#125;</span>
<span class="token function">rotate</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a == &#123;6, 1, 2, 3, 4, 5&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="random-shuffle-随机打乱数组"><a href="#random-shuffle-随机打乱数组" class="headerlink" title="random_shuffle 随机打乱数组"></a><strong>random_shuffle</strong> 随机打乱数组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">random_shuffle</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="partial-sort-数组一次性取前k小"><a href="#partial-sort-数组一次性取前k小" class="headerlink" title="partial_sort 数组一次性取前k小"></a><strong>partial_sort</strong> 数组一次性取前k小</h3><p>时间复杂度$n \log m$</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">partial_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>k<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="partition-partition-copy-元素分成两组"><a href="#partition-partition-copy-元素分成两组" class="headerlink" title="partition, partition_copy 元素分成两组"></a><strong>partition</strong>, <strong>partition_copy</strong> 元素分成两组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point<span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token operator">+</span>n<span class="token punctuation">,</span> <span class="token punctuation">[</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>o2<span class="token operator">-</span>o1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">det</span><span class="token punctuation">(</span>a<span class="token operator">-</span>o1<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 以直线(o1, o2)为界将平面上的点划分成两组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>还有<code>stable_partition</code>版本</p>
<h3 id="merge-inplace-merge-归并数组"><a href="#merge-inplace-merge-归并数组" class="headerlink" title="merge, inplace_merge 归并数组"></a><strong>merge</strong>, <strong>inplace_merge</strong> 归并数组</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 要求分别有序</span>
<span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>aLen<span class="token punctuation">,</span> b<span class="token punctuation">,</span> b<span class="token operator">+</span>bLen<span class="token punctuation">,</span> c<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非原地合并</span>
<span class="token function">inplace_merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span>aLen<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原地合并</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="equal-range-找到存在区间"><a href="#equal-range-找到存在区间" class="headerlink" title="equal_range 找到存在区间"></a><strong>equal_range</strong> 找到存在区间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于使用lower_bound和upper_bound</span>
pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span> bounds <span class="token operator">=</span> <span class="token function">equal_range</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="make-heap-O-n-建堆"><a href="#make-heap-O-n-建堆" class="headerlink" title="make_heap O(n)建堆"></a><strong>make_heap</strong> O(n)建堆</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">make_heap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="sort-heap-对堆排序"><a href="#sort-heap-对堆排序" class="headerlink" title="sort_heap 对堆排序"></a><strong>sort_heap</strong> 对堆排序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">make_heap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sort_heap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="push-heap-堆加入一个元素"><a href="#push-heap-堆加入一个元素" class="headerlink" title="push_heap 堆加入一个元素"></a><strong>push_heap</strong> 堆加入一个元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">a<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token function">push_heap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="pop-heap-堆删除顶端元素"><a href="#pop-heap-堆删除顶端元素" class="headerlink" title="pop_heap 堆删除顶端元素"></a><strong>pop_heap</strong> 堆删除顶端元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">pop_heap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token operator">--</span><span class="token punctuation">,</span> 重载<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="lexicographical-compare-字典序小于"><a href="#lexicographical-compare-字典序小于" class="headerlink" title="lexicographical_compare 字典序小于"></a><strong>lexicographical_compare</strong> 字典序小于</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s1<span class="token operator">+</span>len1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s2<span class="token operator">+</span>len2<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1 &lt; s2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="next-permutation-prev-permutation-求下一排列"><a href="#next-permutation-prev-permutation-求下一排列" class="headerlink" title="next_permutation, prev_permutation 求下一排列"></a><strong>next_permutation</strong>, <strong>prev_permutation</strong> 求下一排列</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">prev_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="Containers-系列"><a href="#Containers-系列" class="headerlink" title="Containers 系列"></a><strong>Containers</strong> 系列</h2><p><em>用到烂的知识点就不多提了。这里只写容易忘的。</em></p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a><strong>bitset</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>bitset&lt;size_t N&gt; foo(int);</code></li>
<li><code>bitset&lt;size_t N&gt; foo(std::string);</code></li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>长度在编译期确定</li>
<li>高位在左，低位在右</li>
<li>重载的方括号可以直接读取、操作位</li>
</ol>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li><code>size_t count()</code> 返回1的个数</li>
<li><code>bool test(size_t pos)</code> 返回非引用的<code>foo[pos]</code></li>
<li><code>bool any()</code> 是否有1</li>
<li><code>bool none()</code> 是否全0</li>
<li><code>bool all()</code> 是否全1</li>
<li><code>bitset&amp; set()</code>  全部位设置为1</li>
<li><code>bitset&amp; set(size_t pos, bool val=true)</code> 设置某个位</li>
<li><code>bitset&amp; reset()</code> 全部设置为0  （也可有参数pos）</li>
<li><code>bitset&amp; flip()</code> 反转全部位  （也可有参数pos）</li>
<li><code>string to_string(char zero, char one)</code> 按要求转化为string</li>
<li><code>unsigned long to_ulong()</code> 转化为UL</li>
<li><code>ULL to_ullong</code> 转化为ULL （C++11）</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ol>
<li><code>map&lt;type1, type2&gt; mymap;</code></li>
<li><code>map&lt;type1, type2&gt; mymap(&#123;&#125;)</code></li>
</ol>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部用平衡树实现</li>
<li>不允许重复的Key</li>
<li>访问必须用迭代器 <code>map&lt;type1, type2&gt;::iterator it;</code></li>
<li><code>it-&gt;first</code> 是Key，不可更变，<code>it-&gt;second</code> 是Value，可以修改。</li>
<li>查找元素必须用<code>it = mymap.find(Key)</code>，失败则返回<code>mymap.end();</code></li>
</ol>
<h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>重载方括号，若Key不存在则建立Key对应的默认构造Value。返回Value的引用。</li>
<li><code>insert()</code> 比较复杂，常用例子：<code>mp.insert(pair&lt;char, int&gt;(&#39;a&#39;, 1));</code></li>
<li><code>iterator begin()</code> 指向头元素的迭代器 （rbegin()指向最后一个元素）</li>
<li><code>iterator end()</code> 指向尾元素的后一个迭代器（rend()指向头元素的前一个迭代器）</li>
<li><code>iterator find(Key)</code> 返回Key对应的迭代器，失败则返回end()。</li>
<li><code>clear()</code> 清空所有键值对，size归零。</li>
<li><code>size_type erase (const key_type&amp; k);</code> 删除Key对应的键值对，返回删除个数</li>
<li><code>iterator erase (const_iterator position);</code> 删除迭代器指向的键值对，返回紧接下一个键值对的迭代器。</li>
<li><code>iterator erase (const_iterator first, const_iterator last);</code> 删除迭代器指向的左闭右开区间的键值对，返回紧接着下一个键值对的迭代器（或<code>end()</code>）。</li>
<li>注意，C++98中<code>erase()</code>不会返回迭代器，而是返回void</li>
<li><code>iterator lower_bound (const key_type&amp; k);</code> 所在上界迭代器</li>
<li><code>iterator upper_bound (const key_type&amp; k);</code> 所在下界迭代器</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><p>结点只有一个元素，不允许重复的红黑树。</p>
<h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ol>
<li>迭代器begin(), end(), rbegin(), rend().</li>
<li>容量empty(), size();</li>
<li>插入<ul>
<li> <code>pair&lt;iterator, bool&gt; insert(const value_type&amp; val);</code> 同时有非const的右值引用版本。</li>
<li> 返回的pair包括一个指向被插入值的迭代器，bool指明是否真的发生了插入操作。（如果元素被来就存在，就为false）</li>
</ul>
</li>
<li>删除<ul>
<li><code>iterator erase(const_iterator position);</code> 删除指定迭代器位置的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>iterator erase(const_iterator first, cosnt_iterator last);</code> 删除指定迭代器的左闭右开区间的元素。返回紧接着的下一个元素的迭代器。</li>
<li><code>size_type erase(const value_type&amp; val);</code> 删除指定的值。 返回被删除的元素个数（0或1）。</li>
</ul>
</li>
<li>交换 <code>swap(set&amp; x);</code> 交换两个类型相同的set。</li>
<li>清空 <code>clear();</code></li>
<li>查找 <code>iterator find(const value_type&amp; val);</code></li>
<li>计数 <code>size_type count(const value_type&amp; val) const;</code></li>
<li>上下界（左闭右开）<ul>
<li><code>iterator lower_bound (const value_type&amp; val);</code></li>
<li><code>iterator upper_bound (const value_type&amp; val);</code></li>
<li><code>pair&lt;iterator,iterator&gt; equal_range (const value_type&amp; val);</code> 包括了下界和上界。</li>
</ul>
</li>
</ol>
<h2 id="C标准库-系列"><a href="#C标准库-系列" class="headerlink" title="C标准库 系列"></a><strong>C标准库</strong> 系列</h2><h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a><strong>assert</strong> 断言</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span>

<span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>ch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-></span>fa <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>ch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-></span>fa <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NDEBUG</span></span>
<span class="token comment">// NDEBUG 标记可删除assert</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="isdigit-判断字符是否十进制数"><a href="#isdigit-判断字符是否十进制数" class="headerlink" title="isdigit 判断字符是否十进制数"></a><strong>isdigit</strong> 判断字符是否十进制数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> minus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="泯灭人性的数据类型"><a href="#泯灭人性的数据类型" class="headerlink" title="泯灭人性的数据类型"></a>泯灭人性的数据类型</h1><h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节数</th>
<th align="center">估计范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">±2e9</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">±3e4</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">1</td>
<td align="center">保有127</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">37数量级，7位</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">307数量级，15位</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">16</td>
<td align="center">4931数量级，20位</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">8</td>
<td align="center">9e18</td>
</tr>
<tr>
<td align="center">__int128_t</td>
<td align="center">16</td>
<td align="center">8.5e37</td>
</tr>
</tbody></table>
<blockquote>
<p>计算struct内存时要小心！最好使用<code>sizeof</code>的方式计算内存。</p>
</blockquote>
<h2 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf"></a>scanf和printf</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unsigned int</td>
<td align="center">%u %o(8进制) %x(16进制)</td>
</tr>
<tr>
<td align="center">unsigned long long</td>
<td align="center">%llu</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">入%lf，出%f</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">%Lf</td>
</tr>
<tr>
<td align="center">__int128_t</td>
<td align="center">不可用</td>
</tr>
</tbody></table>
<h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><p>gets()已经被删除。</p>
<p>读入int之类的操作不会吃掉行末，这会导致下一个<code>getline(st, size)</code>得到空串。</p>
<p>保险起见，应当自定义读入行。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分学备忘录</title>
    <url>/2019/02/03/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%AD%A6%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<!-- 今日立志，做一个对数学敏感的大学生！ -->

<span id="more"></span>

<h1 id="均值不等式"><a href="#均值不等式" class="headerlink" title="均值不等式"></a>均值不等式</h1><h2 id="四种均值"><a href="#四种均值" class="headerlink" title="四种均值"></a>四种均值</h2><ol>
<li>平方平均值 $Q_n=\sqrt{ \frac{\sum_{i=1}^n x_i^2}{n} }$</li>
<li>算术平均值 $A_n=\frac{\sum_{i=1}^n x_i}{n}$</li>
<li>几何平均值 $G_n=\sqrt[n]{x_1 x_2 \cdots x_n}$</li>
<li>调和平均值 $H_n=\frac{1}{\sum_{i=1}^n {\frac{1}{x_i}}}$</li>
</ol>
<h2 id="四种均值的大小关系"><a href="#四种均值的大小关系" class="headerlink" title="四种均值的大小关系"></a>四种均值的大小关系</h2><p>$$ Q_n \geq A_n \geq G_n \geq H_n $$</p>
<h3 id="证明-G-n-leq-A-n"><a href="#证明-G-n-leq-A-n" class="headerlink" title="证明$G_n \leq A_n$"></a>证明$G_n \leq A_n$</h3><ul>
<li><p>分析: 采用数学归纳法. 易证$n=2$的情况. 令$a=A_n$. 要从n-1推出n, 先让开n次方转为幂次. 左端设法变为$a_1a_2\cdots a_n$, 右端设法变为$a^{n-1}\times a$. 原右边是n-1个数求均, 要变成n个数求均, 需要修改第一项以加入$a_n$. 令$\frac{a_2+\cdots +a_{n-1}+x}{n-1}=a$, 左边只能平分n-1份, 少了一份恰为a, 则$x=a_1+a_n-a$. 原左边对应地要将$a_1$替换成$a_1+a_n-a$, 且最后补乘了$a$, 所以应该建立关系$a_1a_n$~$a(a_1+a_n-a)$. 从不等式$(a-a_1)(a-a_n)\leq 0$可以获得这个关系.</p>
</li>
<li><p>证明:<br>  不妨设$a_1, a_2$为所有项中的最小,最大值.  $a=\frac{a_1+\cdots +a_n}{n}$, 则$a_1\leq a\leq a_n$.<br>  $$(a-a_1)(a-a_n)\leq 0 \Rightarrow a_1a_n \leq a(a_1+a_n-a)$$<br>  易证n=2时成立.<br>  假设当n-1时成立,即<br>  $$\sqrt[n-1]{a_2+\cdots +a_{n-1}+(a_1+a_n-a)}\leq \frac{a_2+\cdots +a_{n-1}+(a_1+a_n-a)}{n-1}=a$$<br>  $$a_1a_2\cdots a_n\leq a2+\cdots +a_{n-1}+a(a_1+a_n-a)\leq a^{n-1}\cdot a=a^n $$<br>  $$\therefore\sqrt[n]{a_1\cdots a_n}\leq a=\frac{a_1+\cdots +a_n}{n}$$</p>
</li>
</ul>
<h1 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h1><h2 id="收敛数列定义"><a href="#收敛数列定义" class="headerlink" title="收敛数列定义"></a>收敛数列定义</h2><p>$设数列a_n及常数a, 若\forall \epsilon &gt; 0, \exists N \in Z^+,当n&gt;N时, 总有|a_n-a|&lt;\epsilon, 则称数列{a_n}的极限为a, 记作$<br>$$\lim\limits_{n\to \infty}a_n=a或a_n \to a(n\to \infty)$$<br>$此时也称数列收敛, 否则称数列发散.$</p>
<h2 id="收敛数列的性质"><a href="#收敛数列的性质" class="headerlink" title="收敛数列的性质"></a>收敛数列的性质</h2><ul>
<li>收敛数列的极限唯一<ul>
<li>证法: 反证法.取$\epsilon = \frac{b-a}{2}$, 当$n&gt;max{N_1, N_2}, \frac{a+b}{2} &lt; a_n &lt; \frac{a+b}{2}$, 矛盾.</li>
</ul>
</li>
<li>收敛数列必有界<ul>
<li>$\epsilon 取1, n&gt;N_1时, a-1&lt;a_n&lt;a+1. 再考虑前N_1有限项, 可知有界$</li>
<li>函数收敛无法保证前有限项</li>
<li>推论: 无界数列发散.</li>
<li>有界不一定收敛(跳跃型)</li>
<li>发散不一定无界(跳跃型)</li>
</ul>
</li>
<li>收敛数列的不等式性质<ul>
<li>$\lim a_n &lt; \lim b_n, 则\exists N, 当n&gt;N, a_n&lt;b_n$</li>
<li>反之不一定成立, 极限可能相等</li>
<li>推论: 若$a_n \geq b_n,$则$a \geq b$</li>
</ul>
</li>
<li>保号性<ul>
<li>若极限值非零, 则有连续无穷多项的符号和极限值相同</li>
<li>保号性是不等式性质的推论</li>
<li>推论: 若有连续无穷多项非负(非正), 则极限值非负(非正) (极限值可能为0).</li>
</ul>
</li>
<li>两数列极限的四则运算<ul>
<li>条件是两数列极限存在. 作为除数的极限非零.</li>
<li>推广: 有限项数列极限可进行四则运算.<ul>
<li>条件: 各项数列极限存在, 作为除数的极限非零.</li>
<li>对于分式, 调整分子分母使上下极限存在, 套用四则运算化出分子分母极限.</li>
<li>对于$\infty -\infty$型, 通分或有理化成分式.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><blockquote>
<p>改变数列的有限项, 数列的收敛性和极限不变</p>
</blockquote>
<ul>
<li>若收敛数列被改变, 设被改变的最后一项是k, 取$N=\max(k, N_1)$, 就能维持$\epsilon-N$定义.</li>
<li>若发散数列改变有限项, 变为收敛数列, 则与上矛盾.</li>
</ul>
<h2 id="lim-limits-n-rightarrow-infty-a-n-a-epsilon-N-定义"><a href="#lim-limits-n-rightarrow-infty-a-n-a-epsilon-N-定义" class="headerlink" title="$\lim\limits_{n\rightarrow\infty} a_n=a$ $\epsilon-N$定义"></a>$\lim\limits_{n\rightarrow\infty} a_n=a$ $\epsilon-N$定义</h2><blockquote>
<p>$\forall \epsilon &gt;0, \exists N\in Z^*, 当n&gt;N时, 总有|a_n-a|&lt;\epsilon.$</p>
</blockquote>
<h2 id="常见数列极限"><a href="#常见数列极限" class="headerlink" title="常见数列极限"></a>常见数列极限</h2><ul>
<li>$\lim\limits_{n\rightarrow\infty} \sqrt[n]{n}=1$<ul>
<li>分析: 令$h_n=\sqrt[n]{n}-1&gt;0$, 难以直接由$h_n-0&lt;\epsilon$推算出$N$, 应当适当放大$h_n$. 变形得$n=(h_n+1)^n$, 应令右边缩小并抛弃n次方. 用二项式定理展开, 最终得到$h_n&lt;某个值$.</li>
<li>证明:<br>  令$h_n=\sqrt[n]{n}-1&gt;0$, 则<br>  $$n=(h_n+1)^n=1+nh_n+\frac{n(n-1)}{2}h_n^2+\cdots+h_n^n&gt;1+\frac{n(n-1)}{2}h_n^2$$<br>  $$\Rightarrow n&gt;1+\frac{n(n-1)}{2}h_n^2\Rightarrow h_n&lt;\sqrt{\frac{2}{n}}$$<br>  令$\sqrt{\frac{2}{n}}&lt;\epsilon$, 得$n&gt;\frac{2}{\epsilon^2}$<br>  $\therefore \forall \epsilon &gt;0, 取N&gt;\frac{2}{\epsilon^2}, 则当n&gt;N时,总有|\sqrt[n]{n}-1|&lt;\epsilon$.<br>  $\therefore \lim\limits_{n\rightarrow\infty} \sqrt[n]{n}=1$</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{k\frac{1}{n}} = 1(k&gt;0)$</li>
<li>$q^n \to 0(|q|&lt;1, n \to \infty)$<ul>
<li>分析: 若q=0... 若q!=0, 取n &gt; $[\frac{\ln \epsilon}{\ln |q|}]$.</li>
</ul>
</li>
<li>$\lim\limits_{n \to \infty} \sqrt[n]{a}=1$<ul>
<li>分析: 若a=1... 若a&gt;1, 强行$\log_a$. 若a&lt;1, 倒数.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \sqrt{n+1}-\sqrt{n} = 0$<ul>
<li>分析: 分子有理化后, 分母缩小(适当放大法).</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{1}{n^k} = 0(k&gt;0)$</li>
<li>$\lim\limits_{n\to \infty} \frac{n^k}{a^n} = 0$<ul>
<li>分析: 单调有界. 求一下$\lim\limits_{n\to\infty} \frac{x_{n+1}}{x_n}$. 证明收敛后对递推式两边求极限.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{a^n}{n!} = 0$</li>
<li>$\lim\limits_{n\to\infty} 分式: 观察最高次$</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{a_1^n+\cdots+a_m^n} = max(a_1,\cdots,a_m), a_i&gt;0$ 下文分析</li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^k = 1, k是任意常数$ 下文分析. <strong>这意味着不对接下来一个极限造成影响</strong></li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^n=e(e的一个定义)$ 收敛性在下文分析</li>
<li>$\lim\limits_{n\to\infty} \frac{1}{0!}+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\cdots + \frac{1}{n!} = e$ 夹逼准则, 课件1_2-3 22页</li>
</ul>
<h2 id="无穷大数列定义"><a href="#无穷大数列定义" class="headerlink" title="无穷大数列定义"></a>无穷大数列定义</h2><blockquote>
<p>$设数列a_n及常数a, 若\forall M &gt; 0, \exists N \in Z^+,当n&gt;N时, 总有|a_n| &gt;M, 则称数列{a_n}是无穷大数列, 或称{a_n}趋于无穷大, 记作$<br>$$\lim\limits_{n\to \infty}a_n=\infty或a_n \to \infty(n\to \infty)$$<br>$特别地, 有正无穷大数列和负无穷大数列, 记作.\lim\limits_{n\to \infty}a_n=+\infty或\lim\limits_{n\to \infty}a_n=-\infty$</p>
</blockquote>
<ul>
<li>无穷大数列是发散数列(极限不存在), 是无界数列</li>
<li>发散数列不一定是无穷大数列</li>
<li>无界数列不一定是无穷大数列</li>
</ul>
<h2 id="数列极限存在的准则"><a href="#数列极限存在的准则" class="headerlink" title="数列极限存在的准则"></a>数列极限存在的准则</h2><h3 id="夹逼定理"><a href="#夹逼定理" class="headerlink" title="夹逼定理"></a>夹逼定理</h3><ol>
<li>$\lim\limits_{n\to\infty}a_n=\lim\limits_{n\to\infty}b_n=a$</li>
<li>$a_n\leq c_n\leq b_n(n&gt;N_0)$</li>
<li>$\Rightarrow \lim\limits_{n\to\infty}c_n=a$</li>
</ol>
<ul>
<li>分析: 取$n&gt;max {N_0,N_1,N_2}$, 此时a_n, b_n都在邻域内, 所以夹着的c_n也在邻域内.</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$\lim\limits_{n\to\infty} n(\frac{1}{n^2+\pi}+\cdots+\frac{1}{n^2+n\pi})$<ul>
<li>分析: 分别放大缩小分母.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \sqrt[n]{a_1^n+\cdots+a_m^n} = max(a_1,\cdots,a_m), a_i&gt;0$<ul>
<li>分析: 常数在开无穷次方根时可以忽略, 因此只挑出最大的, 缩小系数为1, 放大系数为m即可.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty} \frac{1}{2}\frac{3}{4}\frac{5}{6}\cdots\frac{2n-1}{2n} = 0$<ul>
<li>分析: 大于零是显然的, 将分子平方再开方, 利用$1\cdot 3&lt;2^2$形式放大分子约分.</li>
</ul>
</li>
<li>$\lim\limits_{n\to\infty}(1+\frac{1}{n})^k = 1, k是任意常数$<ul>
<li>分析: k=0时显然. k为正整数时由有限项极限四则运算可得, k为负整数时倒数. 一般地, 另m=k向下取整, $(1+\frac{1}{n})^m \leq (1+\frac{1}{n})^k \leq (1+\frac{1}{n})^{m+1})$, 夹逼.</li>
</ul>
</li>
<li>已知$|a_{n+1}|\leq q|a_n|(n&gt;N, 0&lt;q&lt;1)$,证明数列极限为0.<ul>
<li>分析:$n\to\infty$,考虑第N+n项, 此时$0\leq|a_{N+n}|\leq q^{n-1}|a_{N+1}|\to 0$</li>
</ul>
</li>
</ul>
<h3 id="数列收敛充要条件-任一子数列都收敛且极限相等"><a href="#数列收敛充要条件-任一子数列都收敛且极限相等" class="headerlink" title="数列收敛充要条件: 任一子数列都收敛且极限相等"></a>数列收敛充要条件: 任一子数列都收敛且极限相等</h3><h4 id="子数列"><a href="#子数列" class="headerlink" title="子数列"></a>子数列</h4><ul>
<li>原数列中取无穷多项并按原有的次序排列.</li>
<li>一般约定$子数列n_k\geq k原数列$</li>
</ul>
<h4 id="充要证明"><a href="#充要证明" class="headerlink" title="充要证明"></a>充要证明</h4><ul>
<li>分析:<ul>
<li>充分性. 原数列n&gt;N时在邻域内, 则子数列取K使$n_K&gt;N$, 当k&gt;K时, $n_k&gt;n_K&gt;N$在邻域内.</li>
<li>必要性. 原数列是原数列的子数列.</li>
</ul>
</li>
</ul>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><blockquote>
<p>数列发散的充要条件是两个子数列极限存在但不相等, 或一个子数列发散.</p>
</blockquote>
<ul>
<li>设法构造易于证明的子数列. 常和三角函数周期性有关系.</li>
</ul>
<blockquote>
<p>若几个子数列的极限存在且相同, 包含的项的并集等于原数列的所有项, 则可得原数列的极限.</p>
</blockquote>
<ul>
<li>分析: 取N&gt;max{N1, N2, ...}, 任意项都在邻域内.</li>
</ul>
<h3 id="单调有界准则-单调有界数列必有极限"><a href="#单调有界准则-单调有界数列必有极限" class="headerlink" title="(单调有界准则)单调有界数列必有极限"></a>(单调有界准则)单调有界数列必有极限</h3><ul>
<li>区分严格单调和不严格单调.</li>
<li>统称单调数列.</li>
<li>分析: 由确界原理得待证极限a.</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>$数列:(1+\frac{1}{n})^n收敛$<ul>
<li>分析: 单调性.均值不等式$\sqrt[n+1]{(1+\frac{1}{n})^n\cdot 1}&lt;\frac{n(1+\frac{1}{n})+1}{n+1}=1+\frac{1}{n+1}$, 故$a_n&lt;a_{n+1}$. 有界性. 二项式展开, 各项放大剩分母阶乘, 阶乘放大到分母为2的幂, 等比求和.</li>
</ul>
</li>
<li>$\lim\limits_{n\to \infty} \frac{n^k}{a^n} = 0$<ul>
<li>分析: 单调有界. 求一下$\lim\limits_{n\to\infty} \frac{x_{n+1}}{x_n}$. 证明收敛后对递推式两边求极限.</li>
</ul>
</li>
</ul>
<h4 id="单调常用方法"><a href="#单调常用方法" class="headerlink" title="单调常用方法"></a>单调常用方法</h4><ul>
<li>递推式直接看出, 或求两边极限后看出</li>
<li>作差法/作商法, 结合上下界看出</li>
</ul>
<h4 id="有界常用方法"><a href="#有界常用方法" class="headerlink" title="有界常用方法"></a>有界常用方法</h4><ul>
<li>递推式放缩/均值不等式, 得到界</li>
<li>符号显然</li>
</ul>
<h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>余切 $\cot x = \frac{\cos x}{\sin x} = \frac{1}{\tan x}$</li>
<li>正割 $\sec x = \frac{1}{\cos x}$</li>
<li>余割 $\csc x = \frac{1}{\sin x}$</li>
</ul>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="弦和公式"><a href="#弦和公式" class="headerlink" title="弦和公式"></a>弦和公式</h3><ul>
<li>$\sin^2 x + \cos^2 x = 1$</li>
<li>$1 + \cot^2 x = \csc^2 x$</li>
<li>$\tan^2 x + 1 = \sec^2 x$</li>
</ul>
<h3 id="诱导公式"><a href="#诱导公式" class="headerlink" title="诱导公式"></a>诱导公式</h3><ul>
<li>半周期性<ul>
<li>$\sin(x+\pi) = -\sin(x)$</li>
<li>$\cos(x+\pi) = -\cos(x)$</li>
<li>$\tan x, \cot x最小正周期是\pi$</li>
</ul>
</li>
<li>奇偶性<ul>
<li>$\sin(-x) = -\sin(x) 奇函数$</li>
<li>$\cos(-x) = \cos(x) 偶函数$</li>
<li>$\tan(-x) = -\tan(x) 奇函数$</li>
<li>$\cot(-x) = -\cot(x) 奇函数$</li>
</ul>
</li>
<li>圆关于y轴对称性<ul>
<li>$\sin(\pi-x) = \sin(x)$</li>
<li>$\cos(\pi-x) = -\cos(x)$</li>
<li>$\tan, \cot的周期是\pi, 套用奇函数性质$</li>
</ul>
</li>
<li>直角加<ul>
<li>$\sin(\pi/2+x) = \cos x$</li>
<li>$\cos(\pi/2+x) = -\sin x$</li>
<li>$\tan(\pi/2+x) = -\cot x$</li>
<li>$\cot(\pi/2+x) = -\tan x$</li>
</ul>
</li>
<li>直角减(余角)<ul>
<li>$\sin(\pi/2-x) = \cos x$</li>
<li>$\cos(\pi/2-x) = \sin x$</li>
<li>$\tan(\pi/2-x) = \cot x$</li>
<li>$\cot(\pi/2-x) = \tan x$</li>
</ul>
</li>
<li>倍角公式<ul>
<li>$\sin2x = 2\sin x\cos x$</li>
<li>$\cos2x = \cos^2 x - \sin^2 x$</li>
<li>$\tan2x = \frac{2\tan x}{1-\tan^2x}$</li>
</ul>
</li>
<li>半角公式<ul>
<li>来源<br>$$ \cos 2x = 2 \cos^2 x-1 = 1-2\sin^2 x $$</li>
<li>$\cos^2 \frac{x}{2} = \frac{1+\cos x}{2}$</li>
<li>$\sin^2 \frac{x}{2} = \frac{1-\cos x}{2}$</li>
<li>$\tan \frac{x}{2} = \frac{\sin \frac{x}{2}}{\cos \frac{x}{2}}_{(同乘凑倍角)} =\frac{\sin x}{1+ \cos x} = \frac{1-\cos x}{\sin x}$</li>
</ul>
</li>
<li>万能公式<ul>
<li>$\sin x = \sin(2\frac{x}{2}) = 2\sin\frac{x}{2}\cos\frac{x}{2} = \frac{2\tan \frac{x}{2}}{\sec^2\frac{x}{2}}=\frac{2\tan \frac{x}{2}}{1+\tan^2 \frac{x}{2}}$</li>
<li>$\cos x = \sin(2\frac{x}{2}) = \cos^2\frac{x}{2} - \sin^2\frac{x}{2} = \frac{1-\tan^2\frac{x}{2}}{1+\tan^2\frac{x}{2}}$</li>
<li>$\tan x = \frac{2\tan\frac{x}{2}}{1-\tan^2\frac{x}{2}}$</li>
</ul>
</li>
<li>积化和差<ul>
<li>用$\sin(a \pm b)$凑$\sin\cdot \cos$</li>
<li>用$\cos(a \pm b)$凑$\sin \cdot\sin, \cos\cdot \cos.$</li>
<li>$\sin a \cos b = \frac{1}{2}(\sin(a+b)+\sin(a-b))$</li>
<li>$\cos a \sin b = \frac{1}{2}(\sin(a+b)-\sin(a-b))$</li>
<li>$\cos a \cos b = \frac{1}{2}(\cos(a+b)+\cos(a-b))$</li>
<li>$\sin a \sin b = -\frac{1}{2}(\cos(a+b)-\cos(a-b))$</li>
</ul>
</li>
<li>和差化积<ul>
<li>$a=\frac{a+b}{2}+\frac{a-b}{2}$</li>
<li>$b=\frac{a+b}{2}-\frac{a-b}{2}$</li>
<li>$\sin a + \sin b = 2\sin\frac{a+b}{2}\cos\frac{a-b}{2}$</li>
<li>$\sin a - \sin b = 2\cos\frac{a+b}{2}\sin\frac{a-b}{2}$</li>
<li>$\cos a + \cos b = 2\cos\frac{a+b}{2}\cos\frac{a-b}{2}$</li>
<li>$\cos a - \cos b = -2\sin\frac{a+b}{2}\sin\frac{a-b}{2}$</li>
<li>帅+帅=帅哥</li>
<li>帅-帅=哥帅</li>
<li>哥+哥=哥哥</li>
<li>哥-哥=负嫂嫂</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="无穷小量"><a href="#无穷小量" class="headerlink" title="无穷小量"></a>无穷小量</h2><ul>
<li>对任意eps&gt;0, 存在delta去心邻域, 使$|f(x)|&lt;eps$. 无穷小量是一个变量 </li>
<li>无穷小是极限为零的函数</li>
<li>无穷小可能在某邻域为0</li>
<li>0是唯一一个可视作无穷小的常熟</li>
</ul>
<h3 id="函数极限与无穷小量"><a href="#函数极限与无穷小量" class="headerlink" title="函数极限与无穷小量"></a>函数极限与无穷小量</h3><ul>
<li>（定理）$x \to x_0$,f(x)极限为A$\Leftrightarrow f(x)=A+a(x)$, a(x)为无穷小量</li>
</ul>
<h3 id="无穷小阶的比较"><a href="#无穷小阶的比较" class="headerlink" title="无穷小阶的比较"></a>无穷小阶的比较</h3><ul>
<li>$\lim\limits_{x \to x_0^+} \frac{f(x)}{(x-x_0)^k} = c \neq 0$,则当$x \to x_0$时,f(x)是$(x-x_0)$的k阶无穷小.</li>
<li>特殊的无穷小量<ul>
<li>$x \to 0, f(x),g(x)是无穷小量,且f(x)=(x+1)g(x), 则f(x) \sim g(x)$, 尽管他们最高次数不相同</li>
<li>最高次数不同而等价, 意味着相乘不改变等价性, 但相加会改变等价性.</li>
<li>具体例子:$f(x)=x^3-x \sim x^2-x, g(x)=x, f(x)+g(x)=x^3, 但x^2-x+x=x^2不等价于x^3$</li>
<li>同阶与否与最高次数无关, 一切判定以比值为准.</li>
</ul>
</li>
</ul>
<h3 id="常用的等价无穷小量"><a href="#常用的等价无穷小量" class="headerlink" title="常用的等价无穷小量"></a>常用的等价无穷小量</h3><h4 id="x-to-0-时"><a href="#x-to-0-时" class="headerlink" title="$x \to 0$时"></a>$x \to 0$时</h4><ul>
<li>$\sin x \sim x$</li>
<li>$\tan x \sim x$</li>
<li>$1 - \cos x \sim \frac{1}{2}x$</li>
<li>$\sqrt[n]{1+x}-1 \sim \frac{1}{n}x$ (n为正整数)(注意是加号)</li>
<li>$\arcsin x \sim x, (u=\arcsin x)$</li>
<li>$\arctan x \sim x$</li>
<li>$\ln(1+x) \sim x, (\lim \ln(1+x)^{\frac{1}{x}})$</li>
<li>$e^x-1 \sim x, (u=e^x-1, \lim \frac{u}{\ln(1+u)})$</li>
<li>$a^x-1 \sim x\ln a, (\lim \frac{e^{x\ln a}-1}{x}=\lim \frac{x\ln a}{x} = \ln a), a &gt; 0$</li>
<li>$(1+x)^a-1 \sim ax, (\lim \frac{(1+x)^a-1}{x}=\lim \frac{e^{a \ln (1+x)}-1}{x} = \lim \frac{a \ln (1+x)}{x} = a), a \neq 0$</li>
<li>x可以用其他函数替代，只要趋向于0即可</li>
</ul>
<h3 id="常用变换"><a href="#常用变换" class="headerlink" title="常用变换"></a>常用变换</h3><ul>
<li>$\lim \limits_{x \to 0} (1-x)^{\frac {1}{x}} = \frac{1}{e}$</li>
<li>$\sin x + x^2=x(\frac{\sin x}{x} + x)$</li>
<li>$\tan x - \sin x = \tan x(1- \cos x)$</li>
<li>$a^x = e^{x \ln a}$ (留意后面有没有-1配合等价无穷小替换)</li>
<li>$x^a = e^{a \ln x}$</li>
<li>在$x \to \infty, 求\lim e^{f(x)g(x)}, 留意最高次相同\Rightarrow 系数比$</li>
<li>$\lim \limits_{n \to \infty} (\frac{\sqrt[n]{a_1}+\cdots +\sqrt[n]{a_m}}{m}-1)n = \lim \limits_{x \to 0} (\frac{a_1^x+\cdots + a_m^x}{m}-1)\frac{1}{x} = \lim \limits_{x \to 0} \frac{x\ln a_1 + \cdots + x\ln a_m}{mx} = \ln \sqrt[m]{a_1 \cdots a_m}, m是正整数, 归结准则$</li>
<li>次方相同, 底数不同,强行同除?!<blockquote>
<p>求$\lim \limits_{x \to 0} \frac{(1+x)^\frac{1}{x}+(1+2x)^\frac{1}{2x}}{\sin x} = \frac{e}{2}$</p>
</blockquote>
</li>
<li>求极限的最后, 有界量(尤其与$\sin\infty$,$\cos \infty$有关)乘无穷小量等于无穷小量</li>
</ul>
<h3 id="无穷小量阶数的性质"><a href="#无穷小量阶数的性质" class="headerlink" title="无穷小量阶数的性质"></a>无穷小量阶数的性质</h3><ul>
<li>$o(x^n)+o(x^m) = o(x^m), x \to 0, n&gt;m&gt;0$</li>
<li>$o(x^n) \cdot o(x^m) = o(x^{n+m}), x \to 0$</li>
<li>无穷小量相加，高阶丢失，保留低阶.</li>
<li>无穷小量相乘，阶数相加.</li>
<li>无穷小量$o(高阶)=o(低阶)$是正确的.</li>
<li>无穷小量可以写成$f(x)=g(x)+o(x^2)$, 求极限时设法出现$\frac {o(x^2)}{kx^2}$即可消去</li>
</ul>
<h2 id="证明题"><a href="#证明题" class="headerlink" title="证明题"></a>证明题</h2><ul>
<li>证明$x \to 0, f(x) = g(x)+o(h(x))$<blockquote>
<p>计算$\lim\limits_{x \to 0}\frac{f(x)-g(x)}{h(x)} = 0$</p>
</blockquote>
</li>
<li>证明函数是无穷小量<blockquote>
<p>证明函数极限为0</p>
</blockquote>
</li>
<li>证明函数是无节量<blockquote>
<p>对任意M&gt;0,找到$|f(x)| &gt; M$</p>
</blockquote>
</li>
</ul>
<h2 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h2><ul>
<li>对任意M&gt;0，存在空心邻域(x0, $\delta$), 使$|f(x)| &gt;M$, 则f(x)是在$x \to x0$时的无穷大量</li>
<li>无穷大量不是一个很大的数</li>
<li>无穷大量的极限不存在</li>
</ul>
<h3 id="无穷大量与无穷小量的关系"><a href="#无穷大量与无穷小量的关系" class="headerlink" title="无穷大量与无穷小量的关系"></a>无穷大量与无穷小量的关系</h3><ul>
<li>无穷大量的倒数量是无穷小量</li>
<li>若无穷小量恒不为零,则该无穷小量的倒数量为无穷大量</li>
</ul>
<h2 id="等价量"><a href="#等价量" class="headerlink" title="等价量"></a>等价量</h2><ul>
<li>不论无穷大或无穷小, 只要$\lim\limits_{x \to x_0} \frac{f(x)}{g(x)}=1$, 就称$当x \to x_0时,f(x)与g(x)是等价的量, 记作f(x) \sim g(x), (x \to x_0)$</li>
<li>g(x)可以是不为零的常数.故可以有$f(x)~A, (A \neq 0)$</li>
<li>函数等价于零无意义</li>
<li>极限相等是等价的非必要非充分条件(可能两函数的极限都不存在, 另外还需要同阶)</li>
</ul>
<h3 id="等价量替换定理"><a href="#等价量替换定理" class="headerlink" title="等价量替换定理"></a>等价量替换定理</h3><ul>
<li>若函数分别等价,且$\lim \frac{f&#39;(x)g&#39;(x)}{h&#39;(x)}=A$, 则$\lim \frac{f(x)g(x)}{h(x)} = \lim \frac{f&#39;(x)g&#39;(x)}{h&#39;(x)}=A$<ul>
<li>两项相加不能直接使用等价量替换</li>
<li>可以使用$\lim f(x)+g(x) = \lim f(x) + \lim g(x) = \lim f&#39;(x) + \lim g&#39;(x) = \lim f&#39;(x)+g&#39;(x)$, 这里要求各函数极限都存在.</li>
<li>常用极限值(常数)可以代入, 但不保证顺利计算出极限.</li>
</ul>
</li>
</ul>
<h2 id="给函数极限-求参数"><a href="#给函数极限-求参数" class="headerlink" title="给函数极限, 求参数"></a>给函数极限, 求参数</h2><ul>
<li>求等价量,确定参数</li>
<li>直接移项得出$常数=\lim g(x)=A$</li>
</ul>
<h1 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>设$y=f(x)$在$x$的某邻域$U(x)$内有定义，若$\Delta y = f(x+ \Delta x)-f(x)$可表示为<br>$$<br>   \Delta y = A\Delta x + o(\Delta x) \quad (\Delta \rightarrow 0),<br>$$<br>其中$A$是与$\Delta x$无关的量，则称$y=f(x)$在点$x$处可微. $A\Delta x$是$\Delta y$的线性主部，并称其为$y=f(x)$在点$x$处的微分，记为$dy, dy = A\Delta x$。</p>
</blockquote>
<p>[toc]</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2019/08/20/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="求-L-R-中满足-y-geq-x-且y-mod-x-x-oplus-y-的数对-x-y-的个数"><a href="#求-L-R-中满足-y-geq-x-且y-mod-x-x-oplus-y-的数对-x-y-的个数" class="headerlink" title="求$[L,R]$中满足$y\geq x,且y\mod x=x\oplus y$的数对$(x,y)$的个数"></a>求$[L,R]$中满足$y\geq x,且y\mod x=x\oplus y$的数对$(x,y)$的个数</h2><span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>题目涉及位操作，对所有数以二进制看待。x和y的最高位应相同，这是因为$y\mod x&lt;x$，其二进制最高位有限制。</li>
<li>两数最高位相同，则y不超过x的两倍。$y\mod x = y-x = y\oplus x$。</li>
<li>$y-x$不可能退位。由$y\geq x$找到两者不同的最高位（y一定是1，x一定是0），这一位异或和为1，若低位退位，则差为0，矛盾，故低位不能退位。由低位不能退位，分类讨论$1-0, 1-1, 0-0$三种情况，发现更低位也不能退位，由归纳法可知$y-x$不可能退位。</li>
<li>综上，以bitset看待，$x\subseteq y$。</li>
<li>考虑记忆化搜索。$x,y$都受到上下界限制，且$y\geq x$，故分别dp枚举$x,y$的合法取值。另外要记录状态保证$x,y$的最高位相同。</li>
</ol>
<p>$$<br>设f[pos][xDown][xUp][yUp][lead]\<br>表示第pos位之后，x是否压下界，x是否压上界，y是否压上界，xy是否取过最高位时的合法方案数<br>$$</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ULL <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">bool</span> xDown<span class="token punctuation">,</span> <span class="token keyword">bool</span> xUp<span class="token punctuation">,</span> <span class="token keyword">bool</span> yUp<span class="token punctuation">,</span> <span class="token keyword">bool</span> lead<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	ULL <span class="token operator">&amp;</span>res <span class="token operator">=</span> ans<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>xDown<span class="token punctuation">]</span><span class="token punctuation">[</span>xUp<span class="token punctuation">]</span><span class="token punctuation">[</span>yUp<span class="token punctuation">]</span><span class="token punctuation">[</span>lead<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token keyword">int</span> xLow <span class="token operator">=</span> xDown <span class="token operator">?</span> L<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> xHigh <span class="token operator">=</span> xUp <span class="token operator">?</span> R<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> yHigh <span class="token operator">=</span> yUp <span class="token operator">?</span> R<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>xLow<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>xHigh<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>yHigh<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>lead <span class="token operator">&amp;&amp;</span> i<span class="token operator">!=</span>j<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
			res <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> xDown<span class="token operator">&amp;&amp;</span>i<span class="token operator">==</span>xLow<span class="token punctuation">,</span> xUp<span class="token operator">&amp;&amp;</span>i<span class="token operator">==</span>xHigh<span class="token punctuation">,</span> yUp<span class="token operator">&amp;&amp;</span>j<span class="token operator">==</span>yHigh<span class="token punctuation">,</span> lead<span class="token operator">&amp;&amp;</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>res <span class="token operator">%=</span> MOD<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化DP</title>
    <url>/2019/08/25/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="单状态的斜率优化"><a href="#单状态的斜率优化" class="headerlink" title="单状态的斜率优化"></a>单状态的斜率优化</h2><p>写出状态转移方程，形如：<br>$$ f[j]=\max_{i=1}^{j-1} { F_1(j)+F_2(i)+F_3(i,j)} $$<br>由于$F_3$涉及i和j，若枚举两个变量会超时。</p>
<p>化简方程，得到</p>
<span id="more"></span>
<p>$$ f[j]=\max_{i=1}^{j-1} {F_2(i)+F_4(j)*F_5(i) } + const(j) $$</p>
<p>这里涉及的每个函数都能事先算出。于是求最大值转化为线性规划：将$f[j]$看作b，$F_2(i)$看作y，$-F_4(j)$看作k，$F_5(i)$看作x，则形式可转化为$b=y-kx$，求b的最大值。维护可能的点队列，则这是一条上凸线，用二分找到最相近斜率的线段的对应点即可。</p>
<p>某些题目的$F_4(j)$具有单调性，即目标直线的斜率有单调性，则可用朴素单调队列代替二分。</p>
<p>也可以将max改成min，这时求最小的b，维护下凸线即可。</p>
<h2 id="双状态的斜率优化"><a href="#双状态的斜率优化" class="headerlink" title="双状态的斜率优化"></a>双状态的斜率优化</h2><p>拓展单状态下的方程，形如：<br>$$ f(j,k]=\max_{i=1}^{j} { F_1(j,k]+F_2(i,j]+F_3(i,j,k)} $$<br>同样化简方程，得到<br>$$ f(j,k]=\max_{i=1}^{j} { F_2(i,j]+F_4(i)*F_5(j,k]} + const(j,k]$$<br>类似地令$F_4(i)$为横坐标x，待求的$f(j,k]$看作截距b，$F_2(i,j]$看作纵坐标y构建线性规划。之后的步骤同上。</p>
<p>斜率优化的目的是减少枚举前驱状态的时间，用O(1)或O(log n)完成状态转移。这将要求在完成状态计算后，将新获得的点加入凸线中。加点后，视情况选择是否维护凸性。<br>对于双状态的题目，不同的j对应不同的凸线（这是因为$F_2(i,j]$会随j变化，即点的坐标会变化）。应当判断对于同一个j、不同的k，能否从同一条凸线得到答案。</p>
<p>如果加点操作的横坐标具有非单调性，可能需要数据结构支持二分查找、中间加点、中间删点的操作。如果不需要即时维护，可以用排序完成维护。</p>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-分治最小割</title>
    <url>/2016/04/27/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E5%88%86%E6%B2%BB%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    <content><![CDATA[<p>对于询问网络图中每个点对的最大流（最小割容量），总是可以将图简化成n个点n-1条边的树型图，边上标有一些容量，使得在树上询问每个点对的最大流等价于原问题。</p>
<span id="more"></span>

<p>上文提到的树叫作Gomory–Hu tree，其构造方法是：</p>
<ol>
<li>将所有点的放在一个集合中。</li>
<li>选一个元素个数至少为2的集合（不妨设其为集合R）中任取两个点作为原图的源点和汇点，跑一次最大流，就会将原图上的所有点分割为两部分，要么与S联通，要么与T联通。</li>
<li>在残余图中，对于每个节点v∈R，若v与S联通，则v留在集合R，否则将v移除并放置于新集合R&#39;中。在Gomory–Hu tree中，有边(R,R&#39;)，边权（容量）是2.中最大流的值。</li>
<li>还原原网络图，重复2，3，4至所有集合有且仅有一个元素。此时Gomory–Hu tree建图完毕。</li>
</ol>
<p>询问网络图中每个点对的最大流，等价于询问Gomory–Hu tree上对应点路径边权的最小值，可以用树链剖分维护。</p>
<h1 id="bzoj4519-不同的最小割"><a href="#bzoj4519-不同的最小割" class="headerlink" title="bzoj4519 不同的最小割"></a>bzoj4519 不同的最小割</h1><h2 id="cuts"><a href="#cuts" class="headerlink" title="cuts"></a>cuts</h2><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成<br>两个部分，如果结点 s,t 不在同一个部分中，则称这个划分是关于 s,t 的割。对于带权图来说，将<br>所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 s,t 的最小割指的是在<br>关于 s,t 的割中容量最小的割。<br>而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把<br>视野放宽，考虑有 N 个点的无向连通图中所有点对的最小割的容量，共能得到 N ( N ? 1)<br>2 个数值。<br>这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件第一行包含两个数 N， M，表示点数和边数。接下来 M 行，每行三个数 u， v， w，表示<br>点 u 和点 v（从 1 开始标号）之间有条边权值是 w。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件第一行为一个整数，表示个数。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>4 4<br>1 2 3<br>1 3 6<br>2 4 5<br>3 4 4</p>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3</p>
<h4 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h4><p>? 对于 50% 的数据， N ≤ 200， M ≤ 2000<br>? 对于 100% 的数据， 1 ≤ N ≤ 850， 1 ≤ M ≤ 8500， 1 ≤ w ≤ 100000</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">860</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">8510</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">29</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>

<span class="token keyword">int</span> to<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> nex<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> mcap<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> cap<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pn<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> tmppn<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> q<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> qh<span class="token punctuation">,</span> qt<span class="token punctuation">,</span> flag<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> fa<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> FLOW<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> cntf<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	qh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> qt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	flag<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>qh <span class="token operator">&lt;</span> qt<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>qh<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>index<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> cap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				flag<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
				q<span class="token punctuation">[</span>qt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> flag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">Dinic</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> depth<span class="token punctuation">;</span>
	<span class="token keyword">int</span> flow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">bfs</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		fa<span class="token punctuation">[</span>depth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;</span> depth<span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> minc <span class="token operator">=</span> INF<span class="token punctuation">,</span> mink<span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>depth<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
				<span class="token punctuation">&#123;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cap<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> minc<span class="token punctuation">)</span>
					<span class="token punctuation">&#123;</span>
						minc <span class="token operator">=</span> cap<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
						mink <span class="token operator">=</span> i<span class="token punctuation">;</span>
					<span class="token punctuation">&#125;</span>
				<span class="token punctuation">&#125;</span>
				flow <span class="token operator">+=</span> minc<span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>depth<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
				<span class="token punctuation">&#123;</span>
					cap<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> minc<span class="token punctuation">;</span>
					cap<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span> minc<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				
				depth <span class="token operator">=</span> mink<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">bool</span> alive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>index<span class="token punctuation">[</span>fa<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span>fa<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>flag<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> cap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#123;</span>
					path<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
					fa<span class="token punctuation">[</span><span class="token operator">++</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
					alive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>alive<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> flag<span class="token punctuation">[</span>fa<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>depth<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	FLOW<span class="token punctuation">[</span>cntf<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> flow<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span>cap<span class="token punctuation">,</span> mcap<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Dinic</span><span class="token punctuation">(</span>pn<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> pn<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> lpart <span class="token operator">=</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rpart <span class="token operator">=</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span>pn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
			tmppn<span class="token punctuation">[</span><span class="token operator">++</span>lpart<span class="token punctuation">]</span> <span class="token operator">=</span> pn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			tmppn<span class="token punctuation">[</span><span class="token operator">--</span>rpart<span class="token punctuation">]</span> <span class="token operator">=</span> pn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		pn<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmppn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> lpart<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span>rpart<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"cuts.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"cuts.out"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ri</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">ri</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">ri</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">addEdge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">addEdge</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//		assert(cur &lt; 8500*4);</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> pn<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">sort</span><span class="token punctuation">(</span>FLOW<span class="token punctuation">,</span> FLOW<span class="token operator">+</span>cntf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cntf<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>FLOW<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>FLOW<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>ans<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> mcap<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> index<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> mcap<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span> index<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token string">'0'</span> <span class="token operator">||</span> <span class="token string">'9'</span><span class="token operator">&lt;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> c<span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> c<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>x <span class="token operator">+</span> c<span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>
<span class="token comment">//	cerr &lt;&lt; x &lt;&lt; endl;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>朝花夕拾</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-树形结构区分</title>
    <url>/2016/06/15/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%8C%BA%E5%88%86/</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><ul>
<li>每个结点有随机的优先级，使树满足优先级树（堆）的性质，其余是普通排序二叉树</li>
<li>旋转：<ul>
<li><strong>参数是子树根(引用子树根的儿子指针，否则要改一系列父子指针)</strong> ，旋转 即是 <strong>沉降</strong>，另一边的孩子上升，但该孩子可能丢失一个子树。</li>
<li><strong>引用原子树根</strong>可方便修改父亲指向自己的指针。</li>
<li>总是<strong>因为查找才会引发旋转</strong>，所以旋转参数总是引用。</li>
<li>没有返回值，因为新子树根就是父亲的儿子指针。</li>
<li>记得维护其他数据域。</li>
</ul>
</li>
<li>插入：<ul>
<li><strong>自带查找</strong></li>
<li>新结点分配随机优先级，像排序二叉树一样<strong>插到一个叶子</strong>上（每个结点有计数器，可节省插入相同结点），然后旋转维护优先级树。</li>
<li>递归地写，<strong>insert()后判断</strong>一下是否需要leftRotate() / rightRotate()。</li>
</ul>
</li>
<li>删除：<ul>
<li><strong>自带查找</strong></li>
<li>找到待删除结点，<strong>修改计数器（当且仅当计数器大于1！）</strong>。如果计数器就是1，就要将自己旋到外结点（没有儿子或有一个儿子），轻松自杀。</li>
<li><strong>引用root</strong>可以方便删掉父亲指向自己的指针。</li>
<li>另一种删除方法：参考普通排序二叉树的删除，但优先级不能被拷贝。非递归地写能优化时间。</li>
</ul>
</li>
<li>查找：<ul>
<li>和一般的二叉排序树一样。</li>
<li>返回值可以写成<strong>地址引用？</strong></li>
</ul>
</li>
<li>分离：<ul>
<li>依赖于size，将树分离为两个指定大小的树。</li>
<li>先找到割边，强行加入一个虚拟结点（优先级为无限大），旋转到根，这时左右子树已经被分离。</li>
</ul>
</li>
<li>合并：<ul>
<li>合并和分离相反。要求其中一棵treap的所有结点小于另一棵。</li>
<li>强行加入一个虚拟结点作为根（优先级为无限小），连接两棵treap，然后删除虚拟结点。</li>
</ul>
</li>
</ul>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><ul>
<li>拥有将某一个结点旋转到根的操作Splay(&amp;root, const x)，并在大多数操作中主动调用splay()</li>
<li>新建结点newNode(const v, const father = 0)<ul>
<li>返回地址</li>
</ul>
</li>
<li>旋转：<ul>
<li>因为splay()旋转涉及很多代结点，不能用引用简化代码，必须存父亲指针。对应的孩子指针、父亲指针必须成对修改。</li>
<li><strong>参数是被旋转子树根的孩子</strong>，先处理祖先的孩子指针，再处理孩子的父亲指针，最后处理被旋转的两个结点的指针。“上有老 下有小 求放过...”</li>
<li>可能会导致<strong>splay树根的改变</strong>，但是只有splay()导致旋转，splay()中自带根的记录。</li>
<li>没有返回值，因为地址对应的内容没有变。</li>
</ul>
</li>
<li>Splay(&amp;root, const x)：<ul>
<li>参数root是splay树根，x是结点地址。<strong>root必须引用</strong>，因为splay操作会更改树根。</li>
<li><strong>所有包含splay()的函数</strong>都要引用root</li>
<li>依赖于祖先两代。若x仅有父亲而没有祖父，相应地旋转就好了。<strong>如果x有祖父，而且三点“共线”，就要先旋转父亲</strong>，后旋转x；如果三点不“共线”，正常地做就好。</li>
</ul>
</li>
<li>插入(&amp;root, const v)<ul>
<li><strong>自带查找</strong></li>
<li>先判根，然后开始循环</li>
<li>保存父亲y，引用孩子x，若x==0 则 x=newNode</li>
<li>因为插入包含了splay()，所以要带引用root。</li>
</ul>
</li>
<li>删除(&amp;root, const v)：<ul>
<li><strong>自带查找</strong></li>
<li>因为删除包含了splay()，所以要带<strong>引用root</strong>。</li>
<li>如果被删结点是<strong>外结点</strong>，轻松自杀，splay()替身或者splay()父亲。</li>
<li>如果被删结点不是外结点，那么被删结点肯定有前驱和后继<strong>在子树上</strong>，任取一个代替自己，然后splay()自己</li>
</ul>
</li>
<li>前驱后继(&amp;root const v) / (&amp;root const x)<ul>
<li><strong>将x旋到根</strong>，前驱就是左子树的最右结点，后继就是右子树的最左结点。</li>
<li>因为包含了splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li>有序合并join(&amp;s1, s2)：<ul>
<li>将s1的最大元素splay到根，然后将s2设为s1的右子树</li>
<li>因为含有splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li>无序合并Merge(s1, s2)：<ul>
<li><strong>依赖于额外数据域size</strong></li>
<li>遍历size小的splay树，逐个插入到另一颗splay树上</li>
</ul>
</li>
<li>划分split(&amp;root, const v)<ul>
<li><strong>自带查找</strong></li>
<li>将关键字为v的结点splay到根，左右子树分开即可。</li>
<li>因为含有splay()，所以要带<strong>引用root</strong>。</li>
</ul>
</li>
<li><strong>splay树应用区间操作</strong><ul>
<li><strong>关键字将是下标，或者没有关键字</strong>。在一些下标可能集体移动的场合，宜不设关键字。</li>
<li><strong>结点记录子树的总体信息</strong>，类似线段树，可包含延迟标记。</li>
<li>对区间[a,b]操作：将a-1旋到根，切掉右子树(b+1在其中)，再将b+1旋转到根，重新连接两棵树。这时<strong>b+1的左子树就是[a,b]</strong> 。</li>
<li>在[a,a+1]中间插入一些数：将被插入的数构建成splay树。将a旋到根，a+1旋到根的右孩子。将新建的splay树挂成a+1的左孩子。</li>
<li>重要的事情说n遍也不嫌多：小心root被更改。具体地说就是splay()要换根，只有splay()才能使用旋转。</li>
</ul>
</li>
</ul>
<h2 id="普通排序二叉树"><a href="#普通排序二叉树" class="headerlink" title="普通排序二叉树"></a>普通排序二叉树</h2><ul>
<li>重点是前驱和后继</li>
<li>前驱(const v)<ul>
<li><strong>必须自带查找</strong></li>
<li>在查找成功之前，<strong>记录最后一个往右走的结点</strong>，因为它可能是前驱</li>
<li>查找成功之后，如果结点有左子树，那么左子树的最大结点一定是前驱</li>
<li>如果一个结点是整棵树的最左（最小）结点，那么它没有前驱。</li>
</ul>
</li>
<li>后继(const v)<ul>
<li>同前驱</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-桥与强连通分量</title>
    <url>/2015/11/06/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE-%E6%A1%A5%E4%B8%8E%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</url>
    <content><![CDATA[<p>[toc]</p>
<span id="more"></span>

<h1 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h1><ul>
<li>桥是在无向图中不在环上的边.</li>
<li>如果隔断桥，无向图将被分为两个不连通的子图.</li>
</ul>
<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><ul>
<li>如果删去一个点, 余下的点不连通, 则这个点是割点.</li>
<li>割点不依赖桥, 桥上也不一定存在割点.</li>
</ul>
<h1 id="如何找桥和割点"><a href="#如何找桥和割点" class="headerlink" title="如何找桥和割点"></a>如何找桥和割点</h1><ol>
<li>任选图上一点为根, dfs.<ul>
<li>记录每个节点首次被访问的次序, 记作dfn[x].</li>
<li>记录每个节点能连接或通过子节点连接到的最早节点的dfn, 且不能沿父亲边, 记作low[x].</li>
<li>dfs(x)将返回low[x].</li>
</ul>
</li>
<li>在每个dfs中, 设当前节点为x, 枚举边连到y.<ul>
<li>如果dfn[y]未定义, 则y是x在搜索树上的儿子. low[x] = min(low[x], dfs(y)).</li>
<li>如果y == fa[x], 则y是x在搜索树上的父亲, 不管此y</li>
<li>若dfn[y]有定义且y!=fa[x], 则y即是x通过非父子边连到的节点, 尝试用dfn[y]更新low[x].</li>
</ul>
</li>
<li>利用桥和割点的性质判定.</li>
</ol>
<h2 id="性质-依据"><a href="#性质-依据" class="headerlink" title="性质/依据"></a>性质/依据</h2><h3 id="沿x的边找其他节点y"><a href="#沿x的边找其他节点y" class="headerlink" title="沿x的边找其他节点y."></a>沿x的边找其他节点y.</h3><ol>
<li>dfn[y]有定义 &lt;==&gt; y是x在搜索树中的祖先<ul>
<li>充分性是显然的.</li>
<li>必要性: 若y不是祖先, 则y是兄弟或祖先的兄弟. 又因为dfn[y]有定义, 所以y一定完成了dfs的过程, 但x和y连接的边却没有处理, 矛盾.</li>
<li>尝试用dfn[y]更新low[x], 而不是用low[y]. (使回溯边不经过祖先点). 这样能保持算法的正确性. 否则因为回溯边经过割点在找割点时产生错误.</li>
</ul>
</li>
<li>若y是x在搜索树上的非第一个儿子:<ul>
<li>若x是根, 则y与之前的儿子以x为割点.</li>
<li>若x不是根, 则y与之前的儿子可能经过x的祖先联通.<ul>
<li>如果验证y与x的祖先不连通, 则x是两者的割点.</li>
<li>如果验证y与x的祖先不连通, 则x是y与其他儿子的割点(否则y已经被访问过, 不会是x的儿子.)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="桥的性质"><a href="#桥的性质" class="headerlink" title="桥的性质"></a>桥的性质</h3><ol>
<li>桥是一条边, 连接着在搜索树中的父亲和儿子/祖先和儿子</li>
<li>设一条边连接着祖先节点u, 儿子节点v, 若dfn[u]&lt;low[v], 则若边删除, 祖先儿子无法连通, 即此边是桥. 反之亦然: 边(u, v)是桥 &lt;==&gt; dfn[u]&lt;low[v] (u是v的祖先)</li>
</ol>
<h3 id="割点的性质"><a href="#割点的性质" class="headerlink" title="割点的性质"></a>割点的性质</h3><ol>
<li>割点是一个点, 它要么是根节点, 要么有一个父亲节点.</li>
<li>对于根节点, 若搜索树上根节点有多余一个儿子, 则任意两对儿子以根节点为割点.</li>
<li>对于非根节点, 设为u, 其父亲为fa, 儿子v(i), 若dfn[u] &lt;= low[v], 则若u删除, fa/v不连通, 即u是割点;  特别地, dfn[u] &lt;= low[v1], 则v1与v2, v3....都以fa为割点.</li>
</ol>
<p>找桥：用dfs遍历图，记录结点访问次序；当某个结点有一条边通往已被访问过的结点时，代表找到了环；不在环上的边就是桥。</p>
<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><p>在有向图中两个顶点Vi，Vj之间有一条从Vi到Vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量（百度百科）</p>
<p>Kosaraju算法:</p>
<p>1、深搜遍历原图G图，记录每个结点离开时间（后序遍历）；</p>
<p>2、选择具有最晚离开时间的顶点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量。</p>
<p>3、如果还有点没有被删除，重复2，否则算法结束</p>
<p>Kosaraju算法性质：如果将求出来的强连通分量收缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的结点，那么这个顺序其实就是强连通分量收缩成点后形成的有向无环图的拓扑序列。</p>
]]></content>
      <tags>
        <tag>朝花夕拾</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾-树链剖分</title>
    <url>/2016/04/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>树链剖分的名字非常高大上， 其实不难， 本质是将树分解成几条链， 映射在线段树（树状数组、Splay等）上， 当我们需要在树上的路径（题目通常给定两个结点，在他们的路径上操作）进行操作时， 就能转化成在线段树（等数据结构）上进行操作， 接下来以树转线段树为例。</p>
<span id="more"></span>

<p>树链剖分最重要的地方在于分解树的规则， 下面是一种通用的分解方法：对于每个结点，如果它有儿子，那么取其子树最重（子树结点最多）的儿子为“重儿子”， 重儿子与其父亲的连边称为“重边”。相对的，其余的儿子成为“轻儿子”，轻儿子与父亲的连边称为轻边 。连续的重边构成“重链”，在同一条重链上的点 在线段树中 按重链的顺序相邻。显然，非叶子结点都有重儿子， 它们必定能映射到唯一的重链上。对于多个同父亲的叶子结点，随便取一个作为重儿子就可以了。可以想象， 轻边连接着不相交的重链，树上的每个结点都能唯一的映射到线段的某一个点上。</p>
<p><img src="./%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E4%BE%8B%E5%AD%90.png" alt="树链剖分例子"></p>
<p>这样一来，一些数据结构就能够推广到树上。比如能求区间最值、区间求和的线段树，在映射做好后，就能套用在树上。<br>假如我们要求树上两点(u,v)之间的路径的权值和。例如上图求(11, 14)间路径权值和，分别从11和14往上跳，跳到重链的顶端，（为了不超过两点的最近公共祖先， 要选择更深的重链头跳），11跳到2，用线段树求出(2,11)的和（利用重链在映射线段上连续的特点），暴力加一下轻边(1,2)，此时两方面同时跳到重链头1，用线段树求出(1,14)的和，得到答案。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="主要数据"><a href="#主要数据" class="headerlink" title="主要数据"></a>主要数据</h2><ol>
<li>树<ul>
<li>这部分是由题目给出的数据</li>
<li>题目要求在树上的路径做段修改, 段询问.</li>
<li>如果树很大, 输入代价可能也很大, 应该考虑自定义输入. 字符串输入用scanf.</li>
</ul>
</li>
<li>高级树形数据结构<ul>
<li>能够满足题目要求的修改, 询问操作.</li>
<li>基础数据来自一段预处理序列, 而不是直接来自输入.</li>
</ul>
</li>
<li>输入树到自定义数据结构的映射<ul>
<li>简称树链剖分.</li>
<li>将输入树剪成若干条链, 作为高级数据结构的基础数据.</li>
</ul>
</li>
</ol>
<h2 id="剖分方法"><a href="#剖分方法" class="headerlink" title="剖分方法"></a>剖分方法</h2><p>在生成映射的过程中, 对于原树的每个节点, 有六个信息要处理.</p>
<ol>
<li>父亲节点 - 防止重复搜索</li>
<li>节点深度 - 防止越过最近公共祖先</li>
<li>子树大小 - 决定重儿子</li>
<li>重儿子 - 构成重链</li>
<li>链上编号 - 映射到序列</li>
<li>重链头 - 找到编号连续的段</li>
</ol>
<ul>
<li>1,2,5,6是自顶向下计算的, 3,4必须自底向上计算.</li>
<li>bfs计算1,2. 反向bfs计算3,4.</li>
<li>模拟栈(#define成队列数组)计算5,6. 为了保证重链编号连续, 重儿子后入栈.</li>
<li>如果值在边上, 将值放进子节点中. 询问时注意轻边的纳入.</li>
</ul>
<h2 id="映射询问"><a href="#映射询问" class="headerlink" title="映射询问"></a>映射询问</h2><ul>
<li>如果两点所在重链的重链头不同, 意味着两点不在同一条重链. 为了防止一条重链头已经越过最近公共祖先, 选择重链头深度大的计算. 询问映射段, 把轻边也算在内(轻边信息放在了重链头节点中). 计算后节点换成重链头的父亲.</li>
<li>如果两节点在同一条重链上, 首先把深度安排好, 特判两节点是否相同. 如果询问边, 这时候的计算与轻边无关, 注意把浅节点编号加一.</li>
</ul>
<h3 id="关于线段树延迟标记"><a href="#关于线段树延迟标记" class="headerlink" title="关于线段树延迟标记"></a>关于线段树延迟标记</h3><ul>
<li>pushDown意味着当前段有多余, 要分两半, 但不一定两半都继续递归. <strong>所以递归后两半都可能带有延迟标记</strong>. </li>
<li>pushUp在修改操作中出现, 且前面必有pushDown, 意味着当前段的延迟操作已经补好. pushUp结束后<strong>当前段一定不带延迟标记</strong>.</li>
</ul>
<p>求路径最值也如法炮制。<br>下面给出实现树上路径求最值、求和的代码，题目对应HYSBZ 1036。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">mmst</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">lson</span> <span class="token expression"><span class="token punctuation">(</span>root<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rson</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">30010</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXE <span class="token operator">=</span> MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> q<span class="token punctuation">;</span>

<span class="token keyword">int</span> to<span class="token punctuation">[</span>MAXE<span class="token punctuation">]</span><span class="token punctuation">,</span> nex<span class="token punctuation">[</span>MAXE<span class="token punctuation">]</span><span class="token punctuation">,</span> Mindex<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> w<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> top<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> fa<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> son<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> siz<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> depth<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> SUM<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> MAX<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	son<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	siz<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>Mindex<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			fa<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
			depth<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>siz<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> siz<span class="token punctuation">[</span>son<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> son<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			siz<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> siz<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">set_tree</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> tp<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	top<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tp<span class="token punctuation">;</span>
	w<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">set_tree</span><span class="token punctuation">(</span>son<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>Mindex<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>son<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">set_tree</span><span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> val<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token function">update</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">,</span> val<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> SUM<span class="token punctuation">[</span>lson<span class="token punctuation">]</span> <span class="token operator">+</span> SUM<span class="token punctuation">[</span>rson<span class="token punctuation">]</span><span class="token punctuation">;</span>
	MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>MAX<span class="token punctuation">[</span>lson<span class="token punctuation">]</span><span class="token punctuation">,</span> MAX<span class="token punctuation">[</span>rson<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">qMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l <span class="token operator">&amp;&amp;</span> r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span> <span class="token keyword">return</span> MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token operator">-</span>MAXN<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">qMax</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">&lt;</span>R<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">qMax</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">qSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l <span class="token operator">&amp;&amp;</span> r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span> <span class="token keyword">return</span> SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">qSum</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">&lt;</span>R<span class="token punctuation">)</span> ref <span class="token operator">+=</span> <span class="token function">qSum</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token operator">-</span>MAXN<span class="token punctuation">;</span>
	<span class="token keyword">int</span> f1 <span class="token operator">=</span> top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> top<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>f1 <span class="token operator">!=</span> f2<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>f1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> depth<span class="token punctuation">[</span>f2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
		ref <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">qMax</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>f1<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a <span class="token operator">=</span> fa<span class="token punctuation">[</span>f1<span class="token punctuation">]</span><span class="token punctuation">;</span>
		f1 <span class="token operator">=</span> top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> v<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">></span> depth<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">qMax</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">findSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> f1 <span class="token operator">=</span> top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> top<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>f1 <span class="token operator">!=</span> f2<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>f1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> depth<span class="token punctuation">[</span>f2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">swap</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
		ref <span class="token operator">+=</span> <span class="token function">qSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>f1<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a <span class="token operator">=</span> fa<span class="token punctuation">[</span>f1<span class="token punctuation">]</span><span class="token punctuation">;</span>
		f1 <span class="token operator">=</span> top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> ref <span class="token operator">+</span> v<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">></span> depth<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref <span class="token operator">+</span> <span class="token function">qSum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token comment">//	freopen("tes.in", "r", stdin);</span>
	<span class="token function">mmst</span><span class="token punctuation">(</span>Mindex<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ri</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">ri</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">addEdge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    	<span class="token function">ri</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    siz<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> depth<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> fa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_tree</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    	<span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">ri</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> que<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> que<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token function">ri</span><span class="token punctuation">(</span>q1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>q2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>que<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">findMax</span><span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>que<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">findSum</span><span class="token punctuation">(</span>q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">else</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">[</span>q1<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>q1<span class="token punctuation">]</span><span class="token operator">=</span>q2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> Mindex<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> Mindex<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> Mindex<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span> Mindex<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span> <span class="token keyword">bool</span> minus <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token string">'0'</span> <span class="token operator">||</span> <span class="token string">'9'</span><span class="token operator">&lt;</span>c<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> minus<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> c<span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> c<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>x<span class="token operator">+</span>c<span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>minus<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编程时有几点要留意：</p>
<ul>
<li>注意权值在树中摆放的位置， 在边上或者在结点上，通常可以转化成在结点上。</li>
<li>在一条重链上，深度小的点在线段树左边，深度大的在右边（相对而言）。</li>
<li>find()中当f1==f2后，路径a~b是尚未被计算的，特别是要留意if (a==b)，将其权值记上。</li>
<li>dfs()先解决深度、大小（轻重）、重儿子、父亲的问题。</li>
<li>set_tree()后解决top重链头标记、安排映射的问题。</li>
</ul>
<h4 id="2016-06-02新增"><a href="#2016-06-02新增" class="headerlink" title="2016.06.02新增"></a>2016.06.02新增</h4><p>改进两个初始化：</p>
<ul>
<li>第一个初始化先用宽搜解决深度计数和父亲指针的预处理，然后反向遍历队列，用改进的方式计算size和重儿子。</li>
<li>第二个初始化用粗略的模拟栈，重儿子优先做深搜，由浅到深计算id和top。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">30010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">bool</span> GETMAX <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> GETSUM <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> val<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> SUM<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> MAX<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> depth<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> fa<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> top<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> wson<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> siz<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> to<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nex<span class="token punctuation">[</span>MAXN<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> _index<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> q<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">querySUM</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">qtree</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">bool</span> flag<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> GETMAX <span class="token operator">?</span> <span class="token operator">-</span>MAXN <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">!=</span>top<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> depth<span class="token punctuation">[</span>top<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span>GETMAX<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> ref <span class="token operator">+=</span> <span class="token function">querySUM</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a <span class="token operator">=</span> fa<span class="token punctuation">[</span>top<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">></span>depth<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> GETMAX<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> ref <span class="token operator">+=</span> <span class="token function">querySUM</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token comment">//	freopen("tes.in", "r", stdin);</span>
	
	<span class="token function">memset</span><span class="token punctuation">(</span>_index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>wson<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>wson<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>siz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>siz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">ri</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">ri</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">addEdge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">ri</span><span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">build</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">ri</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> rd<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> rd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">ri</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">ri</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>rd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">qtree</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> GETMAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'S'</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">qtree</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> GETSUM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> id<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>	
	<span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tail <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	fa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	depth<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">&lt;</span> tail<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>head<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>_index<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				depth<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
				fa<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
				q<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>tail<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
		siz<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token operator">++</span>siz<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>siz<span class="token punctuation">[</span>wson<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> siz<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> wson<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">sta</span> <span class="token expression">q</span></span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	sta<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	top<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span>tail <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> sta<span class="token punctuation">[</span><span class="token operator">--</span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span>
		id<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>num<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>_index<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span>nex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>wson<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				top<span class="token punctuation">[</span>to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				sta<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>wson<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			top<span class="token punctuation">[</span>wson<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> top<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			sta<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> wson<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">lson</span> <span class="token expression"><span class="token punctuation">(</span>root<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rson</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> v<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token function">update</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">,</span> v<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> SUM<span class="token punctuation">[</span>lson<span class="token punctuation">]</span> <span class="token operator">+</span> SUM<span class="token punctuation">[</span>rson<span class="token punctuation">]</span><span class="token punctuation">;</span>
	MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>MAX<span class="token punctuation">[</span>lson<span class="token punctuation">]</span><span class="token punctuation">,</span> MAX<span class="token punctuation">[</span>rson<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	r <span class="token operator">&lt;&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		SUM<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		MAX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>MAXN<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l <span class="token operator">&amp;&amp;</span> r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span> <span class="token keyword">return</span> MAX<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token operator">-</span>MAXN<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">&lt;</span>R<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token function">queryMAX</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">querySUM</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l <span class="token operator">&amp;&amp;</span> r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span> <span class="token keyword">return</span> SUM<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ref <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> ref <span class="token operator">=</span> <span class="token function">querySUM</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> lson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">&lt;</span>R<span class="token punctuation">)</span> ref <span class="token operator">+=</span> <span class="token function">querySUM</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">,</span> rson<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> _index<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> _index<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
	to<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> nex<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> _index<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span> _index<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ri</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> mus <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token string">'0'</span> <span class="token operator">||</span> <span class="token string">'9'</span><span class="token operator">&lt;</span>c<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> mus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> c<span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token string">'0'</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> c<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>x <span class="token operator">+</span> c <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mus<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2019/09/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>不会汇编，强行刚软保，<del>瑟瑟发抖</del>稳得一匹</p>
<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="C语法"><a href="#C语法" class="headerlink" title="C语法"></a>C语法</h2><ol>
<li>指针作差得到区间元素个数。<strong>指针的类型参与计算！</strong></li>
<li>要动态改变函数体，需要在编译期赋予权限。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>linker<span class="token punctuation">,</span> </span><span class="token string">"/section:test,RWE"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<span id="more"></span>

<ol>
<li><code>__asm int 3</code>加入汇编断点（OD）。要在OD中启用StrongOD，禁用跳过int3；并设置测试选项</li>
<li></li>
<li></li>
</ol>
<h2 id="Windows-exe结构"><a href="#Windows-exe结构" class="headerlink" title="Windows exe结构"></a>Windows exe结构</h2><ol>
<li>401000H这个内存地址对应的文件地址是1000H</li>
</ol>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Quickview：更改EXE数据"><a href="#Quickview：更改EXE数据" class="headerlink" title="Quickview：更改EXE数据"></a>Quickview：更改EXE数据</h2><ol>
<li>按<code>F5</code>可以按地址定位</li>
<li>提供三种模式：16进制格式，汇编格式，纯文本格式；按<code>F2</code>切换到32位模式</li>
<li>按<code>Alt+F9</code>保存</li>
<li>按<code>ins</code>选择块（开始和结束各按一次），选择后按<code>shift</code>底部出现块工具</li>
<li></li>
</ol>
<h2 id="OD：单步跟踪EXE"><a href="#OD：单步跟踪EXE" class="headerlink" title="OD：单步跟踪EXE"></a>OD：单步跟踪EXE</h2><ol>
<li>可以用来追踪去壳代码</li>
<li>可以dump数据块到文件</li>
<li>可以设置硬件断点，当某储存位置发生更改时中断</li>
<li><code>Alt+B</code>管理断点，<code>空格</code>切换</li>
<li></li>
</ol>
<h2 id="IDA：静态分析EXE"><a href="#IDA：静态分析EXE" class="headerlink" title="IDA：静态分析EXE"></a>IDA：静态分析EXE</h2><ol>
<li>按<code>G</code>定位</li>
<li>可通过加壳反抗静态分析。</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="面对加壳"><a href="#面对加壳" class="headerlink" title="面对加壳"></a>面对加壳</h2><ol>
<li>用OD动态追踪，尝试还原被加壳代码（等待去壳），再用QV还原EXE（用块复制的办法加快速度）</li>
</ol>
<h2 id="面对序列号"><a href="#面对序列号" class="headerlink" title="面对序列号"></a>面对序列号</h2><ol>
<li><p>观察到现象：弹框并消失。可行办法：跟踪CreateWindow/ShowWindow/DestoryWindow（推荐）</p>
</li>
<li><p>用OD动态追踪，尝试中断DestoryWindow，观察堆栈顶端找到出栈后的程序运行位置（或直接跑retn)</p>
</li>
<li><p>对不当场判断的场合（没有明显现象） 怀疑有文件/注册表读写 <code>FileMon + RegMon = ProcMon</code></p>
<p> RegCreateKey()<br> RegQueryValue()<br> RegSetValue()</p>
<p> CreateFile<br> CreateFileEx<br> ReadFile<br> WriteFile</p>
</li>
<li><p>软件断点：当前断点指令的首字节改为<code>0xCC</code>（对应的汇编指令为int 3）。 可能被程序自检。</p>
</li>
<li><p>硬件断点：选中某条指令-&gt;断点-&gt;硬件执行。  检查已设置的断点：调试-&gt;硬件断点... 原理：CPU调试寄存器保存了断点地址和断点条件，每个周期都会检查条件。触发条件有<code>execute</code>，<code>read</code>, <code>write</code>。  要设置读/写断点，选中变量的首字节-&gt;右键-&gt;断点-&gt;硬件写入-&gt;DWORD（对应的类型）。要设置DWORD断点对变量首字节有要求。读/写完成后到达断点。<br>可以用<code>printf(&quot;%p&quot;,...)</code>知道要跟踪的变量的地址。</p>
</li>
<li><p>利用读/写硬件断点，当操作序列号时就能断住。<code>Ctrl+B</code>搜索已输入的序列号找到内存地址。跳跃几次看到<code>rep movs</code>（字符串拷贝），此时取消断点，回到用户代码，跳出几次，看到getText</p>
</li>
<li><p>如果进入系统代码，则应跳出到用户代码<code>Alt+F9</code>，再按<code>Ctrl+F9</code>跳出一些函数。</p>
</li>
<li><p><code>CallWindowProcA</code>的作用是由系统内核来回调用户事先写的消息处理函数</p>
</li>
</ol>
<h1 id="汇编规则"><a href="#汇编规则" class="headerlink" title="汇编规则"></a>汇编规则</h1><ol>
<li>cdq edx:eax, idiv, edx = edx:eax %n</li>
</ol>
<h1 id="逆向工程历史"><a href="#逆向工程历史" class="headerlink" title="逆向工程历史"></a>逆向工程历史</h1><ol>
<li>微软开发<code>debug</code>，<code>codeview</code>, 宝蓝开发<code>TurboDebug</code>;</li>
</ol>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ol>
<li><code>debug</code> 编程：a(assemble) 地址+汇编语言，偏移地址固定从100开始   (OD中改指令相当于a，若下一条语句实效，会有安全措施，改90NULL)。</li>
<li>u(unassemble) 反汇编，指定开始地址和末地址（l+长度亦可)，反汇编对应地址内的机器语言。</li>
<li>r(register) 查看寄存器 SF+PL-NG UP上DN下.  r + 寄存器名字, 修改内存</li>
<li>p (optional 地址) 单步前进，目标地址是执行完毕的</li>
<li>g (optional =首地址 (optional) 末地址) (从csip)跳跃直到int 3(末地址是未执行的);</li>
<li>d(dump) 查看内存 可以指定(d cs:100 120 || d cs:100 l20)</li>
<li>e(edit) 修改内存 地址 + &quot;string&quot; || hex</li>
<li>t(track in)</li>
</ol>
<h2 id="加密软件"><a href="#加密软件" class="headerlink" title="加密软件"></a>加密软件</h2><ol>
<li><code>lock89</code>, <code>lockup</code>, 作者：杨道沅, 硬盘指纹加密技术</li>
<li><code>lock93</code>, <code>lock93NT</code>, 周辉</li>
<li><code>BitLock</code>, 雷军</li>
</ol>
<h1 id="驻留内存程序"><a href="#驻留内存程序" class="headerlink" title="驻留内存程序"></a>驻留内存程序</h1><h2 id="需要技术"><a href="#需要技术" class="headerlink" title="需要技术"></a>需要技术</h2><ol>
<li>驻留内存</li>
<li>中断</li>
</ol>
<p><code>es:[bx]</code> 0:32是一个中断向量的地址</p>
<p>0:0 ~ 0:3FF 是中断向量表，每个中断向量占用4字节。 例如<code>int 00h</code>的中断向量储存在0:0 ~ 0:3之间; <code>int 01h</code>的中断向量储存在0:4 ~ 0:7之间。</p>
<p>当cpu执行<code>int 00h</code>时：<br>pushf 保护当前标志位（flag）的状态<br>push cs 当前短地址<br>push 下条指令的偏移地址<br>cli<br>jmp 8756h:3412h</p>
<p>// cli disable interrupt    (clear interrupt)<br>// sti enable.              (set interrupt)</p>
<p>8756h:3412h 是中断服务程序的入口地址<br>    ……<br>    iret; 中断返回</p>
<p>当cpu执行<code>iret</code>时：<br>pop ip;<br>pop cs;<br>popf;       从而实现恢复现场。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 调换中断向量表
cli
mov word ptr es:[bx], offset int_8h
mov es:[bx+2], cs
sti<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jmp dword ptr cs:[old_8h] ; 中断链接   old_8h定义在code段内是必要的
; iret 导致旧程序不再执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">int_8h:    ; 中断服务
;;;;;;
push ds
push ax
mov ax, data
mov ds, ax
;;;;;;

inc [count]
cmp [count], 18

inc cs:[count]  ; count db 0 at the end  定义在code段内


push ... ; 记忆所有寄存器   ax bx cb dx si di ds

push cs
pop ds
push cs
pop es
mov al,4
out 70,al
in al,71h &#x2F;&#x2F; hour
call convert
mov word ptr current_time[?], ax
...



jmp dword ptr cs:[old_8h]  ;返回旧程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>驻留</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">install:
mov ah, 9

; program segment prefix(PSP) 长度为100h，其中PSP:80h存放命令行参数，程序刚刚开始时 ds &#x3D; es &#x3D; psp，

...


in al, 60h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="gamebuster"><a href="#gamebuster" class="headerlink" title="gamebuster"></a>gamebuster</h1><pre class="line-numbers language-none"><code class="language-none">mount c:... d:\...
gb
pc
[ctrl][ctrl]  分析&quot;&#x2F;十进制&quot; &quot;十六进制&quot;
[alt + 1]
[shift + 1] 锁

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="dosboxdeb"><a href="#dosboxdeb" class="headerlink" title="dosboxdeb"></a>dosboxdeb</h2><p>dos mcbs 获得当前程序的PSP （memory control block)<br>u 01dd:1785  // 查看反汇编</p>
<h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">pushf
pop ax
or ax, 0100h
push ax
popf    ; 修改 TF &#x3D; 1

nop;    ; 当TF&#x3D;&#x3D;1，执行一条指令后调用 int 1h

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="某种病毒"><a href="#某种病毒" class="headerlink" title="某种病毒"></a>某种病毒</h2><p>修改<code>int 21h</code>中断向量为<code>xxxx:yyyy</code>，原向量保存在内部变量<code>old_21h</code>中。新指令为<code>cmp ah 4Bh</code>，判断是否要执行程度。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">je infect_exe
jmp dword ptr cs:[old_21h]

infect_exe:
    mov ah, 3dh; AH&#x3D;&#x3D;3DH 表示打开文件
    mov al, 2; 读写方式
    pushf
    call dword ptr cs:[old_2h]; call 隐含push段地址、偏移地址 ..?
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>原始的<code>int 21h</code>中断向量的段地址&lt;=70h</p>
<p>假装调用一个无用的<code>int 21h</code>功能，如获取dos版本号</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ah, 30h
pushf
置位TF ; 不能手动int 21h，因为系统将flag置零
call dword ptr [current_21h]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="EXE文件格式"><a href="#EXE文件格式" class="headerlink" title="EXE文件格式"></a>EXE文件格式</h2><p>+00 4D, 5A; EXE标志“MZ”<br>+02 50, 01; 最后一个扇区的字节数为150h （例外：如果是00 00则最后一个扇区是满载）<br>+04 02, 00; EXE占用的扇区数量（200字节/一个扇区）<br>+06 02, 00; 重定位项数<br>+08 02, 00; 文件头的节长度=20h，所以字节长度=200h (20h x 10h)<br>+0A 00, 00; 至少内存   DOS是单任务的，所以内存限制没有太大意义<br>+0C FF, FF; 至多内存<br>+0E 05, 00; SS与程序首段地址的距离 （程序首段地址在运行时确定, = psp+10h）<br>+10 00, 01; SP = 100h</p>
<p>+12 E8, 20; EXE文件头的校验值<br>+14 28, 00; IP=0028h            ; 注意此处先IP后CS   CS:IP第一句指令<br>+16 02, 00; CS与程序首段地址的距离<br>+18 1E, 00; 重定位表的偏移地址</p>
<p>; 下面是重定位表。每个重定位项4个字节。每两个字节为一个信息。<br>+1E 01, 00; 重定位的偏移地址=0001h<br>+20 02, 00; Δ=0002h,<br>; 首段地址+Δ=重定位的段地址<br>;<br>+22 0D, 00; 重定位的偏移地址=000Dh<br>+24 02, 00; Δ=0002h,<br>; 首段地址+Δ=重定位的段地址</p>
<p>DOS运行程序时，文件头不载入内存，所以内存头可认为是文件头长度</p>
<p>200h+2:1 = 0:200h + 0:21 = 0:211</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ah, 2
mov dl, &#39;A&#39;
int 21h
mov ah, 1
int 21h


mov ax, ds
add ax, 10
add ax, 2
push ax
mov ax, 28h
push ax
retf ; pop ip, pop cs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">code segment
assume cd:code
shell:
    call next
next:
    pop ax ; ax &#x3D; ip &#x3D; next的地址
    sub ax, (offset next - offset shell)
    mov bx, ax
    
    mov cs:[old_ds+bx], ds
    mov cs:[old_es+bx], es
    mov bp, ds ; psp
    add bp, 10h; 首段段地址
    mov cx, [reloc_count+bx]
    push cs
    pop ds
    mov si, offset reloc_table
    add si, bx
    
reloc_next_item:
    mov ax, [si] ;lodsw ; ax &#x3D; ds:[si] ; offset
    mov dx, [si+2]                      ; delta segment
    add dx, bp
    mov es, dx
    
    add es:[di], bp
    add si, 4
    dec cx
    jnz reloc_next_item
    
    mov ax, [csip+bx]
    mov dx, [csip+bx+2]
    add dx, bp
    push dx
    push ax
    mov ds, cs:[bx+old_ds]
    mov es, cs:[bx+old_es]
    retf
    


old_ds dw 0
old_es dw 0
csip dw 0, 0
reloc_count dw 0
reloc_table db label byte ; 定义为db但不赋初值


code ends
end shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意加密堆栈后引发的解密对新数据的影响的问题。</p>
<p>保存ss和sp，之后修改它为一段预留空间</p>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p><em>32位系统下</em><br>|            |  保护模式  |      实模式       |<br>| :--------: | :--------: | :---------------: |<br>| 最大段长度 |     4G     |        64K        |<br>|  越界访问  | 运行时错误 |       允许        |<br>|  物理寻址  |  查gdt表   | 基址*10h+10h+偏移 |</p>
<h2 id="查gdt表"><a href="#查gdt表" class="headerlink" title="查gdt表"></a>查gdt表</h2><p>设<code>ds=10h</code>，现通过查gdt表获得其物理地址。gdt表储存描述符，每个占8字节。表的首地址存在于<code>gdtr</code>寄存器。</p>
<p>gdt+10h xx xx xx xx xx xx xx xx</p>
<h2 id="idt中断描述符表"><a href="#idt中断描述符表" class="headerlink" title="idt中断描述符表"></a>idt中断描述符表</h2><p>首地址存在于<code>idtr</code>中。每项有8字节。基址2字节，偏移4字节，剩余2字节记录权限。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lgdt fword ptr gdt ; 把gdt表的首地址和长度载入到gdtr寄存器

cli
smsw ax
and ax, 1Fh
or al, 1
lmsw ax; enable PE bit of MSW or CR0
db 0EAh ; JMP FAR PTR
dw 00h
dw pseg_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学随笔</title>
    <url>/2019/06/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p><em>本文的编撰仅面向作者本人</em></p>
<h1 id="1-6-Rules-of-Inference"><a href="#1-6-Rules-of-Inference" class="headerlink" title="1.6 Rules of Inference"></a>1.6 Rules of Inference</h1><ol>
<li>Modus ponens 假言推理 p &amp; p-&gt;q =&gt; q </li>
<li>Modus tollens 取拒式 !q &amp; p-&gt;q =&gt; !p</li>
<li>Hypothetical syllogism /,haɪpə&#39;θɛtɪk, &#39;sɪlə,dʒɪz(ə)m/ 假言三段论 p-&gt;q &amp; q-&gt;r =&gt; p-&gt;r </li>
<li>Disjunctive syllogism 析取三段论 pVq &amp; !p = p</li>
<li>Addtion 附加律 p =&gt; pVq  （附加在析取式中）</li>
<li>Simplification 化简律 p&amp;&amp;q =&gt; p （合取条件的拆分）</li>
<li>Resolution 消解律 pVq &amp; !pVr =&gt; qVr 条件相斥必有一T</li>
<li>? Logical equivalence<span id="more"></span></li>
</ol>
<p>$$<br>\begin{matrix}<br>    Step &amp; Reason \</p>
<ol>
<li>xxx &amp; Premise \</li>
<li>xxx &amp; Contrapositive,of,(1) \</li>
<li>xxx &amp; XXrule,using,(n),and,(m)<br>\end{matrix}<br>$$</li>
</ol>
<h2 id="Fallacies-谬误"><a href="#Fallacies-谬误" class="headerlink" title="Fallacies 谬误"></a>Fallacies 谬误</h2><ol>
<li>fallacy of affirming the conclusion 肯定结论的谬误 由结论推出条件</li>
<li>fallacy of denying the hypothesis  /haɪ&#39;pɒθɪsɪs/ 否定假设的谬误 从否定条件推出否定结论</li>
</ol>
<h2 id="Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则"><a href="#Rules-of-Inference-for-Quantified-Statements-量化命题的推理规则" class="headerlink" title="Rules of Inference for Quantified Statements 量化命题的推理规则"></a>Rules of Inference for Quantified Statements 量化命题的推理规则</h2><ol>
<li>Universal instantiation 全称实例 $\forall xP(x) \implies P(c)$</li>
<li>Universal generalization 全称引入 $P(c)$ for an arbitrary $c \implies \forall xP(x)$</li>
<li>Existential instantiaion 存在实例 $\exists xP(x) \implies P(c)$ for some element $c$</li>
<li>Existencial generalization 存在引入 $P(c)$ for some element $c \implies \exists xP(x)$</li>
</ol>
<h2 id="Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements"><a href="#Combining-Rules-of-Inference-for-Propositions-and-Quantified-Statements" class="headerlink" title="Combining Rules of Inference for Propositions and Quantified Statements"></a>Combining Rules of Inference for Propositions and Quantified Statements</h2><ol>
<li>Universal modus ponens 全称假言推理 对某个全称实例应用假言推理</li>
<li>Universal modus tollens 全称取拒式 对某个全称实例应用取拒式（否定结论推出否定条件）</li>
</ol>
<hr>
<h1 id="1-7-Introduction-to-Proofs"><a href="#1-7-Introduction-to-Proofs" class="headerlink" title="1.7 Introduction to Proofs"></a>1.7 Introduction to Proofs</h1><ol>
<li>theorem /&#39;θɪərəm/ 定理 （定理的证明有定义、其他定理、公理、推断规则）</li>
<li>lemma /&#39;lemə/ 引理 用于证明定理的其他定理</li>
<li>corollary /kə&#39;rɒlərɪ/ 推论 定理下的直接结论</li>
<li>propositions 命题 偶尔用来称呼不重要的定理，或称事实、结论</li>
<li>conjecture /kən&#39;dʒektʃə/ 猜想 一旦找到证明，猜想就变成定理；也有可能被证伪</li>
</ol>
<h2 id="To-Proof-p-gt-q-or-to-proof-p"><a href="#To-Proof-p-gt-q-or-to-proof-p" class="headerlink" title="To Proof p-&gt;q (or to proof p)"></a>To Proof p-&gt;q (or to proof p)</h2><ol>
<li>Trivial Proof : 平凡证明 if q is true then p-&gt;q is true.</li>
<li>Vacuous Proof : 空证明 if p is false then p-&gt;q is true.</li>
<li>Direct Proof : Assume p is true and show that q is true by using inferences, axioms, logical equivalences.</li>
<li>Indirect Proof : not begin with the premises and not end with the conclusion</li>
<li>Proof by contraposition 反证法 : Assume !q and show !p is true also. 直接证明法无效时尝试反证法</li>
<li>Proof by Contradiction 归谬证明法 : To proof p, first find a r such that !p -&gt; (r &amp;&amp; !r) is true, therefore !p is false and p is true. 假设结论的否定为真，引出一个矛盾</li>
<li>反例证明法 : 指明一个反例，从而证伪</li>
</ol>
<hr>
<h1 id="1-8-Proof-Methods-and-Strategy-证明的方法和策略"><a href="#1-8-Proof-Methods-and-Strategy-证明的方法和策略" class="headerlink" title="1.8 Proof Methods and Strategy 证明的方法和策略"></a>1.8 Proof Methods and Strategy 证明的方法和策略</h1><ol>
<li>Proof by cases 分情形证明法 tautology : (p1Vp2V...pn)-&gt;q &lt;-&gt; (p1-&gt;q)&amp;&amp;(p2-&gt;q)&amp;&amp;...(pn-&gt;q) 类似分类讨论</li>
<li>Exhaustive Proof 穷举证明法 当变量的取值比较少的时候，通过测试所有情形来证明。</li>
<li>Without loss of generality (WLOG) 不失一般性 省略非常类似的情形（证明过程几乎相同）的证明</li>
</ol>
<h2 id="Existence-Proof-存在性证明"><a href="#Existence-Proof-存在性证明" class="headerlink" title="Existence Proof 存在性证明"></a>Existence Proof 存在性证明</h2><p>To proof $\exists x P(x)$ :</p>
<ol>
<li>Constructive existence proof 构造性 : Find an explicit c, for which P(c) is true.</li>
<li>Nonconstructive existence proof 非构造性证明 ： 不直接构造例子，但说明多种情况之一必有符合的例子；或若不存在，就得到某些矛盾。</li>
</ol>
<h2 id="Uniqueness-Proof-唯一性证明"><a href="#Uniqueness-Proof-唯一性证明" class="headerlink" title="Uniqueness Proof 唯一性证明"></a>Uniqueness Proof 唯一性证明</h2><p>同时证明存在性和唯一性，即x符合某种期望，而若y!=x，则y不符合这种期望。也可以等价地证明若y符合这种期望，则y=x。</p>
<hr>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li>The cardinality of  a finite set A 集合的基数，|A|</li>
<li>finite 有限的 /faɪnaɪt/</li>
<li>infinite 无限的 /&#39;ɪnfɪnət/</li>
<li>Power Set 幂集 P(A) The set of all subsets of a set A. $|P(A)| = 2^{|A|}$</li>
<li>Cartesian Product 笛卡尔积 A x B x C的意义和(A x B) x C不一样！</li>
<li>coordinate</li>
</ol>
<h2 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h2><ol>
<li>Union /&#39;junɪən/</li>
<li>Intersection</li>
<li>Complementation : complement 补集，必须有universal set U。A上一横杠</li>
<li>Difference 不满足交换律，A-B</li>
<li>Symmetric Difference 对称差 异或</li>
</ol>
<h3 id="Set-Identities-集合恒等式"><a href="#Set-Identities-集合恒等式" class="headerlink" title="Set Identities 集合恒等式"></a>Set Identities 集合恒等式</h3><ol>
<li>注意一下分配率，德摩根律（否定去括号）</li>
<li>其他不管啊太简单了</li>
<li>Membership Tables 成员表，枚举任意元素属于各个集合情况，从而验证恒等式（和真值表类似）</li>
</ol>
<h2 id="Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B"><a href="#Funtion-f-maps-A-to-B-f-is-a-mapping-from-A-to-B" class="headerlink" title="Funtion (f maps A to B) (f is a mapping from A to B)"></a>Funtion (f maps A to B) (f is a mapping from A to B)</h2><ol start="0">
<li>assignment 指派，分配。 指定f(a)=b。</li>
<li>domain 定义域 A</li>
<li>codomain 陪域 B</li>
<li>image 像 b is an image of a under f</li>
<li>preimage 原像 可能是单个元素，也可能是一个集合。</li>
<li>f(A) range 值域</li>
<li>等价的函数具有相同的domain &amp; codomain &amp; map each element to the same element of the codomain</li>
<li>$f(S) = {f(s)|s\in S}$</li>
<li>$(f_1+f_2)(x) = f_1(x)+f_2(x)$</li>
<li>$(f_1*f_2)(x) = f_1(x)*f_2(x)$</li>
<li>injection injective 单射 one-to-one 可在值域上定义反函数</li>
<li>surjection surjective (or onto) 满射 映上 陪域中每个元素都能找到原像</li>
<li>injective and surjective =&gt; bijection or one-to-one correspondence 双射 一一对应</li>
<li>invertible 可逆的 Inverse Function 反函数</li>
<li>Composition 复合函数 $f \circ g = f(g(x))$</li>
<li>Factorial/fæk&#39;tɔrɪəl/ Function 阶乘函数</li>
<li>Partial Function 局部函数，对某个函数截取部分domain</li>
</ol>
<h2 id="Sequence-序列-a-n"><a href="#Sequence-序列-a-n" class="headerlink" title="Sequence 序列 ${a_n}$"></a>Sequence 序列 ${a_n}$</h2><p>A funtion from N or N+ to S<br>$$a_n = f(n)$$</p>
<ol>
<li>term 项</li>
<li>Geometric Progression 几何级数 a*r^n, n=0,1...  (a and r are real numbers)</li>
<li>Arithmetic Progression 算术级数 （等差数列）</li>
<li>Recurrence relation 递推关系 </li>
<li> a solution of a recurrence relation 满足递推关系的序列称为这个递推关系的一个解</li>
<li> initial conditions 初始条件 递推关系生效前的所有terms</li>
<li> solving the recurrence relation 找到通项公式 这样的公式叫closed formula闭公式</li>
<li> iteration 迭代法，正向替换 working upward； 反向替换 working downward。 用于猜测formula，然后用the method of induction数学归纳法证明。</li>
<li> Summation （序列的部分）总和</li>
<li>in lexicographic order /,lɛksɪkə&#39;græfɪk/ 字典序</li>
</ol>
<h2 id="Matrices-矩阵"><a href="#Matrices-矩阵" class="headerlink" title="Matrices 矩阵"></a>Matrices 矩阵</h2><ol>
<li>Boolean Product 布尔积 类似矩阵乘法，各项求交之后求并</li>
<li>Boolean Powers 多次布尔积。 写作$A^{[n]}$, 记$A^{[n]}=I$</li>
</ol>
<hr>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol>
<li>pseudocode /&#39;sju:doˌkod/ 伪代码</li>
<li>Halt Problem 停机问题，无解</li>
<li>Big-O f(x) of big-O of g(x)</li>
<li>|f(x)| &lt; |c*g(x)| (x &gt; k) : the constants c and k are called witnesses. Only one pair of witnesses is needed.</li>
<li>if f = O(g) &amp;&amp; g = O(f), then the two functions are of the same order.</li>
<li>polynomial /,pɒlɪ&#39;nəʊmɪəl/ 多项式</li>
<li>if |f(x)| &gt; |C*g(x)| (x &gt; k) : Big-Omega</li>
<li>if f = O(g) &amp;&amp; g = O(f), then f = θ(g) : Big-Theta; f(x) is of order g(x).</li>
<li>brute-force 蛮力（算法）</li>
<li>Tractable Problem ：P类问题，多项式时间内解决</li>
<li>Intractable Problem</li>
<li>Unsolvable Problem 无解的问题，例如Halt Problem</li>
<li>Class NP: 可在多项式时间内验证一个解的问题</li>
<li>NP Complete Class: NPC问题，所有的NP问题都能约化为NPC问题。</li>
</ol>
<hr>
<h1 id="Number-Theory-and-Cryptography-数论和密码学"><a href="#Number-Theory-and-Cryptography-数论和密码学" class="headerlink" title="Number Theory and Cryptography 数论和密码学"></a>Number Theory and Cryptography 数论和密码学</h1><p>/krɪp&#39;tɑgrəfi/</p>
<ol>
<li>divisibility /di,vizi&#39;biləti/ 可除性</li>
<li>hexadecimal /,hɛksə&#39;dɛsɪml/ 十六进制（的）</li>
<li>modular /&#39;mɑdjʊlɚ/ 模的</li>
<li>congruence 同余 /&#39;kɑŋgrʊəns/</li>
<li>a divides b  a除b， a is a factor or divisor of b, b is a multiple of a.</li>
<li>quotient /&#39;kwoʃnt/商; remainder /rɪ&#39;mendɚ/余数</li>
<li>-11 / 3 = -4 ... 1</li>
<li>The notation a  ≡  b (mod m)  says  that a is <strong>congruent</strong> to b modulo m.   a  ≡  b (mod m) is a congruence and that m is its modulus.</li>
<li>doing arithmatic modulo m: $a+_mb = (a+b) \mod m; a*_mb = (a*b) \mod m$</li>
</ol>
<h2 id="Zm-0-m-1"><a href="#Zm-0-m-1" class="headerlink" title="Zm = {0...m-1}"></a>Zm = {0...m-1}</h2><ol>
<li>Closure 封闭性</li>
<li>Associativity 结合律</li>
<li>Commutativity 交换律</li>
<li>Identity element 单位元 （加法0，乘法1）</li>
<li>Additive inverse 加法逆元</li>
<li>Distributivity 分配率</li>
<li>判定同余式，左边减右边是m的倍数。</li>
</ol>
<h2 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h2><ol>
<li>composite /kɑm&#39;pɑzɪt/ 合数</li>
<li>divisible by 7 能被7整除</li>
<li>Mersenne Primes 梅森素数：满足2的素数次方减一的素数。检验2的素数次方减一是否素数是容易的，由此得到已知的最大素数。$2^{11}-1不是素数$</li>
<li>Prime Number Theorem: 不超过x的素数个数大约是(x / ln x)，任取一个不超过n的数，则这个数是素数的概率是1/lnx。</li>
<li>对两个互质的数a,b:ak+b可以生成无限个素数。</li>
<li>存在由任意个素数组成的等差数列（Arithmetic Progression）</li>
<li>现阶段没有发现高效生成素数的算法f(n)</li>
<li>不存在多项式函数f(n)使得其值一定是素数</li>
<li>Goldbach’s Conjecture 哥德巴赫猜想：所有大于2的偶数都能表示为两个素数的和。</li>
<li>Conjecture: There are infinitly many primes of the form $n^2+1$.</li>
<li>The Twin Prime Conjecture: 相差2的素数有无限多组</li>
</ol>
<h2 id="Great-Commom-Divisor-dɪ-39-vaɪzɚ"><a href="#Great-Commom-Divisor-dɪ-39-vaɪzɚ" class="headerlink" title="Great Commom Divisor /dɪ&#39;vaɪzɚ/"></a>Great Commom Divisor /dɪ&#39;vaɪzɚ/</h2><ol>
<li>relatively prime 互质数</li>
<li>pairwise relatively prime 两两互质</li>
<li>Prime Factorizations /,fæktərai&#39;zeiʃən/ 质因数分解</li>
<li>Least Common Multiple 最小公倍数 lcm(a,b)</li>
<li>Euclidean /ju:&#39;klidiən/ 欧几里得的</li>
<li>Bézout’s Theorem 贝祖定理 gcd(a,b) = sa+tb. （求s、t用扩展欧几里得）</li>
<li>if gcd(a,b)=1 &amp;&amp; a|bc, then a|c; Therefore, a ≡ b (mod m) if ac ≡ bc (mod m) &amp;&amp; gcd(c,m)=1.</li>
</ol>
<h2 id="Solving-Congruences"><a href="#Solving-Congruences" class="headerlink" title="Solving Congruences"></a>Solving Congruences</h2><ol>
<li>linear congruences 线性同余方程 ax≡b ( mod m)</li>
<li>an inverse of A modulo m 模m下a的乘法逆元</li>
<li>逆元存在的充要条件：若gcd(a,m)=1, 则存在a在模m下的乘法逆元。 Proof: Since gcd(a,m)=1, there are integers s and t such that sa+tm=1. Hence, sa+tm ≡ 1 ( mod m), and it follows that sa ≡ 1 ( mod m). 用扩展欧几里得求出s即逆元。</li>
<li>coefficient /koʊəˈfɪʃənt/ 系数</li>
<li>Chinese Remainder Theorem: 对于模数两两互质的同余方程组（一条方程的形式为$x≡a_i (\mod m_i), m&gt;1$）,在$模M=\prod\limits_{i=1}^n m_i系$中有且仅有唯一解。一个解的构造为$x = \sum\limits_{i=1}^n a_i M_i y_i$, 其中$M_i = M\div m_i, y_i*M_i≡1 (\mod m_i)$。如此构造后，对任意的i，都满足同余方程$x ≡ a_i M_i y_i ≡ a_i (\mod m_i)$。模系下的唯一性<strong>待证 练习30</strong>。</li>
<li>Fermat’s Little Theorem： $有质数p，有整数a不是p的倍数，则a^{p-1}≡1(\mod p)$</li>
<li>利用费马小定理可以简化$a^q \mod p$的运算，其中q很大。可以将q替换为$(q \mod (p-1))$</li>
<li>满足$b^{n-1}≡1(\mod n)$的非质数n成为以b为基的伪质数 Pseudoprimes to the base b。（苏豆）</li>
<li>因为在一定范围内的对于某个基的pseudoprimes总是很少，所以可以进行质数近似判定测试。可惜，对于某些数n，对于所有基b满足gcd(b,n)=1，总是能通过伪素数测试，即$b^{n-1}≡1(\mod n)$，这些数称为Carmichael Numbers（卡麦抠 卡米切尔）。 Carmichael Numbers有无穷多个。</li>
<li>欧拉定理：费马小定理的推广。$有互质整数a,n.则a^{\phi(n)}≡1 (\mod n)$，而a在模n意义下存在逆元的充要条件就是a,n互质，从而得到推论：若a的逆元存在，则为$a^{\Phi(n)-1}$。</li>
<li>Discrete Logarithms (模p意义下的)离散对数 对已知质数p，在模p意义下存在唯一一个primitive root $r$ 原始根，使得$r^n$取遍所有模p意义下所有非零数。 对任意$a\in [1,p-1]$，若有$r^e≡a(\mod p), e \in [1, p-1]$ ，则即$\log_r a=e$</li>
<li>求discrete logarithms $\log_r a$(模质数p意义下)没有找到多项式时间的算法。这个问题是密码学的一部分。</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程实战</title>
    <url>/2021/11/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="开坑，强力更新中"><a href="#开坑，强力更新中" class="headerlink" title="开坑，强力更新中"></a>开坑，强力更新中</h2><blockquote>
<p>我咕了，原因：在学习网络并发的时候迷恋<code>线程池</code>，既然玩就玩大的，直接猛攻<code>C++20 协程线程池</code>，于是现在在苦学协程……</p>
</blockquote>
<span id="more"></span>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://chenshuo.com/practical-network-programming/">chenshuo.com/pnp</a></li>
<li><a href="https://www.bilibili.com/video/BV1TA411q75p">陈硕-网络编程实战(TCP/UDP/Socket)</a></li>
<li>原来的 <a href="http://boolan.com/course/10093">Boolan 博览课</a>已经 404</li>
</ul>
<h2 id="如何保证可靠的-TCP-连接"><a href="#如何保证可靠的-TCP-连接" class="headerlink" title="如何保证可靠的 TCP 连接"></a>如何保证可靠的 TCP 连接</h2><h3 id="发送比接收更难"><a href="#发送比接收更难" class="headerlink" title="发送比接收更难"></a>发送比接收更难</h3><ul>
<li>按难度排序：<ol>
<li>服务器建立 TCP &lt; 客户端建立 TCP &lt; 销毁 TCP</li>
<li>接收 TCP 数据 &lt; 发送 TCP 数据 （尤其在非阻塞 IO 中）</li>
</ol>
</li>
<li>常见错误：<code>send()</code>+<code>close()</code> 导致丢数据<ul>
<li>如果接收缓冲区里有数据，<code>close()</code> 会导致 RST 段（而不是 FIN 段）强行断连，不论发送缓冲区是否为空，导致对方丢数据。</li>
<li><code>SO_LINGER</code> 不能解决这个问题。</li>
<li>正确发送端做法：<code>send()</code>+<code>shutdown_write()</code>+<code>read_until_eof()</code>+<code>close()</code></li>
<li>正确接收端做法：<code>read() -&gt; 0</code> + nothing to send + <code>close()</code></li>
<li>再考虑服务器防御：<code>shutdown_write()</code> 后设置超时，无论如何都关闭连接。</li>
<li>更好的做法是在协议中包含数据长度，使 App 能够判断数据是否完整。</li>
<li>还有一点漏洞：sender 无法保证 receiver 已经正确处理数据，例如 receiver 崩溃时，sender 也会读到 eof。</li>
</ul>
</li>
</ul>
<h3 id="启用-SO-REUSEADDR"><a href="#启用-SO-REUSEADDR" class="headerlink" title="启用 SO_REUSEADDR"></a>启用 SO_REUSEADDR</h3><ul>
<li>允许重复监听同一个端口<ul>
<li>以便 server 崩溃之后可以立即重启</li>
<li>以便多进程 server 监听同一个端口</li>
</ul>
</li>
</ul>
<h3 id="在-Server-中处理-SIGPIPE-信号"><a href="#在-Server-中处理-SIGPIPE-信号" class="headerlink" title="在 Server 中处理 SIGPIPE 信号"></a>在 Server 中处理 SIGPIPE 信号</h3><ul>
<li>在 Linux I/O 中，若输出管道已经关闭，则 writer 会收到 SIGPIPE 信号。默认的反应行为是中止进程。</li>
<li>默认行为在多数场景下十分好用，可以提前结束工作流，减少 CPU 浪费。  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gunzip -c huge.log.gz <span class="token operator">|</span> <span class="token function">grep</span> ERROR <span class="token operator">|</span> <span class="token function">head</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
然而在网络编程中，若 Client 已经关闭，则 Server 同样会收到 SIGPIPE 信号。</li>
<li>Server 应当小心处理 SIGPIPE 信号，以防 Client 出错或者恶意响应。</li>
<li>若直接忽略 SIGPIPE 信号，则应当检查<code>printf()</code>的返回值，在出错时<code>exit()</code>。</li>
</ul>
<h3 id="Nagle-算法-TCP-NODELAY"><a href="#Nagle-算法-TCP-NODELAY" class="headerlink" title="Nagle 算法, TCP_NODELAY"></a>Nagle 算法, TCP_NODELAY</h3><ul>
<li>影响「请求-响应」型协议。</li>
<li>如果有报文段未收到 ack，<code>write()</code> 就不会发送数据，避免应用层太拉发太多小数据。</li>
<li>对于「写-写-读」模式，第二次写会被延迟一个 RTT(Round-Trip Time, 往返延迟)。<ul>
<li>解决办法：应用层缓冲，改成「写-读」模式</li>
<li>然而难以解决并发请求问题</li>
</ul>
</li>
<li>应当考虑关闭 Nagle 算法<ul>
<li>Go 语言就是这么干的</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>并发编程</tag>
        <tag>C++</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>识趣</title>
    <url>/2019/04/07/%E8%AF%86%E8%B6%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="换底公式"><a href="#换底公式" class="headerlink" title="换底公式"></a>换底公式</h3><p>$\log_ab = \frac{\ln b}{\ln a}$</p>
<blockquote>
<p>证明：<br>$e^{\ln a * \log_an} = b$ 两边取对数，移项。</p>
</blockquote>
<p>$A^{\log_bC} = C^{\log_bA}$</p>
<blockquote>
<p>证明：两边取对数，得$\log_bC \ln A = \frac{\ln C}{\ln b}*\ln A$</p>
</blockquote>
<h3 id="分治的时间复杂度"><a href="#分治的时间复杂度" class="headerlink" title="分治的时间复杂度"></a>分治的时间复杂度</h3><p>$T(N) = aT(N/b) + \Theta(N^k \log_p N)$</p>
<p>$$<br>T(N) = \begin{cases}<br>O(N^{\log_b a})&amp; \text{if }a &gt; b^k \<br>O(N^k \log_{p+1} N)&amp; \text{if }a = b^k \<br>O(N^k \log_{p} N)&amp; \text{if }a &lt; b^k \<br>\end{cases}<br>$$</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><h4 id="sin-cos-tan知一求二"><a href="#sin-cos-tan知一求二" class="headerlink" title="sin,cos,tan知一求二"></a>sin,cos,tan知一求二</h4><p>试试$(\tan^2x)^{(-1)^k}+1 = ?$</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 语法笔记</title>
    <url>/2021/05/03/C/</url>
    <content><![CDATA[<p>本文始于 2018/6/27，用于汇聚关于 C++ 的实用知识和碰到的坑，温故而知新。</p>
<blockquote>
<p>2021/11/18 【新增】引用限定成员函数</p>
<p>下次更新：</p>
<ol>
<li><code>if constexpr</code> 在声明和具体化时期的不同表现</li>
<li><code>coroutine</code>：性能神器</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h2><ul>
<li>union可匿名，常在结构定义中。</li>
<li>用于节省内存，尤其在嵌入式系统中。</li>
<li>union的定义形式与struct相同。</li>
</ul>
<h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum 枚举"></a>enum 枚举</h2><ul>
<li>enum A {a,b,c};   首项默认为0，默认后项比前项大一。<br>A被看做一种类型，甚至可以省略；a,c,b被看做常量。<br>a,b,c可以自动提升为int, 但int不能自动转换为枚举类型，除非强制转换A（1）。<br>每个enum根据其常量的最大最小值确定其上下限。</li>
<li>enum创建的常量是静态的, 可以用作静态类成员常量. 运行时所有对象不会包含枚举</li>
<li><strong>更强的安全性--类作用域内枚举(C++11)</strong><ul>
<li>enum class name : type {...};</li>
<li>enum struct name {...};</li>
<li>class或struct二选一, <code>:type</code>可选.</li>
<li>作用域内枚举不允许隐式地转换为整型</li>
<li>默认底层为int</li>
<li>调用格式为name::x</li>
</ul>
</li>
<li>:type 放在枚举名后以指定底层, 否则将随实现而异.</li>
</ul>
<h2 id="char-字符型"><a href="#char-字符型" class="headerlink" title="char 字符型"></a>char 字符型</h2><ul>
<li>char类型被输入输出流区别对待。cout &lt;&lt; (int*) st &lt;&lt; endl;</li>
<li>char类型数组的初始化被C++区别对待：<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> 合法<span class="token punctuation">,</span><span class="token string">"abcd"</span>被转换为<span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> 可供修改
<span class="token keyword">char</span> s2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">;</span> 错误，即使s1是<span class="token keyword">const</span>。
<span class="token keyword">char</span><span class="token operator">*</span> s3 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> 警告<span class="token punctuation">,</span> <span class="token string">"abcd"</span>是常量<span class="token punctuation">,</span>不能修改<span class="token punctuation">.</span>   参数<span class="token keyword">char</span> s3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"abcd"</span>亦等价警告<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><code>const char []</code>所定义的字符串被保护，有内存位置隔离，不允许跟踪（但允许查看）地址。</li>
<li>char是否带符号取决于系统。</li>
<li>wchar_t可以表示系统使用的最大扩展字符集，输入输出用wcin,wcout</li>
<li>raw r&quot;(a/b\c回车defg*)&quot;,   标识符  &quot;(   )&quot;  可变为 &quot;*@(  )*@&quot; 等等，保持平移对称</li>
</ul>
<h3 id="lt-cstring-gt-常用函数"><a href="#lt-cstring-gt-常用函数" class="headerlink" title="&lt;cstring&gt;常用函数"></a>&lt;cstring&gt;常用函数</h3><ul>
<li><code>char* strcpy(char* dest, const char* src)</code><ul>
<li>以src覆盖dest, 直到遇到src的终止符.返回dest.</li>
</ul>
</li>
<li><code>char* strncpy(char* dest, const char* src, size_t count)</code><ul>
<li>以src的前n位覆盖dest, 若遇到src的终止符则用0填充剩余位.返回dest.</li>
</ul>
</li>
<li><code>char* strcat(char *dest, char *src)</code><ul>
<li>将src复制到dest的末尾.返回dest.</li>
</ul>
</li>
<li><code>int strcmp(char *str1, char *str2)</code><ul>
<li>按字典序比较, 返回-1,0,1.</li>
</ul>
</li>
<li><code>int stricmp(char *str1, char *str2)</code><ul>
<li>按字典序但对大小写不敏感比较.</li>
</ul>
</li>
<li><code>int strncmp(char *str1, char *str2, size_t count)</code><ul>
<li>按字典序比较前n位</li>
</ul>
</li>
<li><code>int strnicmp(char *str1, char *str2, size_t count)</code><ul>
<li>按字典序但对大小写不敏感比较前n位</li>
</ul>
</li>
</ul>
<h2 id="vector与array-模板类"><a href="#vector与array-模板类" class="headerlink" title="vector与array 模板类"></a>vector与array 模板类</h2><ul>
<li><code>vector&lt;typename&gt; arr(n_elem);</code> 也可以不指定长度</li>
<li><code>array&lt;typename, n_elem&gt; arr;</code> 定长数组。 等长数组可以直接复制。</li>
<li>下标可越界，欲防止越界用 <code>arr.at(x)</code></li>
</ul>
<h2 id="读入行"><a href="#读入行" class="headerlink" title="读入行"></a>读入行</h2><ul>
<li><code>cin.getline(arr, arsize)</code> 空行不设置failbit</li>
<li><code>cin.get(arr, arsize)</code> 行读取结束后不丢弃换行符（无法跨越）</li>
<li><code>cin.get()</code> 读取一个任意字符，返回char值</li>
<li><code>cin.get(char)</code>返回cin</li>
<li><code>string</code>类读行 <code>getline(cin, str);</code></li>
</ul>
<h2 id="fstream-文件流（以fin-fout为例）"><a href="#fstream-文件流（以fin-fout为例）" class="headerlink" title="fstream 文件流（以fin, fout为例）"></a>fstream 文件流（以fin, fout为例）</h2><ul>
<li>打开文件： <code>.open(&quot;filename&quot;);</code></li>
<li>关闭文件： <code>.close();</code></li>
<li>检测最后一次读入遇到EOF： <code>fin.eof();</code></li>
<li>检测最后一次读入遇到类型不匹配（包括EOF）： <code>fin.fail();</code></li>
<li>检测最后一次读入文件损坏、故障： <code>fin.bad();</code></li>
<li>检测最后一次读入完全正常： <code>fin.good();</code>  等价于 <code>(bool) fin &gt;&gt; value;</code></li>
<li>清空错误标记，准许读入： <code>.clear();</code></li>
</ul>
<h2 id="switch-结构控制"><a href="#switch-结构控制" class="headerlink" title="switch 结构控制"></a>switch 结构控制</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> constValue1 <span class="token operator">:</span> statement1
            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span>

    <span class="token keyword">case</span> constValue2 <span class="token operator">:</span> statement2
            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span>

    <span class="token keyword">default</span> <span class="token operator">:</span> statement3
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><code>exit(EXIT_FAILURE);</code>   ： cstdlib, 同操作系统通信的参数值</li>
<li><code>nullptr</code> : C++11 关键字, 空指针值.</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>应当将空指针写为<code>nullptr</code>. <code>delete</code>和<code>delete []</code> 都可以作用于空指针.</li>
<li>const 指针 将受保护，非const 指针 不能复制其值（除非利用强制类型转换），不允许通过const 指针 修改所指向值。<br>为了防止欺骗const检查，不允许令const 二级指针指向非const 一级指针</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>声明：<code>typename (*pointer name)(parameter list...);</code></li>
<li>获得某函数的地址：<code>pointer = function name;</code></li>
<li>使用函数指针：<code>(*pointer)(parameter list...);</code>  或  <code>pointer(parameter list...);</code></li>
<li>举例：  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">原函数：

<span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

指向f1的指针：

<span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> f1<span class="token punctuation">;</span> 或 <span class="token keyword">auto</span> p1 <span class="token operator">=</span> f1<span class="token punctuation">;</span>

由f1<span class="token punctuation">,</span>f2<span class="token punctuation">,</span>f3组成数组：<span class="token comment">//[]优先级高于*</span>

<span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>ar<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 不允许<span class="token keyword">auto</span>

指向ar<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>的指针：

<span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>arp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>ar<span class="token punctuation">;</span> 或 <span class="token keyword">auto</span> arp <span class="token operator">=</span> <span class="token operator">&amp;</span>ar；

还可以用<span class="token keyword">typedef</span>简化声明：

<span class="token keyword">typedef</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>p_fun<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p_fun ar<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>分析方法: 从变量名开始, 往右往左结合, 逐步解释结合体.<ul>
<li>当遇到一个指针, 总是关心它指向什么类型</li>
<li>当遇到一个数组, 总是关心它的元素的类型</li>
<li>当遇到一个函数, 总是关心它的返回值类型</li>
</ul>
</li>
</ul>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>参量（argument）是实参，参数（parameter）是形参。</li>
</ul>
<h2 id="函数重载（函数多态）"><a href="#函数重载（函数多态）" class="headerlink" title="函数重载（函数多态）"></a>函数重载（函数多态）</h2><ul>
<li>同名函数共存要求：函数特征标（函数参数列表）不同。</li>
<li>当需要自动类型转换但选项不唯一时，编译不通过。</li>
<li>不区分const和非const变量（包括指针）。</li>
<li>区分指向const的指针和指向非const的指针。</li>
<li>区分指向const的引用和指向非const的引用。（编译器调用最匹配的版本）</li>
<li>如果没有右值引用参数版本，右值参量将赋给const引用参量。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>左值引用<ul>
<li>非const引用可以引自可修改的左值（防止修改const值和修改临时变量）</li>
<li>const引用可以引自任何左值、右值（毕竟数值不会变）</li>
<li>基类引用可以指向派生类对象</li>
</ul>
</li>
<li>指针也能被引用, 例如 int*&amp; x = ptr;</li>
</ul>
<h2 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h2><ul>
<li>||, &amp;&amp;具有短路作用,结果必然时短路,不计算右边的表达式</li>
</ul>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><ul>
<li>在声明时用或在第一次调用前的定义用都行</li>
<li>不能处理递归, 编译器有权拒绝采用.</li>
<li>函数默认值必须放在原型声明中, 不能放在和声明分离的定义中.只能从右到左地提供默认值</li>
</ul>
<h2 id="decltype-expression"><a href="#decltype-expression" class="headerlink" title="decltype(expression)"></a>decltype(expression)</h2><ul>
<li><p><strong>decltype(expression)核对表</strong></p>
<ol>
<li>如果expression是一个不带括号的标识符, 则返回相同类型, 包括const,*等限定符</li>
<li>否则,如果expression是一个函数调用(需要提供参数),则返回相同类型</li>
<li>否则,如果expression是一个带括号的左值,则返回其引用</li>
<li>否则,返回expression的类型(例:右值)</li>
</ol>
</li>
<li><p>可以利用<strong>typedef</strong> decltype(expression) somename;简化声明</p>
</li>
<li><p><strong>decltype 用于函数返回类型声明</strong></p>
<ul>
<li>声明返回类型时未知参数列表, 所以需要后置声明  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">gt</span><span class="token punctuation">(</span>T1 x<span class="token punctuation">,</span> T2 y<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>     <span class="token comment">// "-> 已知类型"  也行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><strong>创建模板</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token comment">//也可以用class代替typename</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<ul>
<li><p><strong>显式具体化</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">void</span> swap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  <em>为什么需要显示具体化?常规函数不能替代吗?</em></p>
</li>
<li><p><strong>显式实例化</strong></p>
<ul>
<li>不使用函数就能依照模板生成实例, 常用在库中</li>
<li><code>template void swap&lt;int&gt;(int&amp;, int&amp;);</code></li>
<li>使用函数时<code>add&lt;double&gt;((int)a, (double)b);</code> 会强制使用<double>模板.注意引用类型不能隐式类型转换.后续的强制使用仍需加&lt;double&gt;</li>
</ul>
</li>
</ul>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="::变量名"></a>::变量名</h2><ul>
<li>表明采用全局变量而非局部变量</li>
</ul>
<h2 id="储存空间"><a href="#储存空间" class="headerlink" title="储存空间"></a>储存空间</h2><ol>
<li>静态储存: 保证初始化为0, 生命周期和程序相同.</li>
<li>自动储存(栈内存): 不保证初始化;</li>
<li>动态储存(堆内存): 不保证初始化;</li>
</ol>
<h2 id="储存说明符"><a href="#储存说明符" class="headerlink" title="储存说明符"></a>储存说明符</h2><ul>
<li>static用于变量   <em>编译阶段尽量初始化, 运行时直接分配空间,程序结束时销毁, 首次遇到时再保证初始化</em><ul>
<li>静态外部链接性变量: 直接在非被包括区域定义, 在其他单元中可用extern引用声明(不允许再次初始化)(ODR单定义规则)</li>
<li>静态内部链接性变量: 在非被包括区域加static, 限定在本单元内可以访问</li>
<li>静态无链接性变量:在被包括区域加static, 限定在本包括区域内可以访问</li>
</ul>
</li>
<li>static用于函数 覆盖函数的默认外部链接性为内部链接性,必须同时用于原型和定义中.</li>
<li>thread_local 变量持续性与所属线程的持续性相同, 可与static, extern结合使用(其他声明中不能使用多个储存说明符)</li>
<li>mutable 使得const对象中的属性能被修改,而不受const限制</li>
<li>register C++11之前是寄存器变量,不能取地址;  之后是显式指明自动变量(无实际作用,避免旧代码非法)</li>
</ul>
<h2 id="显式指出语言链接性以帮助链接程序寻找匹配函数"><a href="#显式指出语言链接性以帮助链接程序寻找匹配函数" class="headerlink" title="显式指出语言链接性以帮助链接程序寻找匹配函数:"></a>显式指出语言链接性以帮助链接程序寻找匹配函数:</h2><pre><code>extern &quot;C&quot; void spiff(int);
</code></pre>
<h2 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv-限定符"></a>cv-限定符</h2><pre><code>- const全局变量带有隐式static使得变量链接性为内部, 导致多文件同时include一个头文件时不会发生定义冲突 *可以使用extern覆盖隐式static使变量链接性为外部. 在其他单元中仍需用extern来引用它.*
- volatile 提示编译器该变量会在程序之外被修改, 不要进行寄存器缓存优化.
</code></pre>
<h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><ul>
<li>原函数:  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new int[40] --> new(40*sizeof(int))</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>new, delete函数可以替换.</li>
<li>new在堆中查找满足要求的内存块</li>
<li>定位new运算符<ul>
<li><code>typename* p = new (MemAddress) typename</code></li>
<li>返回(void *)指定的内存地址</li>
<li>允许重载</li>
<li><strong>注意非堆内存不可delete</strong></li>
<li><strong>若内存中存放了对象，则需要手动调用析构函数，再由MemAddress释放内存，且需注意new []与delete []对应</strong></li>
</ul>
</li>
<li>元素的创建与销毁应遵循FILO顺序</li>
</ul>
<h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><ul>
<li>声明区域: 可以声明变量的区域, 例如所在的文件, 代码块.</li>
<li>潜在作用域: 从声明点开始到声明区域的结尾. 可能被局部变量隐藏,故称潜在.</li>
<li>自定义名称空间:<code>namespace Somewhat &#123;...&#125;</code><ul>
<li>只能在函数外部定义, 允许在另一个名称空间中嵌套</li>
<li>因此, 默认情况下声明的名称的链接性为外部(除非它引用了常量)</li>
<li>可以在其他合法位置继续添加名称, 提供定义.</li>
</ul>
</li>
<li><code>using namespace Somewhat;</code>编译指令<ul>
<li>每个声明区域中都有一条隐式的<code>using namespace 全局名称空间;</code></li>
<li>若某处使用过<code>using namespace</code>编译指令,则其子声明区域也隐式添加这条语句.</li>
<li>局部变量拥有最高优先权,能隐藏各种using namespace同名变量(因为名称空间都在函数外部定义)</li>
</ul>
</li>
<li><code>using</code>声明<ul>
<li>类似于声明了一个局部变量, 在代码块中不允许同级同名.</li>
<li>因此使用using声明比使用using编译指令更安全.</li>
</ul>
</li>
<li>名称空间可以拥有别名, 用于简化代码: namespace MEF = myth::elements::fire;</li>
<li>名称空间可以匿名, 声明之后自动隐式using, 用于避免其他using并替代static全局变量.</li>
<li>&lt;.h&gt;文件是不支持名称空间的版本.新版一般将函数搬到std中.</li>
<li>使用建议: 在大型程序/多单元程序使用<ul>
<li>少用<code>using namespace</code></li>
<li>避免在头文件中使用using编译指令,若必须使用,则在所有#include之后使用</li>
<li>避免直接声明外部全局变量和静态全局变量,改用已命名的名称空间</li>
<li>using声明首选用在局部而不是全局</li>
</ul>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>构造函数<ul>
<li>调用示例:  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Classname object<span class="token punctuation">;</span> <span class="token comment">// 调用空参数构造函数</span>
Classname <span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 警告, 正在声明函数</span>
Classname <span class="token function">object</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span> two<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用对应的构造函数</span>
Classname object <span class="token operator">=</span> <span class="token function">Classname</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有可能先构造临时对象</span>
Classname<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Classname</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Classname object<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> Classname object <span class="token operator">=</span> Classname<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// C++11</span>
Classname<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> Classname<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// C++11</span>
Classname object <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// 调用一个参数的构造函数, 可用explicit(修饰构造函数)关闭这种特性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>重载构造函数中使用的new或new []必须对应，因为析构函数只有一个。</li>
<li>初始化列表<ul>
<li>参数列表后由冒号引出的初始化信息。在此初始化对象将使用复制构造函数，而不是空构造函数加赋值运算符，因此效率更高。</li>
<li>初始化的顺序按照成员变量的声明顺序，而与初始化列表顺序无关。</li>
<li>一旦进入花括号，成员变量将完成默认的初始化，对象初步创建完成。因此，成员变量中，非静态常量与引用必须由此列表进行初始化。</li>
<li>类内初始化可等价于默认的列表初始化。列表初始化会覆盖类内初始化。</li>
<li>初始化列表负责调用基类构造函数（基类已在派生类类域中，无需加作用域解析符）</li>
<li>初始化列表负责调用成员对象的非默认构造函数</li>
</ul>
</li>
<li>默认不能继承构造函数（C++11）</li>
</ul>
</li>
<li>析构函数<ul>
<li>只能有一个析构函数, 且参数必须为空</li>
<li>注意用delete对应构造函数或其他过程的new</li>
<li>若对象由定位new运算符创建，则需要手动调用析构函数，且遵循FILO顺序。</li>
<li>必须以delete或delete []对应构造函数中的new或new []。</li>
<li>最后会自动调用基类的析构函数</li>
<li>应当将析构函数声明为虚函数</li>
<li>不能继承析构函数</li>
</ul>
</li>
<li>封装是一个编译期的概念<ul>
<li>编译期不存在实例，编译器仅针对类型做检查</li>
<li>可以在类方法中访问同类对象的私有成员</li>
</ul>
</li>
<li><em>同struct</em> : 避免环形构造<ul>
<li>编译器禁用简单环形定义, 如 <code> struct A &#123; A a; &#125;; // 使用了未完成的定义</code></li>
<li>编译器不能辨别复杂环形定义, 如<code>struct A &#123; A()&#123;&#125; A* a = new A(); &#125;</code></li>
</ul>
</li>
<li>非静态变量在运行时才会创建, 所以如int arr[MAXN]的MAXN必须是静态量,可以是全局const, 类中static const, enum{MAXN=x}.</li>
<li>友元函数<ul>
<li>在共有部分声明友元函数原型, 也可以紧接定义以设为内联函数.后置的定义无需friend修饰</li>
<li>友元函数视为类外函数, 但可以访问类私有成员变量.</li>
<li>类的显式二元重载运算符应当用友元, 尽管没有直接修改类私有成员变量</li>
<li>重载&lt;&lt; : <code>std::ostream&amp; operator &lt;&lt; (const std::ostream&amp; os, const Classname&amp; obj)</code>以方便输出.</li>
<li>友元函数可方便隐式类型转换, 不必苛求由对象发起函数调用.例如cmp(&quot;asd&quot;, obj),可以对应原型cmp(string, string);</li>
<li>可以在派生类友元函数中，强制向上转型并使用基类友元函<br>数据类型, 否则易有二义性<br>函数, 避免隐式转换出错<br>ass_name&amp;)`<br>始化、按值传递、按值返回、上转型并使用基类友元函数。</li>
</ul>
</li>
<li>转换函数<code>operator typeName()</code><ul>
<li>用途:将类转换成基础数据类型</li>
<li>必须是成员方法</li>
<li>不能指定返回类型</li>
<li>不能有参数</li>
<li>用于cout时应显式标明类型</li>
<li>应当用explicit修饰</li>
</ul>
</li>
<li>复制构造函数<code>Class_name(const Class_name&amp;)</code><ul>
<li>在初始化对象时使用(显示的初始化、按值传递、按值返回、编译器生成临时对象)</li>
<li><strong>新版本C++可用移动构造函数</strong></li>
<li>例:  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Class_name <span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
Class_name<span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Class_name</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
Class_name a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 可能生成临时对象后调用赋值运算符函数,根据实现而异.</span>
Class_name a <span class="token operator">=</span> <span class="token function">Class_name</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同上</span>
按值传递函数调用<span class="token function">func</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按值传递也初始化了参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>默认的复制构造函数，是在初始化列表中调用所有成员的复制构造函数。默认复制派生类对象的基类部分</li>
<li>应注意<strong>深度复制</strong>, 即妥善处理指针所指向内容的复制</li>
</ul>
</li>
<li>赋值运算符函数<ul>
<li>考虑妥善处理原来已有的,即将被抛弃的数据.</li>
<li>考虑自己赋值给自己的情况, 小心赋值前删除了自身数据.</li>
<li>记住返回自身引用, 即 <code>return *this</code></li>
<li>不能继承赋值运算符函数</li>
<li>不建议设置为虚方法，为了避免同基类的不同派生类互相赋值</li>
</ul>
</li>
<li>默认方法的潜在危险<ul>
<li>某个类在开发初期不需要复制构造函数/赋值运算符重载，但在以后可能需要</li>
<li>可能写出符合常理的代码，但由于未覆盖默认方法而运行时异常</li>
<li>可能在未察觉的情况下调用了默认方法（用重载加法时按值传递、按值返回将调用复制构造函数）</li>
<li>解决办法：<ul>
<li>不管默认方法是否需要，总是提供正确的代码</li>
<li>将空方法设为private，并留下错误信息</li>
<li>使用delete（C++11）</li>
</ul>
</li>
</ul>
</li>
<li><code>[ ]</code>(取位)运算符: 两个操作数分立于左中括号两侧。只能是成员函数。</li>
<li>const对象<ul>
<li>只能使用const函数, 若返回引用, 则返回类型为const type&amp;</li>
</ul>
</li>
<li>静态类成员函数<ul>
<li>原型含static, 定义不含</li>
<li>和Java不同, 不能通过对象来调用静态成员函数</li>
<li>调用格式 <code>Class_name::s_method();</code></li>
</ul>
</li>
<li>静态类成员变量<ul>
<li>在类中声明, 不可定义</li>
<li>在类外定义并分配内存, 可以不初始化</li>
<li>静态常量在声明同时定义.</li>
</ul>
</li>
<li>派生/继承<ul>
<li><code>class newClass : public baseClase</code></li>
<li>默认继承为private继承。私有继承的向上转型必须显式写出</li>
<li>多重继承的向上转型也应显示写出，以防不同基类的方法冲突</li>
<li>派生类中一旦定义某方法与基类方法同名，则基类所有该名方法被隐藏。与参数列表（特征标）无关。<ul>
<li>可用基类名::方法名的途径调用隐藏的方法</li>
<li>重新定义继承的方法，应确保与原来的原型完全相同</li>
<li>若返回类型为基类引用或指针，则可以修改为派生类的引用或指针（返回类型协变）</li>
<li>若基类虚方法被重载了，则应在派生类中重新定义所有的基类版本</li>
</ul>
</li>
<li>若派生类构造函数使用了new，则应提供复制构造函数/赋值运算符（含<code>base::operator=(o);</code>）/虚析构函数的定义</li>
<li>公有继承表达了is-a关系，私有继承/包含表达了has-a关系。通常使用组合包含层次化来建立has-a关系。如果需要访问原有类的保护成员或重新定义虚方法，才使用私有继承。</li>
<li>欲调用基类对象，对(*this)强制向上转型(const Base &amp;)即可</li>
<li>用using改变继承成员权限：在派生类的public处<code>using Base::methodName;</code>(省略using的技术是即将被抛弃的旧技术)</li>
</ul>
</li>
<li>虚方法<ul>
<li>若希望通过基类引用或指针调用派生类方法，则需要将基类方法声明为virtual虚方法（一般也将派生类方法声明为virtual）</li>
<li>应当将析构函数定义为虚方法，以确保正确地销毁对象</li>
<li>在类中欲调用基类方法(而不是本类方法)，需使用作用域解析符<code>Base::baseMethod();</code></li>
<li>编译器对虚方法的一般实现：把类的所有虚函数的地址制作成表，在对象中添加隐藏的虚函数表指针，在运行时通过指针检索虚函数。</li>
<li>与Java不同，派生类虚方法的访问权限允许变严格，但由基类引用或指针的多态效果仍然生效。</li>
<li>派生类中一旦定义虚方法，就将隐藏基类所有同名方法，故应在派生类中重新定义所有的基类重载方法</li>
<li>可以令虚方法声明结尾处为<code>=0</code>，使方法成为纯虚方法。纯虚方法可以不提供定义。含有至少一个纯虚方法的类为抽象类，不能声明对象。</li>
</ul>
</li>
<li>访问权限<ul>
<li>private：仅本类和友元函数有权访问。对数据成员的理想访问控制。</li>
<li>protected：本类和派生类有权访问。在派生链中，此权限类似public；在类外部，此权限类似peivate。此权限通常只给成员函数。</li>
<li>public：在同一域中就能访问。</li>
</ul>
</li>
<li>引用限定成员函数<ul>
<li>函数签名的最后可以标注<code>&amp;</code>或<code>&amp;&amp;</code>来做「引用限定 ref-qualified」。<ol>
<li>非限定成员函数可由左值调用，也可由右值调用。此时不能再定义引用限定成员函数。</li>
<li>左值限定成员函数仅可由左值调用。</li>
<li>右值限定成员函数仅可由右值调用。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda是一种匿名函数，它在普通函数的基础上增加了一些功能。Lambda是通过函数对象实现的，具有在编译器内联的能力，因此性能可以比函数指针更好。</p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> q <span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 常见的比较函数</span>
<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> mask <span class="token operator">&amp;</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 判断有无交集</span>
<span class="token punctuation">[</span><span class="token operator">&amp;</span>flag<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> flag<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 修改自动变量flag数组</span>
<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 按引用捕获当前作用域的全部自动变量。不是简单地return故要声明类型</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> mx<span class="token punctuation">)</span> mx <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tot <span class="token operator">+=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">[</span>k<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> del<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 按值捕获k、按引用捕获其他变量</span>
    sth <span class="token operator">+=</span> del<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// k是只读的？？！！</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>rvalue,（非严格定义: ）匿名的临时值，常出现在等号的右方。最大特征是不可取地址，例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// (2+3) 就是一个右值， &amp;(2+3)没有意义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>有时候运算过程中会生成一些体积大的临时对象，在完成表达式后这些临时对象会析构，例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyString</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token comment">//... 使用new和delete的模仿string类，具有拷贝构造函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>MyString<span class="token operator">></span> arr<span class="token punctuation">;</span> arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保留10个string的空间</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">MyString</span><span class="token punctuation">(</span><span class="token string">"Hello_rvalue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第8行发生如下事件：</p>
<ol>
<li>MyString(&quot;Hello_rvalue&quot;) 产生一个右值。</li>
<li>push_back接收一个右值参数，并调用MyString的<strong>拷贝构造函数</strong>新建一个对象。</li>
<li>MyString(&quot;Hello_rvalue&quot;)生命周期结束，析构。</li>
</ol>
<p>发现拷贝构造函数存在资源浪费：既然右值的资源已经没有后续价值，大可以将其资源“偷”过来使用。</p>
<p>于是，MyString类新增<strong>移动构造函数</strong>（还有<strong>移动赋值函数</strong>）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyString</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// ... 同上</span>
  <span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token operator">-></span>data<span class="token punctuation">;</span>
    x<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 资源被偷走</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">&#125;</span>
  
  MyString<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 类似移动构造函数，不赘述</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如此一来，push_back将自动调用移动构造函数来创建对象，避免大量new内存。</p>
<p>右值引用的存在，就是为了<strong>尽量榨干临时对象的价值</strong>。</p>
<p>要利用右值引用，最重要的是<strong>合理地定义移动构造和移动赋值</strong>。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>有时候一些左值就像右值一样即将消亡，弃之可惜，例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  string <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp <span class="token operator">+=</span> <span class="token string">" rvalue?"</span><span class="token punctuation">;</span> <span class="token comment">// tmp经过一系列复杂的处理</span>
  arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果能像右值引用一般把tmp的资源“偷”走就好了，于是</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  string <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp <span class="token operator">+=</span> <span class="token string">" rvalue?"</span><span class="token punctuation">;</span> <span class="token comment">// tmp经过一系列复杂的处理</span>
  arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 强制转换为右值</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，move(tmp)后由于资源已经被偷走，tmp可能像野指针一样危险。被move后对象的行为由程序员负责。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是针对c++模板函数的概念。</p>
<p>我们不得不先介绍c++引用折叠概念：</p>
<table>
<thead>
<tr>
<th>typename T</th>
<th>T&amp;</th>
<th>T&amp;&amp;</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>G&amp;</td>
<td>G&amp;&amp;</td>
</tr>
<tr>
<td>G&amp;</td>
<td>G&amp;</td>
<td><strong>G&amp;</strong></td>
</tr>
<tr>
<td>G&amp;&amp;</td>
<td><strong>G&amp;</strong></td>
<td>G&amp;&amp;</td>
</tr>
</tbody></table>
<p>模板函数的右值引用具有欺骗性！在模板实例化时，<code>T&amp; &amp;&amp;</code> 和<code>T&amp;&amp; &amp;</code>都会被转换为<code>T&amp;</code>。只有<code>T&amp;&amp; &amp;&amp;</code>会成为<code>T&amp;&amp;</code>。利用这一点，我们可只定义<code>T&amp;&amp;</code>的函数行为。</p>
<p><em>（对于简单的情况，<code>T &amp;&amp;</code> 等价于 <code>T&amp;&amp; </code>）</em></p>
<p>但此时也出现了另一个问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">f2</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// do something</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们希望，若f1接收左值，那么f2也应该接收左值；如果f1接收右值，那么f2也应该接收右值。但c++规定，“右值引用”是一个左值，因为它有名字，还可以取地址。在这里，f2无论如何都会接收左值。怎样才能写出自动接收左右值的模板函数呢？</p>
<p>利用<strong>任意表达式都能生成匿名值</strong>，最简单的，就像<code>static_cast&lt;T&amp;&amp;&gt;(x1)</code>，此时表达式的结果可以转化为右值。再加上引用折叠的特性，就是<code>std::forward</code>的基本原理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// T可以是scalar,object,lref。 但不可能是rref！</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 实现了左值转发为左值，右值转发为右值。</span>
  <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不能依赖C++17的自动推导，因为x1总是lref！</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 附：std的实现</span>
<span class="token comment">// FUNCTION TEMPLATE forward</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>
_NODISCARD <span class="token keyword">constexpr</span> _Ty<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>
    remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;</span> _Arg<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token comment">// forward an lvalue as either an lvalue or an rvalue</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Ty<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里可能发生引用折叠</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>
_NODISCARD <span class="token keyword">constexpr</span> _Ty<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token comment">// forward an rvalue as an rvalue</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>is_lvalue_reference_v<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">"bad forward call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Ty<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// FUNCTION TEMPLATE move</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>
_NODISCARD <span class="token keyword">constexpr</span> remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Ty<span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token comment">// forward _Arg as movable</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里不可能发生引用折叠</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>捕获异常时，从具体到抽象，最后到<code>...</code>。</li>
<li>如果异常携带字符串信息，则可能引发<code>std::bad_alloc</code>，惊不惊喜！</li>
<li>std定义的异常分类：<code>#include &lt;stdexcept&gt;</code>  <ol>
<li><code>logic_error</code> 逻辑出错。</li>
<li><code>invalid_argument</code> 无效参数。</li>
<li><code>domain_error</code> 值域错误。（继承自<code>logic_error</code>）</li>
<li><code>length_error</code> 试图超越最大体积。（继承自<code>logic_error</code>）</li>
<li><code>out_of_range</code> 试图越界。（继承自<code>logic_error</code>）</li>
<li><code>runtime_error</code> 仅在运行时可知的错误。</li>
<li><code>range_error</code> 计算结果无法用目标类型表示。（继承自<code>runtime_error</code>）</li>
<li><code>overflow_error</code> 算术上溢。（继承自<code>runtime_error</code>）</li>
<li><code>underflow_error</code> 算术下溢。（继承自<code>runtime_error</code>）</li>
<li><code>tx_exception</code> 可用于回滚或取消transaction的异常。（Transactional Memory Technical Specification, TM TS）</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>语法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法笔记</title>
    <url>/2019/10/11/java/</url>
    <content><![CDATA[<p>Since 2018/07/12</p>
<span id="more"></span>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>与C++不同,Java在新建变量时,不允许其名称与其上一级作用域的变量名相同.</li>
<li>若某一时刻某一作用域中,某个名字的变量被销毁,则该名字可以再次使用.</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>整数默认为int, 小数默认为double(8字节), 字面值不能大于类型最大值.</li>
<li>数字可以加后缀指定类型, long为<code>L</code>, double为<code>d</code>, float为<code>f</code>.</li>
<li>缩窄转换会报错,除非强制类型转换(前置括号). 类型提升不会报错(如int-&gt;double)</li>
<li>short是16位有符号类型, char是16位<strong>无符号</strong>类型.</li>
<li>非基础的数据类型只有引用数据类型,像阉割的指针,使用点号时自动解引用.</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><code>int[] array = new int[n];       //    array.length 为数组长度, 越界会报错</code></li>
<li><code>int[] array = new int[] &#123;2, 0, 4, 1&#125;;  //array长度为4, 仅分配内存可初始化</code></li>
<li><code>T[][] array = &#123; &#123;new T(), new T()&#125;,  &#123;new T()&#125; &#125;  //低维长度不定</code></li>
<li><code>int[][] array = new int[n1][];   array[1] = new int[n2]; //低维长度不定</code></li>
<li>凡是new生成的东西都在堆内存中, 只有array作为一个引用存在于栈内存中</li>
<li>与C++不同, 已有数组名(引用)可以赋值给另一个已有数组名(引用), 允许变动.</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//value范围在int内,且不为boolean</span>
<span class="token keyword">case</span> value1<span class="token operator">:</span>
    <span class="token keyword">do</span> sth<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">default</span><span class="token operator">:</span>        <span class="token comment">//default可以放在前面,程序保证入口挑选正确且唯一.</span>
    <span class="token keyword">do</span> sth<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><ul>
<li>类中用<code>&#123;&#125;</code>包裹的代码块，将在每次构造函数调用时执行</li>
<li>构造对象触发的动作：初始化（静态代码块）-&gt;super()-&gt;构造代码块-&gt;构造函数剩余部分</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>构造函数的第一行可以用<code>this(...)</code>调用其它构造函数. 编译器会检测递归构造器调用并报错</li>
<li>编译器保证若有父类,构造方法一定会调用父类构造方法,故<code>this(...)</code>意味着会调用<code>super(....)</code></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>只允许一个父类<code>class Son extends Father &#123;...&#125;</code></li>
<li>当前对象的父类指针为<code>ThisClass.super</code> <strong>?</strong>,</li>
<li>子类的构造函数的第一行都有隐式的<code>super()</code>调用,可以替换为各种显式调用</li>
<li><strong>重写</strong> <em>针对成员方法</em><ul>
<li>继承中当函数名, 参数列表(即特征标)相同时发生重写</li>
<li>访问限制级别必须相同或放宽</li>
<li>若父类函数返回类型为基础类型,则子类重写返回类型必须相同</li>
<li>若父类返回引用类型, 则子类返回相同或其子类类型</li>
<li>重写方法不能抛出新异常, 只可以抛出相同/更少异常</li>
<li>抽象方法必须在具体类中被重写</li>
<li>父类引用指向子类对象时,会动态绑定子类重写函数</li>
</ul>
</li>
<li><strong>隐藏</strong> <em>针对所有成员变量和静态成员方法</em><ul>
<li>成员变量类型可以改变</li>
<li>父类引用指向子类对象时,静态绑定父类被隐藏成员.(由对象调用的静态方法将被翻译为由类调用的静态方法。因此是隐藏而不是重写)</li>
<li>为什么是隐藏？因为子类的构造函数总会调用父类的构造函数。若一个变量被两次修改，可能产生隐患。</li>
</ul>
</li>
<li><strong>向上转型</strong><ul>
<li>成员方法<ol>
<li>   编译时<strong>检查声明类型类</strong>中是否含有被调用的成员方法,而不检查子类对象</li>
<li>   运行时<strong>根据对象</strong>调用最后重写的成员方法,而不依赖与声明类型类</li>
<li>   被重写的方法没有丢失,但仅能通过类方法中super访问.</li>
</ol>
</li>
<li>成员变量<ol>
<li>   编译时<strong>检查声明类型类</strong>中是否含有被访问的成员变量, 而不检查子类对象</li>
<li>   运行时<strong>访问声明类型类</strong>中的成员变量, 而不访问子类对象所重写的</li>
</ol>
</li>
</ul>
</li>
<li><code>instanceof</code><ul>
<li>判断一个对象是否为某个类的实例或是否实现了某个接口.</li>
<li>若判断是否类的实例, 则编译器要求引用类型和类有关联(至少有父子关系)</li>
<li>常用于强制类型转换前.</li>
</ul>
</li>
</ul>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><ul>
<li>静态代码块在程序生命周期中最多执行一次</li>
<li>执行静态代码块的行为叫做<strong>初始化</strong></li>
<li>能触发初始化的动作是<strong>主动引用</strong><ol>
<li>创建类的实例</li>
<li>访问类的静态变量(常量除外, 因为常量在代码中被直接替换, 不会新开内存)</li>
<li>访问类的静态方法</li>
<li>反射</li>
<li>当子类被初始化时, 父类还没初始化, 那么先执行父类初始化</li>
<li>虚拟机启动时, 先初始化含main()定义的类</li>
<li>接口(禁止了static代码块)不要求父类初始化,直到真正引用父接口</li>
</ol>
</li>
<li>不会触发初始化的动作是<strong>被动引用</strong><ol>
<li>子类调用父类静态变量或父类静态方法, 只初始化父类</li>
<li>访问类的常量</li>
<li>声明对象数组(因为声明的是数组头引用和引用数组, 实际不含任何访问)</li>
<li>访问静态内部类的任何组份</li>
</ol>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>final修饰变量: 声明常量, 其内容不可修改<ul>
<li>对于基本数据类型, 其值不可修改</li>
<li>对于引用数据类型, 指向不能更换, 但所指向的内容仍可修改</li>
<li>常量和普通变量一样可以重写/隐藏.</li>
<li>每个对象都包含各自的final变量, 在构造其中初始化</li>
</ul>
</li>
<li>final修饰类: 定义不可被继承类<ul>
<li>一般出于安全性原因才会考虑final修饰类</li>
<li>因为不可被继承, 所以类不可能为abstract, 方法不含abstract</li>
</ul>
</li>
<li>final修饰方法: 定义不可被重写方法</li>
</ul>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><ul>
<li>abstract修饰类: 指明类是抽象类, 不能实例化. 含抽象方法的类必须用abstract修饰.<ul>
<li>抽象类不可能含final方法, 但无其他限制, 可像普通类一样编写.</li>
</ul>
</li>
<li>abstract修饰方法: 指明方法是抽象方法, 原型后加分号, 而不能写方法体.</li>
</ul>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul>
<li>对应关键字 <code>implements</code> 实现</li>
<li>接口是对行为的抽象, 方便描述类的共同行为.</li>
<li>接口的变量默认且仅限于<code>public static final</code>(意味着在接口外能访问)</li>
<li>接口的方法默认且仅限于<code>public abstract</code></li>
<li>新接口可以继承(extends)多个旧接口.</li>
<li>类实现(implements)接口后必须重写接口方法, 否则必须定义为abstract类.</li>
<li>类可以实现多个方法, 即使这些方法有同名常量或同一函数.<ul>
<li>若实现多个方法后有同名常量, 则尝试访问它们时会产生编译时二义性错误.</li>
</ul>
</li>
<li>接口作为一种数据类型, 可以引用, 可以向上转型以实现多态.</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul>
<li>访问不同包中的类需要加上<code>包名.</code>, 或者使用import <code>包名.类名</code>或<code>包名.*</code></li>
<li>包是开放的(可以跨单元). 一个包可拥有多个public类, 但一个单元最多拥有一个public类, 且必须与单元名相同(大小写敏感).</li>
<li>同一包中的类可以互相访问非private成员.</li>
<li>继承另一个包的类后, 继承所得成员所属包不变.</li>
</ul>
<h2 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h2><ul>
<li>类中数据权限修饰符<ol>
<li><code>private</code> : 数据能在本类中访问.</li>
<li><code>(空, 即默认修饰符)</code> : 数据能在同包中访问.</li>
<li><code>protected</code> : 当类为public时有意义, 数据能在包外继承类中访问.</li>
<li><code>public</code> : 当类为public时有意义, 数据能在包外访问.</li>
</ol>
<ul>
<li>同类对象可以互相访问本类的private成员.</li>
<li>重写方法时, 权限不能降低, 否则会影响多态.</li>
</ul>
</li>
<li>类权限修饰符<ol>
<li><code>(空, 即默认修饰符)</code> : 本类能在同包中访问.</li>
<li><code>public</code> : 本类能在包外访问. 一个单元最多拥有一个public类, 且必须与单元名相同(大小写敏感).</li>
</ol>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>成员内部类<ul>
<li>在类中以成员形式定义的另一个类, 称为成员内部类.</li>
<li>内部类是外部类的成员, 依赖于外部对象的存在,因此不能含有静态方法或静态变量(常量除外).</li>
<li>其他类中声明示例  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">OuterClass</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">OuterClass<span class="token punctuation">.</span>InnerClass</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>因为是成员之一, 可以访问任何外部类成员, 存在引用<code>OuterClass.this</code></li>
</ul>
</li>
<li>静态内部类<ul>
<li>在类中以静态成员形式定义的另一个类, 称为静态内部类.</li>
<li>静态内部类的外部类一定全是静态的.==?_?==</li>
<li>静态内部类可以访问外部类的静态成员.</li>
<li>静态内部类可以定义静态成员变量,静态成员方法和静态内部类.</li>
<li>初始化某个静态内部类不会触发外部类的初始化.</li>
</ul>
</li>
<li>局部类<ul>
<li>定义在方法中的, 有类名的类, 称为局部类.</li>
<li>局部类依赖于方法的运行, 因此本身不是静态的, 不能含有静态成员(常量除外). </li>
<li>局部类可以访问方法中的局部变量(jr8之前只能访问final).</li>
<li>若方法是成员方法, 则能访问外部类的所有成员, 存在引用<code>OuterClass.this</code></li>
<li>若方法是静态方法, 则只能访问外部类的静态成员.</li>
</ul>
</li>
<li>匿名类<ul>
<li>匿名类是没有类名的子类, 使用格式: <code>new FatherClassOrInterface() &#123;...&#125; ;</code></li>
<li>匿名类通常意味着向上转型, 并即时生成一个实例, 因此本身不是静态的.</li>
<li>匿名类可以出现在成员变量中/方法中.</li>
<li>匿名类不能定义新的构造方法/实现新的接口/派生出子类.</li>
<li>匿名类若出现在成员变量中, 则类似于成员内部类; 若出现在方法中, 则类似于局部类.</li>
</ul>
</li>
</ul>
<h2 id="回调（思想）"><a href="#回调（思想）" class="headerlink" title="回调（思想）"></a>回调（思想）</h2><ul>
<li>某个对象A引发另一对象B的行为，同时使B持有A的引用。B在行为过程中再引发A的行为，此谓回调。</li>
<li>A的引用，可能是直接引用，也可能是接口引用等</li>
<li>令B持有A的引用，可能通过方法参数传递，也可能通过set成员变量引用</li>
<li>在多线程中，回调尤为常用</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>Throwable的直接子类有Error（JVM错误用），Exception（异常类）。Exception的直接子类有RuntimeException（算术异常，丢失资源，找不到类，空指针，非法参数，数组越界，未知异常），IOException（EOF异常，找不到文件）</li>
<li>运行时异常无需手动管理，所有过程隐式进行。IOException需要显式处理。</li>
<li>当程序发生异常时，需要手写<code>throw new XXException(..)</code>，则方法会抛出一个异常。在异常被抛出的地方，必须被处理。</li>
<li>处理异常：<ul>
<li>用<code>try&#123;&#125;</code>包括可能会抛出异常的代码块，后接<code>catch (XXExcepetion e)&#123;&#125; catch (BiggerException e)&#123;&#125;... finally&#123;&#125;</code>代码块。或在方法声明中注明<code>throws XXException</code>(则调用此方法的方法必须处理此异常)</li>
<li>若<code>try&#123;&#125;</code>代码块中确实抛出异常，则程序跳至catch代码块，并用e接收异常实例以供分析。</li>
<li>无论在<code>try&#123;&#125;</code>,<code>catch()&#123;&#125;</code>中有无遇到异常，程序必定执行<code>finally&#123;&#125;</code>，一般在其中回收资源。在<code>finally&#123;&#125;</code>中引发的异常会中止余下代码的执行。</li>
<li>需要同一时间分别处理多个异常时（比如关闭多个流），常用try嵌套。注意在finally中判断引用是否为空。</li>
</ul>
</li>
</ul>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li>抽象父类：InputStream，OutputStream（抽象方法是read(), write()）</li>
<li>文件字节流：FileInputStream，FileOutputStream<ul>
<li>构造方法（常用的）有(String name)， (File file), OutputStream还有(File file, boolean append), 若append，则文件写入在末尾</li>
<li><code>int read()</code> 用int返回下一字节byte（无输入则返回-1）,对文件单个字节操作.</li>
<li><code>int read(byte b[])</code> 将最多b.length的字节读入到b[]，返回实际读入的字节数。只遇到EOF则返回-1</li>
<li><code>int read(byte b[], int off, int len)</code> 将最多len的字节读入到b[off]或以后，返回实际读入的字节数。只遇到EOF则返回-1</li>
<li><code>void write(int b)</code> 写一个字节b（抛弃高位）</li>
<li><code>void write(byte b[], int off, int len)</code> 从<code>b[off]</code>开始写出len个字节</li>
<li><code>void write(byte b[])</code> 写出b.length个字节</li>
<li></li>
</ul>
</li>
<li><code>BufferedInputStream(InputStream)</code> 利用内置的缓冲数组加速读取</li>
<li><code>BufferedOutputStream(OutputStream)</code> 加速写出</li>
</ul>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li>抽象父类：Reader, Writer</li>
<li>文件字符流：FileReader, FileWriter(使用默认字符集)</li>
<li>若要指定字符编码和字节缓冲区大小，应该构造InputStreamReader(FileInputStream in, String charsetName);</li>
<li><code>BufferedReader(Reader in)</code>, <code>(Readerin int sz)</code> 加速读入</li>
<li><code>BufferedWriter(Writer out)</code>, <code>(Writer out, int sz)</code> 加速写出</li>
<li><code>PrintWriter(File file)</code> <code>(String fileName)</code>, <code>(OutputStream out)</code>, <code>(Writer out)</code>有格式的输出流</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul>
<li>可以定义泛型类<code>class&lt;T&gt; &#123;&#125;</code></li>
<li>不能调用泛型参数的构造方法</li>
<li>可以指定泛型类上界，以使用其成员<code>class&lt;T extends K&gt;</code>，编译器静态地禁止代码越过上界。泛型类在各处代码都能记住其上界。</li>
<li>声明一个泛型类对象时，省略尖括号表示<code>&lt;Object&gt;</code></li>
<li>在同一条声明语句中，后面的尖括号可以留空表示同上<code>&lt;&gt;</code></li>
<li>类型参数是运行时构造对象才能确定的，因此静态方法不能使用类型参数</li>
<li>泛型类是非协变的，<code>A&lt;Person&gt;</code>与<code>A&lt;Student&gt;</code>没有关联</li>
<li>禁止声明类型为泛型类的数组(可以用arrayList代替)</li>
</ul>
<h3 id="将泛型类用作参数"><a href="#将泛型类用作参数" class="headerlink" title="将泛型类用作参数"></a>将泛型类用作参数</h3><ul>
<li>使用通配符<code>&lt;?&gt;</code>, 此时可以指定泛型参数的下界（super）或更严格的上界（无视变得宽松的上界）</li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li>可以定义泛型方法<code>public static &lt;T&gt; T func()&#123; return null; &#125; </code></li>
<li>不能调用泛型参数的构造方法</li>
<li>可以指定泛型参数上界，以使用其成员<code>public static &lt;T extends K&gt; T func() &#123; return null; &#125;</code>，编译器静态地禁止代码越过上界</li>
<li>类型参数视为方法接受的实数，因此可以用于定义静态方法</li>
<li></li>
<li>编译实现将把泛型改写成Object，并在适当的时候向下转型。因此，</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>接受泛型参数</li>
<li><code>boolean add(E e)</code></li>
<li><code>boolean addAll(Collention&lt;? extends E&gt; c)</code></li>
<li><code>boolean contains(Object o), containsAll(Collect&lt;?&gt; c)</code></li>
<li><code>boolean equals(Object o)</code></li>
<li><code>boolean isEmpty()</code></li>
<li><code>Iterator&lt;E&gt; iterator()</code></li>
<li><code>boolean remove(Object o)</code> 删除成功返回ture</li>
<li><code>boolean removeAll(Collenton&lt;?&gt; c)</code></li>
<li><code>int size()</code></li>
<li><code>Object[] toArray()</code></li>
<li><code>&lt;T&gt; T[] toArray(T[])</code></li>
</ul>
<h3 id="Collections-由静态方法构成的类"><a href="#Collections-由静态方法构成的类" class="headerlink" title="Collections 由静态方法构成的类"></a>Collections 由静态方法构成的类</h3><ul>
<li><code>void sort(Collection&lt;?&gt; c)</code></li>
</ul>
<h2 id="list-允许重复的列表"><a href="#list-允许重复的列表" class="headerlink" title="list 允许重复的列表"></a>list 允许重复的列表</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><code>void add(int index, E element)</code></li>
<li><code>void add(int index, Collection&lt;? extends E&gt; c)</code></li>
<li>常用<code>void ensureCapacity(int minCapacity)</code>可以优化新开内存的耗时</li>
<li><code>int indexOf(Object o)</code> 返回第一次出现的位置，无则-1</li>
<li><code>int lastIndexOf(Object o)</code></li>
<li><code>E remove(int index)</code> 删除指定位置的元素</li>
<li><code>E set(int index, E element)</code> 替换指定位置的元素</li>
<li><code>void sort(Comparator&lt;? super E&gt; c)</code> 排序</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li>同ArrayList</li>
<li><code>void addFirst(E e)</code></li>
<li><code>void addLast(E e)</code></li>
<li><code>E getFirst()</code></li>
<li><code>E getLast</code></li>
<li><code>Iterator&lt;E&gt; descendingIterator()</code> 逆序迭代器</li>
<li><code>E pop()</code></li>
<li><code>void push(E e) == addFirst(E e)</code></li>
</ul>
<h2 id="set-不允许重复的集合"><a href="#set-不允许重复的集合" class="headerlink" title="set 不允许重复的集合"></a>set 不允许重复的集合</h2><ul>
<li><code>boolean(如果集合发生改变) remainAll(Collection&lt;?&gt; c), removeAll(Collection&lt;?&gt; c)</code></li>
<li><code>void clear()</code> 清空</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>依赖于<code>HashCode()</code>判断元素是否相同</li>
<li>基于Object的<code>HashCode()</code>会将地址纳入计算，可以覆写<code>HashCode()</code>以忽略地址差异</li>
<li>若<code>HashCode()</code>相同，则调用<code>equals()</code>判断。基于Object的<code>equals()</code>仅比较地址（String类已覆写好）。</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul>
<li>依赖于接口Comparable的<code>compareTo()</code>或者比较类的<code>compare(,)</code>比较大小。优先使用比较类。小在前，大在后。</li>
<li>比较类需要实现接口Comparator,并<code>@Override compare(,)</code></li>
<li><code>Iterator&lt;E&gt; descendingIterator()</code> 逆序迭代器</li>
<li><code>Comparator &lt;? super E&gt; comparator()</code> 返回比较器，或null</li>
<li><code>E ceiling(E e)</code> 返回最小的大于等于e的元素，或null</li>
<li><code>E floor(E e)</code> 返回最大的小于等于e的元素，或null</li>
<li><code>E higher(E e)</code> 返回最小的大于e的元素，或null</li>
<li><code>E lower(E e)</code> 返回最大的小于e的元素，或null</li>
</ul>
<h2 id="Map-键值绑定"><a href="#Map-键值绑定" class="headerlink" title="Map 键值绑定"></a>Map 键值绑定</h2><ul>
<li><code>static interface Map.Entry&lt;K, V&gt;</code></li>
<li><code>int size()</code></li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>允许键值为null</li>
<li><code>HashMap()</code> 默认容量为16，负载因子为0.75</li>
<li><code>HashMap(int intialCapacity)</code></li>
<li><code>HashMap(int intialCapacity, float loadFactor)</code></li>
<li><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
<li><code>boolean containsKey(Object key)</code></li>
<li><code>boolean containsValue(Object value)</code></li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></li>
<li><code>V get(Object key)</code></li>
<li><code>Set&lt;K&gt; keySet()</code></li>
<li><code>V put(K key, V value)</code> 返回上一个值或null</li>
<li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code> 复制映射</li>
<li><code>V remove(Object key)</code></li>
<li><code>boolean remove(Object key, Object value)</code></li>
<li><code>V replace(K key, V value)</code> 如果有键则替换</li>
<li><code>boolean replace(K key, V oldValue, V newValue)</code> 如果键key映射到oldValue则替换</li>
<li><code>Collection&lt;V&gt; values()</code>返回值的Collection</li>
</ul>
]]></content>
      <tags>
        <tag>语法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA 学习笔记</title>
    <url>/2021/08/05/cuda/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>《CUDA 编程 基础与实践》樊哲勇</li>
<li><a href="https://docs.nvidia.com/cuda/index.html">CUDA Toolkit Documentation</a></li>
</ul>
<h2 id="获得-GPU-加速的关键"><a href="#获得-GPU-加速的关键" class="headerlink" title="获得 GPU 加速的关键"></a>获得 GPU 加速的关键</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol>
<li>数据传输比例较小</li>
<li>核函数的算术强度较高</li>
<li>核函数中定义的线程数目较多</li>
</ol>
<h4 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h4><ol>
<li>减少主机与设备之间的数据传输</li>
<li>提高核函数的算术强度</li>
<li>增大核函数的并行规模</li>
</ol>
<span id="more"></span>

<h2 id="SM-流多处理器"><a href="#SM-流多处理器" class="headerlink" title="SM 流多处理器"></a>SM 流多处理器</h2><p>官方有时简称 Multiprocessor</p>
<h3 id="SM-的构成"><a href="#SM-的构成" class="headerlink" title="SM 的构成"></a>SM 的构成</h3><ol>
<li>寄存器</li>
<li>共享内存</li>
<li>常量内存的缓存</li>
<li>纹理和表面内存的缓存</li>
<li>L1 缓存</li>
<li>（常见4个）线程束调度器</li>
<li>执行核心：INT32, FP32, FP64, 单精度浮点数超于函数的特殊函数单元(special function unit, SFUs), 混合精度的张量核心(tensor cores)</li>
</ol>
<h3 id="SM-的占有率"><a href="#SM-的占有率" class="headerlink" title="SM 的占有率"></a>SM 的占有率</h3><p>当并行规模较小，有些 SM 占有率为零，导致程序性能低下。当并行规模足够大时，也有可能得到非 100% 的占有率。</p>
<p>考虑指标（查询官方文档 CUDA_Occupancy_Calculator.xls 的图灵架构）：</p>
<ol>
<li>一个 SM 最多拥有线程块个数$\ N_b = 16$。</li>
<li>一个 SM 最多拥有的线程个数$\ N_t = 1536$。</li>
<li>线程块大小最大为$\ 1024$。</li>
</ol>
<p>当并行规模足够大（核函数配置的总线程数足够多），需要分几种情况讨论 SM 的理论占有率：</p>
<ol>
<li>寄存器核共享内存使用量很少。SM 的占有率完全由线程块大小决定。首先，由于线程束大小是 32，线程块大小最好是 32 的倍数。其次，线程块大小不能小于$\ N_t/N_b$​，才可能利用最大线程数量。因此，96 的线程块大小就能获得 100% 的占有率。类似的，128 的线程块大小在开普勒架构下能获得满占有率。（我选择 128）</li>
<li>寄存器带来占有率瓶颈。一个 SM 最多有 65536（64K）个寄存器。如果令线程数最大化（1536），那么平均一个线程可用 42.7 个寄存器。当每个线程所用的寄存器个数大于 42 时，SM 的占有率将低于 50%。</li>
<li>有限的共享内存对占有率的约束。一个 SM 拥有 65536 字节共享内存。如果线程块大小为 128，且SM 是线程满载（1536），要令占有率为 100%，则网格大小为 12，一个线程块最多有 5461 字节的共享内存。</li>
</ol>
<h3 id="运行时API查询设备"><a href="#运行时API查询设备" class="headerlink" title="运行时API查询设备"></a>运行时API查询设备</h3><p>参考<code>deviceQuery.cpp</code></p>
<h2 id="全局内存的合理使用"><a href="#全局内存的合理使用" class="headerlink" title="全局内存的合理使用"></a>全局内存的合理使用</h2><h3 id="合并访问"><a href="#合并访问" class="headerlink" title="合并访问"></a>合并访问</h3><p>全局内存具有最高的延迟，所以配置有缓存，每次 Cache Miss 默认读取 32 字节。由于缓存命中问题，需要提高内存访问的合并度，从而提高效率。简单起见，只考虑全局内存到 L2 缓存。可以定义合并度(degree of coalescing) 为<strong>一个线程束</strong>请求的字节数除以实际数据传输处理的字节数。合并度体现了显存带宽的利用率。</p>
<p>CUDA 运行时 API 函数分配的内存的首地址至少是256字节的整数倍。</p>
<p>只要确保每当线程束读取一次内存后，该内存对应的32字节范围都被当前线程束利用，则合并度就是100%。</p>
<p>对于一个线程束访问同一个全局内存地址的 4 字节，属于广播式的非合并访问（因为只用了 4 字节而非 32 字节，合并度为 12.5%）。如果内存只读，那么适合采用常量内存。</p>
<h3 id="写优先于只读"><a href="#写优先于只读" class="headerlink" title="写优先于只读"></a>写优先于只读</h3><p>有时候合并写入与合并读取无法兼顾，例如矩阵转置。此时应当优先保证写入是合并的。</p>
<p>这是因为从帕斯卡架构开始，若编译器判定一个全局内存变量在整个核函数的范围内都<strong>只读</strong>，则会自动用函数<code>__ldg()</code>读取全局内存，附带缓存效果，缓解非合并访问的影响。但对于全局内存的写入，没有类似的优化手段。</p>
<h2 id="共享内存的合理使用"><a href="#共享内存的合理使用" class="headerlink" title="共享内存的合理使用"></a>共享内存的合理使用</h2><p>在核函数内，使用<code>__shared__</code>修饰的变量（数组）将使用共享内存。同一线程块使用同一个共享内存副本，而不同线程块的共享内存是互相独立的，不可见的。</p>
<p>利用共享内存，可以消除一些无法兼顾读写合并的全局内存访问，例如数组归约，先将要读取的数据从全局内存拷贝至共享内存（然后<code>__syncthreads()</code>同步一下），可以带来细微的性能提升。</p>
<p>对共享内存的访问越频繁，性能提升越明显。</p>
<h3 id="动态共享内存"><a href="#动态共享内存" class="headerlink" title="动态共享内存"></a>动态共享内存</h3><p>共享内存大小可以在核函数的执行配置中指定：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>grid_size<span class="token punctuation">,</span> block_size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> block_size<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>同时要修改共享内存变量的声明方式</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// before</span>
__shared__ real a<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// after</span>
<span class="token keyword">extern</span> __shared__ real a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态和静态的声明方式在性能上几乎没有差别。</p>
<h3 id="避免共享内存的bank冲突"><a href="#避免共享内存的bank冲突" class="headerlink" title="避免共享内存的bank冲突"></a>避免共享内存的bank冲突</h3><p>共享内存在物理上被分为 32 个（恰好是线程束大小）个 bank，多个线程同时访问同一个 bank 会导致冲突；多个线程同时访问不同的 bank 能取得更高的性能。</p>
<p>除了开普勒架构（8 字节）外，每 4 个字节被划分到一个 bank。例如 <code>0000</code> 属于 bank0，<code>0004</code> 属于 bank1 …… <code>0128</code> 属于 bank0。可以看出，每个 bank 的相邻层的地址相差 128。</p>
<p>一个线程束试图同时访问同一个 bank 中的 n 层数据将导致 n 次 内存事务(memory transaction)。亦称为 n 路 bank 冲突。n 很大的 bank 冲突是要尽量避免的。</p>
<p>在矩阵转置中，写入共享内存时易产生 bank 冲突，可以通过修改数组大小解决。</p>
<p>记得双精度浮点数占 8 字节。</p>
<h2 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h2><p>例如在数组归约（加法）中，要令GPU完成求和，需要使用原子操作。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>原子函数在全局内存和共享内存上体现原子性。</p>
<p>原子函数不依赖内存栅栏，不需要线程同步或顺序约束（参考<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomic-functions">官方文档</a>）。</p>
<p>原子函数只能用于设备函数。</p>
<h3 id="原子性粒度"><a href="#原子性粒度" class="headerlink" title="原子性粒度"></a>原子性粒度</h3><p>系统原子性：在任意 CPU 和 GPU 的任意线程上保持原子性。函数名有后缀<code>_system</code>，如<code>atomicAdd_system</code>。</p>
<p>设备原子性：在当前 GPU 的任意线程上保持原子性。函数名无附加后缀。</p>
<p>线程块原子性：在当前 GPU 的同一线程块中的任意线程上保持原子性。函数名有后缀<code>_block</code>，如<code>atomicAdd_block</code>。</p>
<h3 id="原子函数速查"><a href="#原子函数速查" class="headerlink" title="原子函数速查"></a>原子函数速查</h3><p><strong>注意：所有的函数都返回旧值</strong></p>
<p>支持的类型可参考书第 92 页。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// T in &#123;int, unsigned int, unsigned long long int&#125;</span>
<span class="token keyword">using</span> UI <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
T <span class="token function">atomicAdd</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加法，支持浮点</span>
T <span class="token function">atomicSub</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 减法，支持浮点</span>
T <span class="token function">atomicExch</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new = val，支持float</span>
T <span class="token function">atomicMin</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最小值</span>
T <span class="token function">atomicMax</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最大值</span>
UI <span class="token function">atomicInc</span><span class="token punctuation">(</span>UI <span class="token operator">*</span>address<span class="token punctuation">,</span> UI val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new = (old >= val) ? 0 : (old+1)</span>
UI <span class="token function">atomicDec</span><span class="token punctuation">(</span>UI <span class="token operator">*</span>address<span class="token punctuation">,</span> UI val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new = ((old == 0) || (old > val)) ? val : (old-1)</span>
T <span class="token function">atomicAnd</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按位与</span>
T <span class="token function">atomicOr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按位或</span>
T <span class="token function">atomicXor</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按位异或</span>
T <span class="token function">atomicCAS</span><span class="token punctuation">(</span>T <span class="token operator">*</span>address<span class="token punctuation">,</span> T compare<span class="token punctuation">,</span> T val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// new = old == compare ? val : old。支持unsigned short int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="线程束与协作组"><a href="#线程束与协作组" class="headerlink" title="线程束与协作组"></a>线程束与协作组</h2><h3 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h3><p>单指令-多线程（single instruction multiple thread, SIMT）：不同线程共享同一个 PC。SIMT 的通病是分支发散（branch divergence），所有的分支会产生串行的时间开销。</p>
<p>在伏特架构之前，一个线程束共享一个 PC。不同线程束之间没有分支发散问题。</p>
<p>从伏特架构开始，引入了独立线程调度（independent thread scheduling）机制。每个线程有自己的 PC，使得需要用户自己控制线程束内的同步。另一个代价是每个线程需要用两个寄存器来做 PC。如果旧代码出现线程束内不安全的问题，可以指定虚拟架构为低于伏特架构的计算能力。</p>
<h3 id="线程束内的线程同步"><a href="#线程束内的线程同步" class="headerlink" title="线程束内的线程同步"></a>线程束内的线程同步</h3><p><code>__syncwarp()</code>比线程块同步函数<code>__syncthreads()</code>更加廉价。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数原型</span>
<span class="token keyword">void</span> <span class="token function">__syncwarp</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其中掩码表示参与同步的线程，默认 32 个线程全部参与。</p>
<p>在分治时，当问题规模缩小到一个线程束内，可以不使用<code>__syncthreads</code>而用<code>__syncwarp</code>。</p>
<h3 id="更多线程束内的基本函数"><a href="#更多线程束内的基本函数" class="headerlink" title="更多线程束内的基本函数"></a>更多线程束内的基本函数</h3><p><strong>注意：若当前线程不参与，则函数的返回值是无定义的。</strong></p>
<p>线程束表决函数（warp vote functions）</p>
<p>线程束匹配函数（warp match functions）<em>待续</em></p>
<p>线程束洗牌函数（warp shuffle functions）</p>
<p>线程束矩阵函数（warp matrix functions）<em>待续</em></p>
<h4 id="线程束表决"><a href="#线程束表决" class="headerlink" title="线程束表决"></a>线程束表决</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token function">__ballot_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> <span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 若当前线程参与，则同步表决下一次参与意愿（当 predicate 非零，则令返回值对应位置 1， 否则置 0。）。相当于从旧掩码表决出一个新掩码。</span>

<span class="token keyword">int</span> <span class="token function">__all_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> <span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 若当前线程参与，则同步投票，一票否决，返回投票是否通过。所有参与线程都同意才通过。</span>

<span class="token keyword">int</span> <span class="token function">__any_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> <span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 若当前线程参与，则同步投票，一票通过，返回投票是否通过。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="线程束洗牌"><a href="#线程束洗牌" class="headerlink" title="线程束洗牌"></a>线程束洗牌</h4><p>定义“束内指标” <code>int lane_id = threadIdx.x % w</code>。</p>
<p><code>w</code> 是逻辑线程束大小，只能取 2、4、8、16、32 中的一个。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token function">__shfl_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> T v<span class="token punctuation">,</span> <span class="token keyword">int</span> srcLane<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token operator">=</span>warpSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 参与线程返回标号为 srcLane 的变量 v 的值。这是一种广播式数据交换。 </span>

T <span class="token function">__shfl_up_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> T v<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token operator">=</span>warpSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 标号为 t 的参与线程返回标号为 t - d 的线程中的 v 的值；若 t - d &lt; 0 则返回原来的 v。相当于数据向上平移。</span>

T <span class="token function">__shfl_down_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> T v<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token operator">=</span>warpSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 标号为 t 的参与线程返回标号为 t + d 的线程中的 v 的值；若 t + d >= w 则返回原来的 v。相当于数据向下平移。</span>

T <span class="token function">__shfl_xor_sync</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> T v<span class="token punctuation">,</span> <span class="token keyword">int</span> laneMask<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token operator">=</span>warpSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 标号为 t 的参与线程返回标号为 t ^ laneMask 的线程中的 v 的值；相当于对应的两个线程交换数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用线程束洗牌优化数组归约：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> FULL_MASK <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> __global__ <span class="token function">reduce_shfl</span><span class="token punctuation">(</span><span class="token keyword">const</span> real <span class="token operator">*</span>d_x<span class="token punctuation">,</span> real <span class="token operator">*</span>d_y<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> tid <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> bid <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> bid <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> tid<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> __shared__ real s_y<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> N <span class="token operator">?</span> d_x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span> offset <span class="token operator">>=</span> <span class="token number">32</span><span class="token punctuation">;</span> offset <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tid <span class="token operator">&lt;</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">+=</span> s_y<span class="token punctuation">[</span>tid <span class="token operator">+</span> offset<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    real y <span class="token operator">=</span> s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 寄存器优化</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> offset <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        y <span class="token operator">+=</span>  <span class="token function">__shfl_down_sync</span><span class="token punctuation">(</span>FULL_MASK<span class="token punctuation">,</span> y<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">atomicAdd</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="协作组"><a href="#协作组" class="headerlink" title="协作组"></a>协作组</h3><p>协作组（cooperative groups）可以看作线程块和线程束同步机制的推广。范围涵盖线程块内部，线程块之间（网格级）及设备之间的同步与协作。</p>
<p>引入头文件和命名空间</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cooperative_groups.h></span></span>
<span class="token keyword">namespace</span> cg <span class="token operator">=</span> cooperative_groups<span class="token punctuation">;</span> <span class="token comment">// 仅供参考</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="线程块级别的协作组"><a href="#线程块级别的协作组" class="headerlink" title="线程块级别的协作组"></a>线程块级别的协作组</h4><p>基本类型<code>thread_group</code>。有如下成员：</p>
<ol>
<li><code>void sync()</code> 同步组内所有线程</li>
<li><code>unsigned size()</code> 返回组内总的线程数目</li>
<li><code>unsigned thread_rank()</code> 返回当前线程的组内标号</li>
<li><code>bool is_valid()</code> 检查定义的组是否违反 CUDA 的任何限制</li>
</ol>
<p>导出类型<code>thread_block</code>，额外函数：</p>
<ol>
<li><code>dim3 group_index()</code> 返回当前线程的线程块指标，相当于 blockIdx</li>
<li><code>dim3 thread_index()</code> 相当于 threadIdx</li>
</ol>
<p>于是可以抽象出当前线程块：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">thread_block g <span class="token operator">=</span> <span class="token function">this_thread_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 __syncthreads()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以将 <code>thread_block</code> 进行多次分割（但一组线程的数量只能是 2 的幂次）：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">thread_group g32 <span class="token operator">=</span> <span class="token function">tiled_partition</span><span class="token punctuation">(</span><span class="token function">this_thread_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于线程束</span>
thread_group g4 <span class="token operator">=</span> <span class="token function">tiled_partition</span><span class="token punctuation">(</span>g32<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再次分割</span>
<span class="token comment">// ---------- 模板化版本 ----------</span>
thread_block_tile<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> g32 <span class="token operator">=</span> tiled_partition<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">this_thread_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样的“线程块片”可以模仿线程束的一些行为，比如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token function">__ballot_sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">__all_sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">__any_sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">__shfl_sync</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> <span class="token keyword">int</span> srcLane<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">__shfl_up_sync</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">__shfl_down_sync</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">__shfl_xor_sync</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> <span class="token keyword">int</span> laneMask<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 相对线程束的不同点：1. 不允许掩码，所有线程必须参与 2. 洗牌函数不再需要宽度参数，宽度由线程块片大小确定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="再次优化数组归约"><a href="#再次优化数组归约" class="headerlink" title="再次优化数组归约"></a>再次优化数组归约</h3><p>这次我们采用的技巧有：</p>
<ol>
<li>使用静态全局内存</li>
<li>调用两次核函数，舍弃原子加法函数（这会提高精确度）</li>
<li>提高线程利用率（在规约之前进行小部分求和）</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;real.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;widgets.hpp></span></span>

<span class="token keyword">constexpr</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> FULL_MASK <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> __global__ <span class="token function">reduce_cp</span><span class="token punctuation">(</span><span class="token keyword">const</span> real <span class="token operator">*</span>d_x<span class="token punctuation">,</span> real <span class="token operator">*</span>d_y<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> tid <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> bid <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">extern</span> __shared__ real s_y<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    real y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> stride <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">*</span> gridDim<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// 以网格大小为跨度</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> bid <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> tid<span class="token punctuation">;</span> n <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> n <span class="token operator">+=</span> stride<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        y <span class="token operator">+=</span> d_x<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 确保一个网格能覆盖所有数据</span>
    <span class="token punctuation">&#125;</span>
    s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 线程块内，跨线程束折半归约</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span> offset <span class="token operator">>=</span> <span class="token number">32</span><span class="token punctuation">;</span> offset <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tid <span class="token operator">&lt;</span> offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">+=</span> s_y<span class="token punctuation">[</span>tid <span class="token operator">+</span> offset<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    y <span class="token operator">=</span> s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> offset <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        y <span class="token operator">+=</span> <span class="token function">__shfl_down_sync</span><span class="token punctuation">(</span>FULL_MASK<span class="token punctuation">,</span> y<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        d_y<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// 返回线程块结果</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e8</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> GRID_SIZE <span class="token operator">=</span> <span class="token number">10240</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> BLOCK_SIZE <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
__device__ real d_input<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
__device__ real d_output<span class="token punctuation">[</span>GRID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

real <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">const</span> real <span class="token operator">*</span>d_x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    real <span class="token operator">*</span>d_y<span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaGetSymbolAddress</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_y<span class="token punctuation">,</span> d_output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> shared_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> BLOCK_SIZE<span class="token punctuation">;</span>
    reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>GRID_SIZE<span class="token punctuation">,</span> BLOCK_SIZE<span class="token punctuation">,</span> shared_size<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>d_x<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> GRID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    real h_y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>h_y<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> cudaMemcpyDeviceToHost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// CHECK(cudaMemcpyFromSymbol(h_y, d_output, sizeof(real)));</span>

    <span class="token keyword">return</span> h_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
    <span class="token keyword">static</span> real input<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">fill_n</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> N<span class="token punctuation">,</span> <span class="token number">1.23f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaMemcpyToSymbol</span><span class="token punctuation">(</span>d_input<span class="token punctuation">,</span> input<span class="token punctuation">,</span> N <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    real <span class="token operator">*</span>d_x<span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaGetSymbolAddress</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_x<span class="token punctuation">,</span> d_input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">reduce</span><span class="token punctuation">(</span>d_x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 运行结果：</span>
<span class="token comment">// 123000064.000000</span>
<span class="token comment">// 对比 CPU 裸归约方法的加速比：67</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="CUDA-流"><a href="#CUDA-流" class="headerlink" title="CUDA 流"></a>CUDA 流</h2><h3 id="核函数外部的并行"><a href="#核函数外部的并行" class="headerlink" title="核函数外部的并行"></a>核函数外部的并行</h3><p>主要有以下情形：</p>
<ol>
<li>核函数计算与数据传输之间的并行</li>
<li>主机计算与数据传输之间的并行</li>
<li>不同的数据传输之间的并行</li>
<li>核函数计算与主机计算之间的并行</li>
<li>不同核函数之间的并行</li>
</ol>
<p>若两个任务的运行时间相近，则尽量令他们并行。反之，则并行和串行的性能差距不大。</p>
<p>使用 CUDA 流的主要目的是尽量取得核函数外部的并行能力。</p>
<h3 id="使用-CUDA-流"><a href="#使用-CUDA-流" class="headerlink" title="使用 CUDA 流"></a>使用 CUDA 流</h3><p>CUDA 流的使用相对简单，只要记住一些规则就好。</p>
<ol>
<li><p>CUDA 程序有一个默认流。若 API 不需要指定流句柄，可推测它用于默认流。</p>
</li>
<li><p>创建、销毁 CUDA 流</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cudaStream_t stream<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">cudaStreamCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建流，获得句柄</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// ...</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">cudaStreamDestroy</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 销毁流，句柄不抹除</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>检测 CUDA 流是否空闲 </p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cudaError_t <span class="token function">cudaStreamSynchronize</span><span class="token punctuation">(</span>cudaStream_t stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞主机，直到 CUDA 流完成所有操作</span>
cudaError_t <span class="token function">cudaStreamQuery</span><span class="token punctuation">(</span>cudaStream_t stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 cudaSuccess（已完成）/ cudaErrorNotReady（未完成）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p><code>cudaMemcpy</code> 会阻塞主机。但是核函数的调用总是异步的。应该尽量早地调用核函数，随后再进行主机的计算任务。</p>
</li>
<li><p>在核函数配置中指派 CUDA 流：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">my_kernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>N_grid<span class="token punctuation">,</span> N_block<span class="token punctuation">,</span> N_shared<span class="token punctuation">,</span> stream_id<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 四个模板参数必须齐全</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>异步的数据传输需要：</p>
<ol>
<li>使用 <code>cudaMemcpyAsync</code> 函数。</li>
<li>涉及的主机内存必须是不可分页的，否则 API 将会退化为同步版本。</li>
</ol>
<p> 异步传输的过程将由 GPU 的 DMA（direct memory access）接管。</p>
</li>
<li><p>可以用 CUDA 运行时 API 来申请不可分页的内存（non-pageable memory），又称固定内存（pinned memory）。不可分页意味着操作系统无权修改虚拟地址所对应的物理地址。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cudaError_t <span class="token function">cudaMallocHost</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
cudaError_t <span class="token function">cudaHostAlloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
cudaError_t <span class="token function">cudaFreeHost</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>良好的 CUDA 流指派会从流水线重叠中获得并行加速。但是 CUDA 流是有启动开销，且硬件环境有限，过多的 CUDA 流会拉低性能。</p>
</li>
</ol>
<h2 id="指令速查"><a href="#指令速查" class="headerlink" title="指令速查"></a>指令速查</h2><h3 id="编译器选项"><a href="#编译器选项" class="headerlink" title="编译器选项"></a>编译器选项</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--ptxas-options<span class="token operator">=</span>-v <span class="token comment"># 报道每个核函数的寄存器使用数量</span>
--maxrregcount<span class="token operator">=</span> <span class="token comment"># 限制所有核函数的寄存器使用量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">__global__ <span class="token comment"># 核函数修饰符</span>
__device__ <span class="token comment"># 设备函数、变量修饰符</span>
__host__ <span class="token comment"># 主机函数修饰符，一般只与__device__同时出现</span>
__noinline__ <span class="token comment"># 建议函数非内联</span>
__forceinline__ <span class="token comment"># 建议函数内联</span>
__launch_bounds__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 修饰核函数，限制寄存器使用量</span>
__shared__ <span class="token comment"># 修饰全局变量，使它成为共享内存</span>
__managed__ <span class="token comment"># 修饰全局变量，使它成为统一内存，必须与__device__同时出现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><h3 id="CMake模板"><a href="#CMake模板" class="headerlink" title="CMake模板"></a>CMake模板</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 2021/08/02</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.20</span><span class="token punctuation">)</span>

<span class="token keyword">project</span><span class="token punctuation">(</span>hello LANGUAGES CUDA <span class="token property">VERSION</span> <span class="token number">0.1</span><span class="token punctuation">)</span>

<span class="token keyword">option</span><span class="token punctuation">(</span>USE_DOUBLE <span class="token string">"Use real as double, otherwise float"</span> <span class="token boolean">OFF</span><span class="token punctuation">)</span>

<span class="token keyword">find_package</span><span class="token punctuation">(</span>CUDAToolkit REQUIRED<span class="token punctuation">)</span>

<span class="token comment"># set(CMAKE_CUDA_COMPILER_ID NVIDIA)</span>

<span class="token comment"># set(ENV&#123;PATH&#125; "C:/Program\ Files\ (x86)/Microsoft\ Visual\ Studio/2019/Community/VC/Tools/MSVC/14.29.30037/bin/Hostx64/x64:$ENV&#123;PATH&#125;")</span>

<span class="token comment"># report registers used in each core function</span>
<span class="token keyword">add_compile_options</span><span class="token punctuation">(</span>--ptxas-options=-v<span class="token punctuation">)</span>

<span class="token keyword">include_directories</span><span class="token punctuation">(</span>./include<span class="token punctuation">)</span>

<span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cu<span class="token punctuation">)</span>

<span class="token comment"># compute capability, see https://developer.nvidia.com/zh-cn/cuda-gpus#compute</span>
<span class="token keyword">set_property</span><span class="token punctuation">(</span>TARGET hello PROPERTY CUDA_ARCHITECTURES <span class="token number">86</span><span class="token punctuation">)</span>
<span class="token comment"># set_property(TARGET hello PROPERTY CUDA_ARCHITECTURES 75)</span>

<span class="token comment"># install(TARGETS hello DESTINATION .)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="报错、计时工具"><a href="#报错、计时工具" class="headerlink" title="报错、计时工具"></a>报错、计时工具</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// widgets.hpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CHECK</span><span class="token expression"><span class="token punctuation">(</span>callee<span class="token punctuation">)</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                                                         </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">const</span> cudaError_t err <span class="token operator">=</span> callee<span class="token punctuation">;</span>                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> cudaSuccess<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                           </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"CUDA error at %s(%d)\n"</span><span class="token expression"><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"    Function:   %s\n"</span><span class="token expression"><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>            </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"    Error code: %d\n"</span><span class="token expression"><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"    Error hint: %s\n"</span><span class="token expression"><span class="token punctuation">,</span> <span class="token function">cudaGetErrorString</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                 </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">cudaTiming</span><span class="token punctuation">(</span><span class="token keyword">const</span> F <span class="token operator">&amp;</span>func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cudaEvent_t start<span class="token punctuation">,</span> stop<span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventRecord</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cudaEventQuery</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventRecord</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventSynchronize</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> elapsed_time<span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventElapsedTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>elapsed_time<span class="token punctuation">,</span> start<span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CUDA Time = %g ms.\n"</span><span class="token punctuation">,</span> elapsed_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventDestroy</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaEventDestroy</span><span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">hostTiming</span><span class="token punctuation">(</span><span class="token keyword">const</span> F <span class="token operator">&amp;</span>func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token operator">::</span>milli<span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Host Time = %g ms.\n"</span><span class="token punctuation">,</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="精度控制模板"><a href="#精度控制模板" class="headerlink" title="精度控制模板"></a>精度控制模板</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// real.hpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">USE_DOUBLE</span></span>
<span class="token keyword">using</span> real <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> real EPS <span class="token operator">=</span> <span class="token number">1e-15</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token keyword">using</span> real <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> real EPS <span class="token operator">=</span> <span class="token number">1e-6f</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>GPGPU</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络提纲</title>
    <url>/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1 概述</a><ul>
<li><a href="#13-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.3 互联网的组成</a><ul>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F">交换方式</a></li>
</ul>
</li>
<li><a href="#15-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%B1%BB%E5%88%AB">1.5 计算机网络的类别</a><ul>
<li><a href="#%E6%8C%89%E7%85%A7%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB">按照网络的作用范围分类</a></li>
</ul>
</li>
<li><a href="#16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD">1.6 计算机网络的性能</a><ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">性能指标</a><ul>
<li><a href="#%E9%80%9F%E7%8E%87">速率</a></li>
<li><a href="#%E5%B8%A6%E5%AE%BD">带宽</a></li>
<li><a href="#%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a></li>
<li><a href="#%E6%97%B6%E5%BB%B6">时延</a></li>
<li><a href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">时延带宽积</a></li>
<li><a href="#%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4">往返时间</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E7%8E%87">利用率</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.7 计算机网络体系结构</a><ul>
<li><a href="#%E5%8D%8F%E8%AE%AE">协议</a><ul>
<li><a href="#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">五层协议的体系结构</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98">习题</a></li>
</ul>
</li>
<li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2 物理层</a><ul>
<li><a href="#21-%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.1 物理层的基本概念</a></li>
<li><a href="#22-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">2.2 数据通信的基础知识</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E5%9E%8B">数据通信系统的模型</a></li>
<li><a href="#%E6%9C%89%E5%85%B3%E4%BF%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">有关信道的几个概念</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">常用的编码方式</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95">基本的带通调制方法</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">信道的极限容量</a><ul>
<li><a href="#%E4%BF%A1%E9%81%93%E8%83%BD%E9%80%9A%E8%BF%87%E7%9A%84%E9%A2%91%E7%8E%87%E8%8C%83%E5%9B%B4">信道能通过的频率范围</a></li>
<li><a href="#%E4%BF%A1%E5%99%AA%E6%AF%94">信噪比</a></li>
<li><a href="#%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F">香农公式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.3 物理层下面的传输媒体</a><ul>
<li><a href="#%E5%BC%95%E5%AF%BC%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">引导型传输媒体</a></li>
<li><a href="#%E9%9D%9E%E5%BC%95%E5%AF%BC%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">非引导型传输媒体</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a></li>
<li><a href="#25-%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F">2.5 数字传输系统</a></li>
<li><a href="#26-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.6 宽带接入技术</a><ul>
<li><a href="#adsl%E6%8A%80%E6%9C%AF">ADSL技术</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1">习题</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3 数据链路层</a><ul>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">点对点信道的数据链路层</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%B8%A7">数据链路和帧</a></li>
<li><a href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">三个基本问题</a></li>
</ul>
</li>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEppp">点对点协议PPP</a><ul>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9">PPP协议的特点</a></li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F">PPP协议的帧格式</a></li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">PPP协议的工作状态</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-2">习题</a></li>
</ul>
</li>
</ul>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ol>
<li>电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li>
<li>报文交换：整个报文传送到相邻结点，全部储存下来后查找转发表，转发到下一个结点。</li>
<li>分组交换：单个分组（整个报文的一部分）传送到相邻结点，储存下来后查找转发表，转发到下一个结点。</li>
</ol>
<h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="按照网络的作用范围分类"><a href="#按照网络的作用范围分类" class="headerlink" title="按照网络的作用范围分类"></a>按照网络的作用范围分类</h3><ol>
<li>广域网 (Wide Area Network, WAN)，远程网，长距离，高速链路，较大通信容量。</li>
<li>城域网 (Metropolitan Area Network, MAN)，多个局域网，一个城市，常用以太网技术。</li>
<li>局域网 (Local Area Network, LAN)，微型计算机或工作站通过高速通信线路相连。</li>
<li>个人区域网 (Personal Area Networl, PAN)，个人使用的电子设备。</li>
</ol>
<h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><ul>
<li>1Mbps = $10^6$ bits / second</li>
<li>1MB = $2^{20}$ Bytes</li>
</ul>
<h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul>
<li>某个信号具有的频带宽度（300Hz &lt;-&gt; 3.4 kHz ==&gt; 3.1kHz），频域</li>
<li>某通道传输数据的能力，时域</li>
</ul>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul>
<li>单位时间内通过某个网络（或信道、接口）的实际数据量</li>
</ul>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ol>
<li>发送时延（传输时延）（transmission delay）：发送数据帧所需的时间，与发送器（网络适配器）有关。$发送时间 = \frac{数据长度}{发送速率}$</li>
<li>传播时延（propagation delay）：电磁波传播花费的时间，与线路有关</li>
<li>处理时延：收到分组后的计算耗时</li>
<li>排队时延：输入队列、输出队列耗时</li>
</ol>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>传播时延 * 带宽。表示线路的“容积”</p>
<h4 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h4><p>（Round-Trip Time, RTT）最后一帧的传播延迟+ack的传播延迟（假设忽略发送时延）</p>
<p>$有效数据率 = \frac{数据长度}{发送时间+\text{RTT}}$</p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><ul>
<li>信道利用率：信道有数据通过的时间的比率</li>
<li>网络利用率：全网络的信道利用率的加权平均值</li>
</ul>
<p>设$D_0$为网络空闲时（利用率0%）的时延，$D$表示当前网络时延，当前利用率$U$，则$D = \frac{D_0}{1-U}$。</p>
<h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><ul>
<li>系统网络体系结构 SNA（System Network Architecture）。IBM开发。</li>
<li><strong>开放系统互连基本参考模型 OSI/RM</strong>（Open Systems Interconnection Reference Model）ISO制定。</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><p>定义：为进行网络中的数据交换而建立的规则、标准或约定</p>
</li>
<li><p>三要素：语法，语义，同步</p>
</li>
</ul>
<h4 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h4><p><img src="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<p>无论哪一层传送的数据单元，都笼统地用“<strong>分组</strong>”或“<strong>协议数据单元PDU（Protocol Data Unit）</strong>”来表示</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><strong>application layer</strong></p>
<p>负责应用进程间交互。  协议定义进程间通信和交互的规则。</p>
<p>如：域名系统DNS；HTTP协议；SMTP协议；</p>
<p>数据单元称为<strong>报文（message）</strong>。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p><strong>transport layer</strong></p>
<p>负责为进程间通信提供<strong>通用的</strong>数据传输服务。</p>
<p>一个主机，多个进程 =&gt; 传输层有复用和分用的功能</p>
<p>主要协议：  </p>
<ul>
<li>传输控制协议 TCP（Transmission Control Protocol）：面向连接的、可靠的数据传输服务。数据传输的单位是<strong>报文段（segment）</strong></li>
<li>用户数据报协议 UDP（User Datagram protocol）：无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性）。数据传输的单位是<strong>用户数据报</strong></li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>network layer</strong></p>
<p>也叫网际层、IP层。</p>
<p>负责为分组交换网上的不同主机提供通信服务。 发送数据时，将运输层的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</p>
<p>在TCP/IP中，网络层使用IP协议，所以分组也叫<strong>IP数据报</strong>，简称数据报。</p>
<p>网络层要选择合适的路由。</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p><strong>data link layer</strong></p>
<p>将网络层的包<strong>组装成帧（framing）</strong>，在两个相邻结点之间传送<strong>帧（frame）</strong>。每一帧包括数据和<strong>控制信息</strong>（如同步信息、地址信息、差错控制等）。</p>
<p>控制信息指出了数据在哪、校验或纠错信息。如果发现差错，可以<strong>丢弃</strong>这一帧。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p><strong>physical layer</strong></p>
<p>数据单位是<strong>比特</strong>。负责关注电压和电缆的引脚。</p>
<p>电缆、无线信道等物理媒体不是物理层关注的。如何解释0和1的意义也不是物理层负责的。</p>
<hr>
<p>同层次之间可以屏蔽下层的工作，看作把协议数据单元直接传送给“<strong>对等层（peer layers）</strong>”。</p>
<p>每一层在协议的控制下为上一层提供<strong>服务</strong>。要实现本层协议，需要依赖下一层提供的服务。</p>
<p>每一层协议只能看见下一层的服务。 下面的协议对上面的实体是透明的。</p>
<p>OSI把层与层之间交换的数据的单位称为*<em>服务数据单元SDU（Service Data Unit）</em></p>
<p>计算机网络的协议必须把<strong>所有</strong>不利的条件都事先估计到，而不能假定一切都是正常的和理想的。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>OSI的三个核心概念是服务、接口、协议。</li>
<li>原数据1000字节，七层体系结构，每层20字节的头。则头占用了$140/1140 = 12%$的带宽。</li>
<li>最早实现分组交换（<strong>packet switched</strong>）的网络是<strong>ARPAnet</strong>。</li>
<li>网络层控制了子网的操作、决定分组的路由。</li>
<li>应用层有一系列用户常用的协议。</li>
<li>表示层（<strong>presentation</strong>）关心数据的语法和语义。</li>
<li>数据链路层将原始传输设备转换为一个已检错的线路。</li>
<li>能将信息发往部分机器的广播形式叫多播（<strong>multicasting</strong>）。</li>
<li>协议是实体如何进行交流的约定。</li>
<li>各种协议的实现细节不属于网络体系结构的内容。</li>
<li>一个计算机网络可以看作一些自主计算机系统的连接。</li>
<li>发送速率是10Mbps，考虑同轴线缆的传播速度是光速的$\frac{2}{3}$，则1bit的长度是20米。</li>
<li>OSI的失败在于技术、耗时、实现、政策。</li>
<li>数据包在向上层传递时，头部将会被删除。</li>
<li>卫星组网，回应请求的延迟按4倍的距离算。</li>
<li>储存转发传输（<strong>Store-and-forward transmission</strong>）意味着路由器要储存整个包的内容。</li>
<li>数据转换和压缩是由表示层完成的。</li>
<li>接口定义了低层向高层提供的原始操作和服务。</li>
</ol>
<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2 物理层"></a>2 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层的主要任务是确定与传输媒体接口相关的一些特性，即：  </p>
<ol>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ol>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><p>三大部分：  </p>
<ol>
<li>源系统（发送端、发送方）</li>
<li>传输系统（传输网络）</li>
<li>目的系统（接收端、接收方）</li>
</ol>
<p>源系统、目的系统可细分为：</p>
<ol>
<li>源点（<strong>source</strong>）</li>
<li>发送器（数字比特流-&gt;模拟信号）</li>
<li>接收器（模拟信号-&gt;数字比特流）</li>
<li>终点（destination）</li>
</ol>
<h3 id="有关信道的几个概念"><a href="#有关信道的几个概念" class="headerlink" title="有关信道的几个概念"></a>有关信道的几个概念</h3><p>从通信的双方信息交互来看，三种基本方式：  </p>
<ol>
<li>单向通信（单工通信）</li>
<li>双向交替通信（半双工通信）</li>
<li>双向同时通信（全双工通信）</li>
</ol>
<p>“单工”有时也表示双向交替通信。</p>
<p>来自信源的信号称为<strong>基带信号</strong>（基本频带信号）。信道不能传输低频分量或直流分量，故需要对基带信号进行<strong>调制（modulation）</strong>。</p>
<p>调制的分类：</p>
<ol>
<li><strong>基带调制</strong>（<strong>编码</strong>）：对波形变换，变换后仍是基带信号，仍是数字信号。</li>
<li><strong>带通调制</strong>：使用<strong>载波（carrier）</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。载波调制后的信号成为<strong>带通信号</strong>（仅在一段频率范围内能通过信号）。</li>
</ol>
<h4 id="常用的编码方式"><a href="#常用的编码方式" class="headerlink" title="常用的编码方式"></a>常用的编码方式</h4><p><img src="./%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="数字信号常用的编码方式"></p>
<ol>
<li><strong>不归零制</strong>：电平代表01</li>
<li><strong>归零制</strong>：脉冲代表01；位开始边界总是中间电平。</li>
<li><strong>曼彻斯特编码</strong>：位周期中心跳变代表01.</li>
<li><strong>差分曼彻斯特编码</strong>：位中心总是跳变；位开始边界跳变为0，不跳变为1。</li>
</ol>
<p>自同步：从信号波形本身提取信号时钟频率。</p>
<h4 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h4><p><img src="./%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="基本的带通调制方法"></p>
<ol>
<li><strong>调幅（AM）</strong>：振幅随数字信号变化。</li>
<li><strong>调频（FM）</strong>：频率随数字信号变化。</li>
<li><strong>调相（PM）</strong>：初相位随数字信号变化。</li>
</ol>
<p>为了更高的信息传输速率，必须采用多元制的振幅相位混合调制方法。例如<strong>正交振幅调制QAM（Quadrature Amplitude Modulation）</strong>。</p>
<h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>限制码元在信道上的传输速率的因素有两个：  </p>
<ol>
<li>信道能通过的频率范围</li>
<li>信噪比</li>
</ol>
<h4 id="信道能通过的频率范围"><a href="#信道能通过的频率范围" class="headerlink" title="信道能通过的频率范围"></a>信道能通过的频率范围</h4><p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间的清晰界限。</p>
<p><strong>奈氏准则</strong>：算出理想条件下、避免码间串扰，码元的传输速率的上限值。超过此上限，接收端对码元的识别成为不可能。</p>
<p>信道的频带越宽，能通过的信号高频分量越多，就可用更高速率传送码元而不出现码间串扰。</p>
<h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>信噪比就是信号的平均功率和噪声的平均功率之比，记为$S/N$。</p>
<p>$$<br>\text{信噪比(dB)} = 10 \log_{10}(S/N) \text{(dB)}<br>$$</p>
<h4 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h4><p><strong>信道的极限信息传输速率</strong>$C$：</p>
<p>$$<br>C = W \log_2(1 + S/N) \text{(bit/s)}<br>$$</p>
<p>$W$是信道的带宽(Hz)，S是信道内所传信号的平均功率，N是信道内高斯噪声功率。</p>
<p>只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p>
<p>要提高信息的传输速率，还可用编码的方法让每一个码元携带更多比特的信息量。</p>
<h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><p><strong>传输媒体</strong>（传输介质，传输媒介）是发送器和接收器之间的物理通路。可分为两大类：<strong>引导型（guided）</strong>，<strong>非引导型</strong>。</p>
<p>引导型沿着固体媒体传播；非引导型指向自由空间，无线传输。</p>
<h3 id="引导型传输媒体"><a href="#引导型传输媒体" class="headerlink" title="引导型传输媒体"></a>引导型传输媒体</h3><ol>
<li><strong>双绞线（twisted pairs）</strong>：最常用，便宜，性能不错。距离太长时需要放大器（模拟传输）或中继器（数字传输），加粗导线。<strong>屏蔽双绞线（STP，Shielded Twisted Pair）</strong>；<strong>无屏蔽双绞线（UTP，Unshielded Twisted Pair）</strong>。</li>
<li><strong>同轴电缆（coaxial cable）</strong></li>
<li><strong>光缆（fiber cable）</strong></li>
</ol>
<h3 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h3><p>短波（高频）通信：靠电离层的反射；多径效应，质量较差，低速传输。</p>
<p> 微波通信：  </p>
<ol>
<li>地面微波接力通信</li>
<li>卫星通信</li>
</ol>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol>
<li><strong>频分复用（FDM, Frequency Division Multiplexing）</strong>：用户始终占用不同频带</li>
<li><strong>时分复用（TDM）</strong>：更有利于数字信号的传输。利用率不高，若用户太多则时隙太短。</li>
<li><strong>统计时分复用（STDM, Statistic）</strong>：保存用户信息头，有额外花销。</li>
<li><strong>波分复用（WDM, Wavelength Division Multiplexing）</strong>：光的频分复用。光载波频率很高，因此常用波长。</li>
<li><strong>密集波分复用（DWDN, Dense）</strong>：一根光纤上复用几十或更多路。</li>
<li><strong>码分复用（CDM, Code），码分多址CDMA（Code Division Multple Access）</strong>：频谱类似于白噪声，不易被发现；抗干扰能力强。</li>
</ol>
<h2 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h2><h2 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h2><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p><strong>非对称数字用户线ADSL（Asymmetric Digital Subscriber Line）</strong>技术是用数字技术对线有的模拟电话用户线进行改造，使其承载宽带数字业务。</p>
<p>ADSL传输距离取决于数据率和用户线的线径。实际最高数据传输速率还与用户线上的信噪比密切相关。</p>
<p><strong>离散多音调 DMT（Discrete Multi-Tone）</strong>调制技术：频分复用（24kHz - 1.1MHz）划分为许多子信道。相当于许多的调制解调器并行地传送数据。</p>
<p>ADSL自适应地调整可用频率以避开干扰，可见不能保证固定的数据率</p>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>ICMP属于网络层</li>
<li>SDLC, PPP, HDLC属于数据链路层</li>
<li>红外线在光纤中衰减。现有波段是0.85，1.30，1.55（微米，e-6）</li>
<li>电路交换不使用储存转发传输技术。</li>
<li>10base5，一种以太网标准，该标准用于使用粗同轴电缆（Thick coaxialcable）、速度为10Mbps的基带局域网络，基于曼彻斯特编码。在总线型网络中，最远传输距离为500米。</li>
<li>波特率（baud rate）为1000的信道，若其电平级数为16（2^4），则数据率（data rate）可达4Kbps。</li>
<li>影响数据传输率的因素有信噪比、频率带宽、调制效率（Modulation rate）。不受传播速率影响。</li>
<li>频分复用时，最左右两侧可不设置保护频段。</li>
<li><img src="./%E7%94%B5%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90.png" alt="电话系统结构"></li>
<li>光纤具有较好的抗干扰性</li>
<li>二元信号，3KHz信道，信噪比S/N 31，最大传输数据率为6Kbps。（当做无噪声信道计算）</li>
<li>E1载波，2.048Mbps速率的PCM载波，同步时分复用，30个话音信道（64K）和两个控制信道（16K）。  开始和中间各有8位分别做同步和信令；30路8位数据；组成一帧，256位，每一帧125us时间（每秒8000帧）。 开销占比2/32 = 6.25%， 有效数据率1.92Mbps。</li>
<li>T1载波，24个信道（每个8bit），外加1bit帧同步数据，共193bit每帧。每个8bit中有1bit是控制数据。对一路语音通道，数据比特率是7b/125us=56kb/s。总的比特率193b/125us=1.544Mb/s。开销占比(1*24+1)/193 = 13%。</li>
<li><img src="./%E4%BF%A1%E9%81%93%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87.png" alt="信道最大传输速率"></li>
<li>物理层关心在一个通信信道上传输纯比特。</li>
</ol>
<h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3 数据链路层"></a>3 数据链路层</h1><p>主要信道类型：  </p>
<ol>
<li>点对点信道</li>
<li>广播信道</li>
</ol>
<h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>数据链路 = 物理链路 + 通信协议</p>
<p>常用<strong>网络适配器</strong>实现这些硬件和软件，适配器也含有物理层的功能。</p>
<p>网络层交下来的数据构成<strong>帧</strong>——数据链路层的协议数据单元。 帧上交到网络层组成IP数据包（数据包、分组、包）。</p>
<p>点对点信道在数据链路层通信时的主要步骤：  </p>
<ol>
<li>网络层（IP数据报）-&gt;数据链路层</li>
<li>数据链路层添加首部尾部，成帧</li>
<li>帧发送到另一结点</li>
<li>接受者的数据链路层检错（有错则丢弃帧），提取IP数据报-&gt;网络层</li>
</ol>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ol>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ol>
<p>封装成帧：</p>
<p>链路层协议规定了<strong>最大传输单元（MTU, Maximum Transfer Unit）</strong>，表示帧能容纳的最大数据（不计首部和尾部）。</p>
<p>如果数据是ASCII编码的文本文件，帧头标记是<strong>SOH(Start Of Header, 0x01)<strong>，帧尾标记是</strong>EOT(End Of Transmission，0x04)</strong> 。</p>
<p>透明传输：</p>
<p>若文本无需处理（不会出现SOH和EOT），则传输是<strong>透明传输</strong>。</p>
<p>若文本无法透明传输，可以用<strong>字节填充（byte stuffing）</strong>或<strong>字符填充（character stuffing）</strong>。在特殊字符前插入<strong>转义字符</strong>“<strong>ESC（0x1B）</strong>”。例如文本含&quot;0x1B&quot;，就传输 &quot;0x1B 0x1B&quot;。</p>
<p>数据链路层还原IP数据报时需要去除转义信息。</p>
<p>差错检测：</p>
<p><strong>误码率（BER, Bit Error Rate）</strong>指单位时间内错误比特的比率。</p>
<p><strong>循环冗余检验（CRC, Cyclic Redundancy）</strong></p>
<p>假设传送数据$M$，<em>事先约定</em>除数$P\text（n+1位二进制）$，做异或取模$R\text{(n位二进制)} =  2^nM \mod P$。</p>
<p>$R$作为<strong>帧检验序列（FCS, Frame Check Sequence）</strong>，也放在数据末尾。</p>
<p>接收端直接做异或取模，若无差错，余数为0。</p>
<p>用多项式表示，除数$P=1100=X^3 + X^2 + 1$。</p>
<p>现在可以近似认为“凡是接收端数据链路层接收的帧均无差错”。但尚未考虑<strong>帧丢失、重复、失序</strong>等问题，即非<strong>可靠传输</strong>。</p>
<p>OSI要求可靠传输，因此有CRC，<strong>帧编号、确认</strong>和<strong>重传机制</strong>。但现在的数据链路层不使用确认和重传，而将差错交给上层协议（如运输层TCP）来处理。</p>
<h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP协议是用户和ISP通信时使用的数据链路层协议。</p>
<h3 id="PPP协议的特点"><a href="#PPP协议的特点" class="headerlink" title="PPP协议的特点"></a>PPP协议的特点</h3><ol>
<li>简单。将繁杂任务丢给TCP/IP。不纠错，无序号，无流量控制。仅做CRC检验。</li>
<li>封装成帧。使用帧定界符。</li>
<li>透明性。规避文本出现的帧定界符。</li>
<li>支持多种网络层协议，在同一物理链路上。</li>
<li>支持多种链路。</li>
<li>差错检测。立即丢弃错误帧。</li>
<li>检测连接状态。及时发现链路故障或恢复。</li>
<li>最大传送单元MTU的标准默认值。</li>
<li>网络层地址协商。使通信的两个网络层知道或配置彼此的网络层地址。</li>
<li>数据压缩协商。</li>
</ol>
<p>PPP不需要的功能：  </p>
<ol>
<li>纠错</li>
<li>流量控制</li>
<li>序号（PPP不是可靠传输协议）</li>
<li>多点线路</li>
<li>半双工或单工链路（PPP仅支持全双工链路）</li>
</ol>
<p>PPP协议的组成：  </p>
<ol>
<li>IP数据包封装到串行链路的方法。PPP既支持异步链路（无奇偶校验的8比特数据），也支持面向比特的同步链路。</li>
<li><strong>链路控制协议LCP（Link Control Protocol）</strong>。建立、配置和测试数据链路连接。</li>
<li><strong>网络控制协议NCP（Network Control Protocol）</strong>。用来支持不同的网络层协议。</li>
</ol>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><p><img src="./PPP%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="PPP协议的帧格式"></p>
<p>当“协议”为0x0021就是IP数据包，<br>为0xC021就是LCP数据，<br>为0x8021就是网络层的控制数据。</p>
<p>字节填充：</p>
<p>异步：  </p>
<ol>
<li>0x7E -&gt; (0x7D, 0x5E)</li>
<li>0x7D -&gt; (0x7D, 0x5D)</li>
<li>ASCII控制字符（小于0x20） -&gt; (0x7D 0x??)</li>
</ol>
<p>零比特填充： 用于SONET/SDH链路，同步传输<br>信息字段中5个连续的1后插入一个0。有效避开了0x7E。</p>
<h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><p><img src="./PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="PPP协议的状态图"></p>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><ol>
<li>selective repeat protocol 最大接受窗口为$2^M-1$</li>
<li>Go-Back-N 最大接收窗口是$2^{M-1}$（默认接收窗口大小 = 发送窗口大小）</li>
<li>CRC异或取模。别忘了先左移n位</li>
<li>纠错需要距离为2d+1比特的编码</li>
<li>检测需要距离为d+1比特的编码</li>
<li>数据链路层的功能：为网络层提供明确的服务接口；调节数据流，以帮助慢速接收者不被淹没。</li>
<li>处理传输错误</li>
<li>PPP提供了NCP，LCP和帧的封装方法</li>
<li>？？？PPP提供了协商网络层选项的方法（而不是SLIP, BOOTP, HDLC）</li>
<li>PPP, HDLC, SDLC(同步) 属于数据链路层。ICMP属于网络层。</li>
<li>PPP帧包括flags，address，control，protocol，payload，checksum。</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++20 Coroutine</title>
    <url>/2021/11/18/C-20-Coroutine/</url>
    <content><![CDATA[<blockquote>
<p><strong>协程</strong>(coroutine)是能够暂停和恢复的函数。</p>
</blockquote>
<p>协程是<strong>线程阻塞造成性能下降</strong>的最佳解决方案，尤其是应用在静态线程池中。</p>
<span id="more"></span>

<small>

<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>GoLang 设计的 goroutine 简单好用，大名鼎鼎；虚拟机语言（例如 C#，Javascript，Java）的协程更是逆天改命，强势占领高性能并发的高地；机器队这边简直神速，而我们的人工队 C++ 在干什么呢，不会还没做完 STL network 吧，不会连 <code>format</code> 的编译器支持都没有吧，不会还没推广 <code>import &lt;module&gt;</code> 吧 🥵🥵🥵……</p>
</small>

<h2 id="C-的协程"><a href="#C-的协程" class="headerlink" title="C++的协程"></a>C++的协程</h2><p>C++的协程是：</p>
<ol>
<li>对称的。一个协程暂停后，可返回 caller 或恢复任意协程。</li>
<li>语言级特性。编译器知道你在使用协程。然而不比库强到哪里去。</li>
<li>无栈(Stackless) 的。没有独立运行时栈，无惧爆栈，调度成本低。</li>
</ol>
<p>一个协程在被命令「暂停」时，会保证将数据和当前运行位置保存在堆内存（以便恢复现场），然后转移运行权。</p>
<p>协程允许程序员更美观地编写异步代码，也使懒惰求值的算法成为可能。</p>
<p>当一个函数出现以下三种关键字之一，它就是协程：</p>
<ol>
<li><code>co_await</code> 暂停（直到被命令「恢复」）。</li>
<li><code>co_yield</code> 暂停同时返回一个值。</li>
<li><code>co_return</code> 结束整个协程并返回一个值。</li>
</ol>
<h2 id="协程的限制"><a href="#协程的限制" class="headerlink" title="协程的限制"></a>协程的限制</h2><ol>
<li>不能使用变参模板</li>
<li>不能使用 <code>return</code></li>
<li>不能使用占位符返回类型 （<code>auto</code> 或者 Concept）</li>
<li>不能是 constexpr 函数</li>
<li>不能是构造函数或者析构函数</li>
<li>不能是 <code>main</code> 函数</li>
</ol>
<h2 id="协程的运行过程"><a href="#协程的运行过程" class="headerlink" title="协程的运行过程"></a>协程的运行过程</h2><p>所有协程必须关联着几个对象：</p>
<ol>
<li><strong>promise object</strong>，在协程内部进行操作，协程向其写入结果或者异常。</li>
<li><strong>coroutine handle</strong>，在协程外部进行操作，用于恢复协程或者销毁协程帧(frame)。</li>
<li><strong>coroutine state</strong>，保存协程的信息，分配于堆内存上（除非被优化），对程序员不可见。具体保存着：<ol>
<li>promise object</li>
<li>所有协程参数（按值复制或移动）</li>
<li>记录暂停点的状态机</li>
<li>局部变量和临时变量</li>
</ol>
</li>
</ol>
<hr>
<p>当协程「开始」时，它会：</p>
<ol>
<li>使用 <code>operater new</code> 来构造 coroutine state。</li>
<li>将所有协程参数拷贝或移动到 coroutine state。<em>小心发生「垂悬引用」，尤其在协程恢复后。</em></li>
<li>构造 promise object。优先调用接受所有协程参数的构造函数，否则调用默认构造函数。</li>
<li>调用 <code>promise.get_return_object()</code>，其结果保存为本地变量。此结果在第一次暂停时会返回给 caller。包括这一步和以前的步骤，所有异常都会抛给 caller，而不是放入 promise object。</li>
<li>调用 <code>promise.initial_suspend()</code>，紧接着 <code>co_await</code> 它。<em>常见的返回值是 <code>suspend_always</code> 用于懒汉协程，或者 <code>suspend_never</code> 用于饿汉协程</em></li>
<li>当 <code>co_await promise.initial_suspend()</code> 恢复后，协程开始运行其函数体。</li>
</ol>
<hr>
<p>当协程到达暂停点，它会：</p>
<ol>
<li>将 return object 返回给执行权所有者，类型应为协程的返回类型，允许发生隐式转换。</li>
</ol>
<hr>
<p>当协程到达 <code>co_return [expr]</code> 语句，它会：</p>
<ol>
<li>调用 <code>promise.return_void()</code>，条件是：<ol>
<li><code>co_return;</code></li>
<li><code>co_return expr</code> 而 expr 的类型是 void</li>
<li>函数体结束</li>
</ol>
</li>
<li>或者调用 <code>promise.return_value(expr)</code>。</li>
<li>析构所有自动变量。</li>
<li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。</li>
</ol>
<hr>
<p>当协程因未捕获异常而结束，它会：</p>
<ol>
<li>捕获这个异常，并在 <code>catch</code> 块中调用 <code>promise.unhandled_exception()</code></li>
<li>调用 <code>promise.final_suspend()</code>，紧接着 <code>co_await</code> 它。此时恢复另一个协程是 UB。</li>
</ol>
<hr>
<p>当 coroutine state 被析构（要么遇到 <code>co_return</code>，要么未捕获异常，在要么被 handle 销毁）时，它会：</p>
<ol>
<li>析构 promise object。</li>
<li>析构所有协程参数。</li>
<li>使用 <code>operator delete</code> 来释放coroutine state。</li>
<li>转移执行权。</li>
</ol>
<h2 id="关于堆分配"><a href="#关于堆分配" class="headerlink" title="关于堆分配"></a>关于堆分配</h2><p>程序员可通过自定义 <code>operator new</code> 来控制 coroutine state 的分配。这部分暂时忽略不讲。</p>
<h2 id="Promise类型推导"><a href="#Promise类型推导" class="headerlink" title="Promise类型推导"></a>Promise类型推导</h2><p>这部分暂时忽略不讲。</p>
<h2 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h2><p>一元运算符 <code>co_await</code> 会暂停协程并将转移执行权。其操作数必须定义 <code>operator co_await</code>，或者能通过当前协程的 <code>Promise::await_transform</code> 转换成这种类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">co_await</span> expr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>首先，<code>expr</code> 要被转换为 awaitable，规则如下：</p>
<ol>
<li>如果 <code>expr</code> 是由 initial suspend point，final suspend point 或者 yield expression 生成的，那么 awaitable 就是 <code>expr</code> 本身。</li>
<li>否则，如果当前协程有定义 <code>Promise::await_transform</code>，那么 awaitable 就是 <code>promise.await_transform(expr)</code>。</li>
<li>否则，awaitable 就是 <code>expr</code> 本身。</li>
</ol>
<p>然后生成一个 awaiter object，规则如下：</p>
<ol>
<li>根据重载解析的结果调用 <code>opeartor co_await(awaitable)</code> 或者 <code>awaitable.operator co_await()</code></li>
<li>如果重载解析找不到函数，那么 awaiter 就是 awaitable 本身。</li>
<li>如果重载解析有歧义，那么程序是 ill-formed。</li>
</ol>
<p>然后，调用 <code>awaiter.await_ready()</code>并判断，决定是否暂停协程：</p>
<ul>
<li>若 <code>false</code>，协程暂停，必要的信息存放于 coroutine state。然后调用 <code>awaiter.await_suspend(handle)</code>。在这个函数中，通过 <code>handle</code> 可以访问 coroutine state，也是这个函数有责任安排协程在某个 executor 上恢复（甚至立即就地恢复），或者干脆销毁协程：<ul>
<li>若 <code>awaiter.await_suspend(handle)</code> 返回 void，执行权立即转移（给 caller/resumer）。</li>
<li>否则若返回 bool，<ul>
<li>若 <code>true</code> 则转移执行权（给 caller/resumer）。</li>
<li>若 <code>false</code> 则恢复当前协程。</li>
</ul>
</li>
<li>否则返回一个 coroutine handle（对应其他协程），调用这个 <code>other_handle.resume()</code>。注意链式调用可能最终恢复当前协程。</li>
<li>当前协程恢复后，返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li>
</ul>
</li>
<li>若 <code>true</code>，协程直接返回 <code>awaiter.await_resume()</code> 作为 <code>co_await expr</code> 的结果。</li>
</ul>
<p>注意在进入 <code>awaiter.await_suspend(handle)</code> 之前，当前协程已经完全暂停，此时当前 handle 可以在线程之间自由传递，并由其他调度者恢复。在这种情况下，协程可能已经被恢复，awaiter 随之已经被析构，所以 <code>await_suspend()</code> 不应再访问 <code>*this</code>。</p>
<h2 id="co-yield"><a href="#co-yield" class="headerlink" title="co_yield"></a>co_yield</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">co_yield</span> expr
<span class="token keyword">co_yield</span> braced<span class="token operator">-</span>init<span class="token operator">-</span>list		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>等价于</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">co_await</span> promise<span class="token punctuation">.</span><span class="token function">yield_value</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

]]></content>
      <tags>
        <tag>语法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
